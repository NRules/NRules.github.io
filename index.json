{
  "api/NRules.Activation.html": {
    "href": "api/NRules.Activation.html",
    "title": "Class Activation | NRules",
    "keywords": "Class Activation Namespace NRules Assembly NRules.dll Represents a match of all rule's conditions. public class Activation : IMatch Inheritance object Activation Implements IMatch Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Facts Facts matched by the rule. public IEnumerable<IFactMatch> Facts { get; } Property Value IEnumerable<IFactMatch> Rule Rule that got activated. public IRuleDefinition Rule { get; } Property Value IRuleDefinition Trigger Event that triggered the match. public MatchTrigger Trigger { get; } Property Value MatchTrigger See Also IMatch IFactMatch"
  },
  "api/NRules.AgendaExpressionEvaluationException.html": {
    "href": "api/NRules.AgendaExpressionEvaluationException.html",
    "title": "Class AgendaExpressionEvaluationException | NRules",
    "keywords": "Class AgendaExpressionEvaluationException Namespace NRules Assembly NRules.dll Represents errors that occur while evaluating agenda expression. [Serializable] public class AgendaExpressionEvaluationException : RuleExpressionEvaluationException, ISerializable Inheritance object Exception RuleExecutionException RuleExpressionEvaluationException AgendaExpressionEvaluationException Implements ISerializable Inherited Members RuleExpressionEvaluationException.Expression Exception.GetBaseException() Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState object.Equals(object) object.Equals(object, object) object.GetHashCode() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors AgendaExpressionEvaluationException(SerializationInfo, StreamingContext) protected AgendaExpressionEvaluationException(SerializationInfo info, StreamingContext context) Parameters info SerializationInfo context StreamingContext Properties Message Gets a message that describes the current exception. public override string Message { get; } Property Value string The error message that explains the reason for the exception, or an empty string (\"\"). RuleName Rule that caused exception. public string RuleName { get; } Property Value string Methods GetObjectData(SerializationInfo, StreamingContext) When overridden in a derived class, sets the SerializationInfo with information about the exception. [SecurityCritical] public override void GetObjectData(SerializationInfo info, StreamingContext context) Parameters info SerializationInfo The SerializationInfo that holds the serialized object data about the exception being thrown. context StreamingContext The StreamingContext that contains contextual information about the source or destination. Exceptions ArgumentNullException The info parameter is a null reference (Nothing in Visual Basic)."
  },
  "api/NRules.AgendaFilters.AgendaContext.html": {
    "href": "api/NRules.AgendaFilters.AgendaContext.html",
    "title": "Class AgendaContext | NRules",
    "keywords": "Class AgendaContext Namespace NRules.AgendaFilters Assembly NRules.dll Context associated with the agenda operation. public class AgendaContext Inheritance object AgendaContext Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString()"
  },
  "api/NRules.AgendaFilters.IAgendaFilter.html": {
    "href": "api/NRules.AgendaFilters.IAgendaFilter.html",
    "title": "Interface IAgendaFilter | NRules",
    "keywords": "Interface IAgendaFilter Namespace NRules.AgendaFilters Assembly NRules.dll Base interface for agenda filters. Agenda filters are applied to rule matches (activations) before they are added to the agenda. If activation does not pass all the filters, it is not added to the agenda, and so the rule will not fire. public interface IAgendaFilter Methods Accept(AgendaContext, Activation) Tests rule activation whether it should be added to the agenda. bool Accept(AgendaContext context, Activation activation) Parameters context AgendaContext Agenda context. activation Activation Rule activation. Returns bool Whether the activation should be added to the agenda - true, or not - false."
  },
  "api/NRules.AgendaFilters.IStatefulAgendaFilter.html": {
    "href": "api/NRules.AgendaFilters.IStatefulAgendaFilter.html",
    "title": "Interface IStatefulAgendaFilter | NRules",
    "keywords": "Interface IStatefulAgendaFilter Namespace NRules.AgendaFilters Assembly NRules.dll Base interface for stateful agenda filters that store some state related to the activations and need to update that state during the activation lifecycle. public interface IStatefulAgendaFilter : IAgendaFilter Inherited Members IAgendaFilter.Accept(AgendaContext, Activation) Methods Remove(AgendaContext, Activation) Called by the engine when activation is removed from the agenda. The agenda filter can use this method to remove any state associated with the activation. void Remove(AgendaContext context, Activation activation) Parameters context AgendaContext Agenda context. activation Activation Rule activation. Remarks This method must not evaluate agenda expressions. Select(AgendaContext, Activation) Called by the engine when activation is selected from the agenda, before rule's actions are executed. void Select(AgendaContext context, Activation activation) Parameters context AgendaContext Agenda context. activation Activation Rule activation. Remarks This method must not evaluate agenda expressions."
  },
  "api/NRules.AgendaFilters.html": {
    "href": "api/NRules.AgendaFilters.html",
    "title": "Namespace NRules.AgendaFilters | NRules",
    "keywords": "Namespace NRules.AgendaFilters Contains types that implement filtering of matched rules as part of rules engine execution. Classes AgendaContext Context associated with the agenda operation. Interfaces IAgendaFilter Base interface for agenda filters. Agenda filters are applied to rule matches (activations) before they are added to the agenda. If activation does not pass all the filters, it is not added to the agenda, and so the rule will not fire. IStatefulAgendaFilter Base interface for stateful agenda filters that store some state related to the activations and need to update that state during the activation lifecycle."
  },
  "api/NRules.Aggregators.AggregateExpressionExtensions.html": {
    "href": "api/NRules.Aggregators.AggregateExpressionExtensions.html",
    "title": "Class AggregateExpressionExtensions | NRules",
    "keywords": "Class AggregateExpressionExtensions Namespace NRules.Aggregators Assembly NRules.dll Extension methods used for working with collections of aggregate expressions. public static class AggregateExpressionExtensions Inheritance object AggregateExpressionExtensions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods Find(IEnumerable<IAggregateExpression>, string) Get an enumerable of matching aggregate expressions. public static IEnumerable<IAggregateExpression> Find(this IEnumerable<IAggregateExpression> expressions, string name) Parameters expressions IEnumerable<IAggregateExpression> The list of aggregate expressions to search through. name string Name of the aggregate expressions to find. Returns IEnumerable<IAggregateExpression> FindSingle(IEnumerable<IAggregateExpression>, string) Get a single matching aggregate expression. public static IAggregateExpression FindSingle(this IEnumerable<IAggregateExpression> expressions, string name) Parameters expressions IEnumerable<IAggregateExpression> The list of aggregate expressions to search through. name string Name of the aggregate expression to find. Returns IAggregateExpression"
  },
  "api/NRules.Aggregators.AggregationAction.html": {
    "href": "api/NRules.Aggregators.AggregationAction.html",
    "title": "Enum AggregationAction | NRules",
    "keywords": "Enum AggregationAction Namespace NRules.Aggregators Assembly NRules.dll Action that aggregation performed on the aggregate, based on added/modified/removed facts. public enum AggregationAction Fields None = 0 No changes at the aggregate level. Added = 1 New aggregate created. Modified = 2 Existing aggregate modified. Removed = 3 Existing aggregate removed."
  },
  "api/NRules.Aggregators.AggregationContext.html": {
    "href": "api/NRules.Aggregators.AggregationContext.html",
    "title": "Class AggregationContext | NRules",
    "keywords": "Class AggregationContext Namespace NRules.Aggregators Assembly NRules.dll Context associated with the aggregation operation. public class AggregationContext Inheritance object AggregationContext Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString()"
  },
  "api/NRules.Aggregators.AggregationResult.html": {
    "href": "api/NRules.Aggregators.AggregationResult.html",
    "title": "Class AggregationResult | NRules",
    "keywords": "Class AggregationResult Namespace NRules.Aggregators Assembly NRules.dll Result of the aggregation. public class AggregationResult Inheritance object AggregationResult Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields Empty public static readonly AggregationResult[] Empty Field Value AggregationResult[] Properties Action Action that aggregation performed on the aggregate. public AggregationAction Action { get; } Property Value AggregationAction Aggregate Resulting aggregate. public object Aggregate { get; } Property Value object Previous Previous aggregate. public object Previous { get; } Property Value object Source Facts that produced this aggregation result. public IEnumerable<IFact> Source { get; } Property Value IEnumerable<IFact> Methods Added(object, IEnumerable<IFact>) Constructs an aggregation result that indicates a new aggregate. public static AggregationResult Added(object result, IEnumerable<IFact> source) Parameters result object Aggregate. source IEnumerable<IFact> Aggregate source facts. Returns AggregationResult Aggregation result. Modified(object, object, IEnumerable<IFact>) Constructs an aggregation result that indicates a modification at the aggregate level. public static AggregationResult Modified(object result, object previous, IEnumerable<IFact> source) Parameters result object Aggregate. previous object Previous aggregate. source IEnumerable<IFact> Aggregate source facts. Returns AggregationResult Aggregation result. None(object, IEnumerable<IFact>) Constructs an aggregation result that indicates no changes at the aggregate level. public static AggregationResult None(object result, IEnumerable<IFact> source) Parameters result object Aggregate. source IEnumerable<IFact> Aggregate source facts. Returns AggregationResult Aggregation result. Removed(object) Constructs an aggregation result that indicates an aggregate was removed. public static AggregationResult Removed(object result) Parameters result object Aggregate. Returns AggregationResult Aggregation result."
  },
  "api/NRules.Aggregators.AggregatorRegistry.html": {
    "href": "api/NRules.Aggregators.AggregatorRegistry.html",
    "title": "Class AggregatorRegistry | NRules",
    "keywords": "Class AggregatorRegistry Namespace NRules.Aggregators Assembly NRules.dll Registry of custom aggregator factories. public class AggregatorRegistry Inheritance object AggregatorRegistry Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods RegisterFactory(string, Type) Registers a custom aggregator factory type, so that rules that use it can be successfully compiled. public void RegisterFactory(string name, Type factoryType) Parameters name string Name of the custom aggregator. factoryType Type Custom aggregator factory type."
  },
  "api/NRules.Aggregators.IAggregateExpression.html": {
    "href": "api/NRules.Aggregators.IAggregateExpression.html",
    "title": "Interface IAggregateExpression | NRules",
    "keywords": "Interface IAggregateExpression Namespace NRules.Aggregators Assembly NRules.dll Expression used by an aggregator, compiled to an executable form. public interface IAggregateExpression Properties Name Name of the aggregate expression. string Name { get; } Property Value string Methods Invoke(AggregationContext, ITuple, IFact) Invokes the expression with the given inputs. object Invoke(AggregationContext context, ITuple tuple, IFact fact) Parameters context AggregationContext Aggregation context. tuple ITuple Partial match up to the aggregate element. fact IFact Fact being processed by the aggregate element. Returns object Result of the expression."
  },
  "api/NRules.Aggregators.IAggregator.html": {
    "href": "api/NRules.Aggregators.IAggregator.html",
    "title": "Interface IAggregator | NRules",
    "keywords": "Interface IAggregator Namespace NRules.Aggregators Assembly NRules.dll Base interface for fact aggregators. An aggregator is a stateful element of the rules engine, that receives matching facts of a particular kind, and can combine them into a synthetic fact, that is then used by the downstream logic in the rule. Aggregator also receives updates and removals for the matching facts, so that it can keep the corresponding aggregate facts in sync. An aggregator must be supplemented by a corresponding implementation of IAggregatorFactory that knows how to create new instances of the aggregator. public interface IAggregator Methods Add(AggregationContext, ITuple, IEnumerable<IFact>) Called by the rules engine when new facts enter corresponding aggregator. IEnumerable<AggregationResult> Add(AggregationContext context, ITuple tuple, IEnumerable<IFact> facts) Parameters context AggregationContext Aggregation context. tuple ITuple Tuple containing preceding partial matches. facts IEnumerable<IFact> New facts to add to the aggregate. Returns IEnumerable<AggregationResult> Results of the operation on the aggregate, based on the added facts. Modify(AggregationContext, ITuple, IEnumerable<IFact>) Called by the rules engine when existing facts are modified in the corresponding aggregator. IEnumerable<AggregationResult> Modify(AggregationContext context, ITuple tuple, IEnumerable<IFact> facts) Parameters context AggregationContext Aggregation context. tuple ITuple Tuple containing preceding partial matches. facts IEnumerable<IFact> Existing facts to update in the aggregate. Returns IEnumerable<AggregationResult> Results of the operation on the aggregate, based on the modified facts. Remove(AggregationContext, ITuple, IEnumerable<IFact>) Called by the rules engine when existing facts are removed from the corresponding aggregator. IEnumerable<AggregationResult> Remove(AggregationContext context, ITuple tuple, IEnumerable<IFact> facts) Parameters context AggregationContext Aggregation context. tuple ITuple Tuple containing preceding partial matches. facts IEnumerable<IFact> Existing facts to remove from the aggregate. Returns IEnumerable<AggregationResult> Results of the operation on the aggregate, based on the removed facts."
  },
  "api/NRules.Aggregators.IAggregatorFactory.html": {
    "href": "api/NRules.Aggregators.IAggregatorFactory.html",
    "title": "Interface IAggregatorFactory | NRules",
    "keywords": "Interface IAggregatorFactory Namespace NRules.Aggregators Assembly NRules.dll Base interface for aggregator factories. Aggregator factory constructs new instances of IAggregator of a given type, so that they can accumulate aggregation results. An IAggregatorFactory type must either be registered in AggregatorRegistry, or provided in the canonical rule model via CustomFactoryType. If both are provided, the aggregator factory at the AggregateElement level takes precedence. public interface IAggregatorFactory Methods Compile(AggregateElement, IEnumerable<IAggregateExpression>) Called by the rules engine to compile the aggregator factory before it is used for the first time. void Compile(AggregateElement element, IEnumerable<IAggregateExpression> compiledExpressions) Parameters element AggregateElement Corresponding aggregate element from the rule definition. compiledExpressions IEnumerable<IAggregateExpression> Aggregate expressions compiled to an executable form. Create() Creates a new aggregator instance. This method is called by the engine for each new combination of preceding partial matches, so that a new instance of the aggregator is created to accumulate the results. IAggregator Create() Returns IAggregator Aggregator instance."
  },
  "api/NRules.Aggregators.html": {
    "href": "api/NRules.Aggregators.html",
    "title": "Namespace NRules.Aggregators | NRules",
    "keywords": "Namespace NRules.Aggregators Contains types that implement aggregation of facts as part of rules engine execution. Classes AggregateExpressionExtensions Extension methods used for working with collections of aggregate expressions. AggregationContext Context associated with the aggregation operation. AggregationResult Result of the aggregation. AggregatorRegistry Registry of custom aggregator factories. Interfaces IAggregateExpression Expression used by an aggregator, compiled to an executable form. IAggregator Base interface for fact aggregators. An aggregator is a stateful element of the rules engine, that receives matching facts of a particular kind, and can combine them into a synthetic fact, that is then used by the downstream logic in the rule. Aggregator also receives updates and removals for the matching facts, so that it can keep the corresponding aggregate facts in sync. An aggregator must be supplemented by a corresponding implementation of IAggregatorFactory that knows how to create new instances of the aggregator. IAggregatorFactory Base interface for aggregator factories. Aggregator factory constructs new instances of IAggregator of a given type, so that they can accumulate aggregation results. An IAggregatorFactory type must either be registered in AggregatorRegistry, or provided in the canonical rule model via CustomFactoryType. If both are provided, the aggregator factory at the AggregateElement level takes precedence. Enums AggregationAction Action that aggregation performed on the aggregate, based on added/modified/removed facts."
  },
  "api/NRules.BatchOptions.html": {
    "href": "api/NRules.BatchOptions.html",
    "title": "Enum BatchOptions | NRules",
    "keywords": "Enum BatchOptions Namespace NRules Assembly NRules.dll Defines how batch insert/update/retract of facts behaves. Any fact that already exists in the session during insert is considered failed. Similarly, a fact that does not exist in the session during update or retract is also considered failed. By default, any failed fact in a batch operation fails the whole operation, and no facts are propagated. This behavior can be changed using BatchOptions. public enum BatchOptions Fields AllOrNothing = 0 Default behavior of batch operations, where the operation is either applied to all facts in the batch or none of them. SkipFailed = 1 Changes the behavior of fact propagation, where failed facts are skipped, and the rest are propagated."
  },
  "api/NRules.Diagnostics.AgendaEventArgs.html": {
    "href": "api/NRules.Diagnostics.AgendaEventArgs.html",
    "title": "Class AgendaEventArgs | NRules",
    "keywords": "Class AgendaEventArgs Namespace NRules.Diagnostics Assembly NRules.dll Information related to agenda events. public class AgendaEventArgs : EventArgs Inheritance object EventArgs AgendaEventArgs Inherited Members EventArgs.Empty object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors AgendaEventArgs(IMatch) Initializes a new instance of the AgendaEventArgs class. public AgendaEventArgs(IMatch match) Parameters match IMatch Rule match related to the event. Properties Facts Facts related to the event. public IEnumerable<IFactMatch> Facts { get; } Property Value IEnumerable<IFactMatch> Match Rule match related to the event. public IMatch Match { get; } Property Value IMatch Rule Rule related to the event. public IRuleDefinition Rule { get; } Property Value IRuleDefinition"
  },
  "api/NRules.Diagnostics.AgendaExpressionErrorEventArgs.html": {
    "href": "api/NRules.Diagnostics.AgendaExpressionErrorEventArgs.html",
    "title": "Class AgendaExpressionErrorEventArgs | NRules",
    "keywords": "Class AgendaExpressionErrorEventArgs Namespace NRules.Diagnostics Assembly NRules.dll Information related to error events raised during agenda expression evaluation. public class AgendaExpressionErrorEventArgs : AgendaExpressionEventArgs, IRecoverableError Inheritance object EventArgs ExpressionEventArgs AgendaExpressionEventArgs AgendaExpressionErrorEventArgs Implements IRecoverableError Inherited Members AgendaExpressionEventArgs.Rule AgendaExpressionEventArgs.Facts AgendaExpressionEventArgs.Match ExpressionEventArgs.Expression ExpressionEventArgs.Exception ExpressionEventArgs.Arguments ExpressionEventArgs.Result EventArgs.Empty object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors AgendaExpressionErrorEventArgs(Expression, Exception, object[], IMatch) Initializes a new instance of the AgendaExpressionErrorEventArgs class. public AgendaExpressionErrorEventArgs(Expression expression, Exception exception, object[] arguments, IMatch match) Parameters expression Expression Expression related to the event. exception Exception Exception related to the event. arguments object[] Expression arguments. match IMatch Rule match related to the event. Properties IsHandled Flag that indicates whether the exception was handled. If handler sets this to true then engine continues execution, otherwise exception is rethrown and terminates engine's execution. public bool IsHandled { get; set; } Property Value bool"
  },
  "api/NRules.Diagnostics.AgendaExpressionEventArgs.html": {
    "href": "api/NRules.Diagnostics.AgendaExpressionEventArgs.html",
    "title": "Class AgendaExpressionEventArgs | NRules",
    "keywords": "Class AgendaExpressionEventArgs Namespace NRules.Diagnostics Assembly NRules.dll Information related to events raised during agenda expression evaluation. public class AgendaExpressionEventArgs : ExpressionEventArgs Inheritance object EventArgs ExpressionEventArgs AgendaExpressionEventArgs Derived AgendaExpressionErrorEventArgs Inherited Members ExpressionEventArgs.Expression ExpressionEventArgs.Exception ExpressionEventArgs.Arguments ExpressionEventArgs.Result EventArgs.Empty object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors AgendaExpressionEventArgs(Expression, Exception, object[], object, IMatch) Initializes a new instance of the AgendaExpressionEventArgs class. public AgendaExpressionEventArgs(Expression expression, Exception exception, object[] arguments, object result, IMatch match) Parameters expression Expression Expression related to the event. exception Exception Exception related to the event. arguments object[] Expression arguments. result object Expression result. match IMatch Rule match related to the event. Properties Facts Facts related to the event. public IEnumerable<IFactMatch> Facts { get; } Property Value IEnumerable<IFactMatch> Match Rule match related to the event. public IMatch Match { get; } Property Value IMatch Rule Rule related to the event. public IRuleDefinition Rule { get; } Property Value IRuleDefinition"
  },
  "api/NRules.Diagnostics.Dgml.DgmlWriter.html": {
    "href": "api/NRules.Diagnostics.Dgml.DgmlWriter.html",
    "title": "Class DgmlWriter | NRules",
    "keywords": "Class DgmlWriter Namespace NRules.Diagnostics.Dgml Assembly NRules.dll Creates a DGML document writer that can be used to serialize a Rete graph for a given rules session into XML. public class DgmlWriter Inheritance object DgmlWriter Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors DgmlWriter(ReteGraph) Creates an instance of a DgmlWriter for a given session schema. public DgmlWriter(ReteGraph schema) Parameters schema ReteGraph Rules session schema. Methods GetContents() Retrieves a serialized DGML graph as an XML string. public string GetContents() Returns string Contents of the serialized DGML graph as an XML string. SetMetricsProvider(IMetricsProvider) Sets the IMetricsProvider to retrieve performance metrics for serialized nodes, so that performance metrics are included in the output. public void SetMetricsProvider(IMetricsProvider metricsProvider) Parameters metricsProvider IMetricsProvider Performance metrics provider or null to exclude performance metrics from the output. SetRuleFilter(IEnumerable<string>) Sets a filter for Rete graph nodes, such that only nodes that belong to the given set of rules is serialized, along with the connecting graph edges. public void SetRuleFilter(IEnumerable<string> ruleNames) Parameters ruleNames IEnumerable<string> Set of rules to use as a filter, or null to remove the filter. WriteAllText(string) Writes DGML graph representing a given rules session to a file. public void WriteAllText(string fileName) Parameters fileName string File to write the session to. WriteXml(XmlWriter) Writes DGML graph representing a given rules session to the provided XmlWriter. public void WriteXml(XmlWriter writer) Parameters writer XmlWriter XmlWriter to write the session to."
  },
  "api/NRules.Diagnostics.Dgml.html": {
    "href": "api/NRules.Diagnostics.Dgml.html",
    "title": "Namespace NRules.Diagnostics.Dgml | NRules",
    "keywords": "Namespace NRules.Diagnostics.Dgml Contains types that enable exporting rete network diagnostics as a DGML document. Classes DgmlWriter Creates a DGML document writer that can be used to serialize a Rete graph for a given rules session into XML."
  },
  "api/NRules.Diagnostics.ExpressionEventArgs.html": {
    "href": "api/NRules.Diagnostics.ExpressionEventArgs.html",
    "title": "Class ExpressionEventArgs | NRules",
    "keywords": "Class ExpressionEventArgs Namespace NRules.Diagnostics Assembly NRules.dll Information related to expression evaluation events. public class ExpressionEventArgs : EventArgs Inheritance object EventArgs ExpressionEventArgs Derived AgendaExpressionEventArgs LhsExpressionEventArgs RhsExpressionEventArgs Inherited Members EventArgs.Empty object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors ExpressionEventArgs(Expression, Exception, object[], object) Initializes a new instance of the ExpressionEventArgs class. public ExpressionEventArgs(Expression expression, Exception exception, object[] arguments, object result) Parameters expression Expression Expression that caused the event. exception Exception Exception thrown during expression evaluation. arguments object[] Arguments passed to expression during evaluation. result object Result of expression evaluation. Properties Arguments Arguments passed to the expression during evaluation. public virtual IEnumerable<object> Arguments { get; } Property Value IEnumerable<object> Exception Exception thrown during expression evaluation. public Exception Exception { get; } Property Value Exception Expression Expression that caused the event; public Expression Expression { get; } Property Value Expression Result Result of expression evaluation. public object Result { get; } Property Value object"
  },
  "api/NRules.Diagnostics.IEventProvider.html": {
    "href": "api/NRules.Diagnostics.IEventProvider.html",
    "title": "Interface IEventProvider | NRules",
    "keywords": "Interface IEventProvider Namespace NRules.Diagnostics Assembly NRules.dll Provider of rules session events. public interface IEventProvider Events ActivationCreatedEvent Raised when a new rule activation is created. A new activation is created when a new set of facts (tuple) matches a rule. The activation is placed on the agenda and becomes a candidate for firing. event EventHandler<AgendaEventArgs> ActivationCreatedEvent Event Type EventHandler<AgendaEventArgs> ActivationDeletedEvent Raised when an existing activation is deleted. An activation is deleted when a previously matching set of facts (tuple) no longer matches the rule due to updated or retracted facts. The activation is removed from the agenda and is no longer a candidate for firing. event EventHandler<AgendaEventArgs> ActivationDeletedEvent Event Type EventHandler<AgendaEventArgs> ActivationUpdatedEvent Raised when an existing activation is updated. An activation is updated when a previously matching set of facts (tuple) is updated and it still matches the rule. The activation is updated in the agenda and remains a candidate for firing. event EventHandler<AgendaEventArgs> ActivationUpdatedEvent Event Type EventHandler<AgendaEventArgs> AgendaExpressionEvaluatedEvent Raised when agenda expression is evaluated. This event is raised on both, successful expression evaluations, and on exceptions. event EventHandler<AgendaExpressionEventArgs> AgendaExpressionEvaluatedEvent Event Type EventHandler<AgendaExpressionEventArgs> See Also IAgendaFilter AgendaExpressionFailedEvent Raised when agenda expression evaluation threw an exception. Gives observer of the event control over handling of the exception. event EventHandler<AgendaExpressionErrorEventArgs> AgendaExpressionFailedEvent Event Type EventHandler<AgendaExpressionErrorEventArgs> See Also IAgendaFilter FactInsertedEvent Raised after a new fact is inserted into working memory. event EventHandler<WorkingMemoryEventArgs> FactInsertedEvent Event Type EventHandler<WorkingMemoryEventArgs> FactInsertingEvent Raised before a new fact is inserted into working memory. event EventHandler<WorkingMemoryEventArgs> FactInsertingEvent Event Type EventHandler<WorkingMemoryEventArgs> FactRetractedEvent Raised after an existing fact is retracted from the working memory. event EventHandler<WorkingMemoryEventArgs> FactRetractedEvent Event Type EventHandler<WorkingMemoryEventArgs> FactRetractingEvent Raised before an existing fact is retracted from the working memory. event EventHandler<WorkingMemoryEventArgs> FactRetractingEvent Event Type EventHandler<WorkingMemoryEventArgs> FactUpdatedEvent Raised after an existing fact is updated in the working memory. event EventHandler<WorkingMemoryEventArgs> FactUpdatedEvent Event Type EventHandler<WorkingMemoryEventArgs> FactUpdatingEvent Raised before an existing fact is updated in the working memory. event EventHandler<WorkingMemoryEventArgs> FactUpdatingEvent Event Type EventHandler<WorkingMemoryEventArgs> LhsExpressionEvaluatedEvent Raised when left-hand side expression is evaluated. This event is raised on both, successful expression evaluations, and on exceptions. event EventHandler<LhsExpressionEventArgs> LhsExpressionEvaluatedEvent Event Type EventHandler<LhsExpressionEventArgs> LhsExpressionFailedEvent Raised when left-hand side expression evaluation threw an exception. Gives observer of the event control over handling of the exception. event EventHandler<LhsExpressionErrorEventArgs> LhsExpressionFailedEvent Event Type EventHandler<LhsExpressionErrorEventArgs> RhsExpressionEvaluatedEvent Raised when right-hand side expression is evaluated. This event is raised on both, successful expression evaluations, and on exceptions. event EventHandler<RhsExpressionEventArgs> RhsExpressionEvaluatedEvent Event Type EventHandler<RhsExpressionEventArgs> See Also IActionInterceptor RhsExpressionFailedEvent Raised when right-hand side expression evaluation threw an exception. Gives observer of the event control over handling of the exception. event EventHandler<RhsExpressionErrorEventArgs> RhsExpressionFailedEvent Event Type EventHandler<RhsExpressionErrorEventArgs> See Also IActionInterceptor RuleFiredEvent Raised after a rule has fired and all its actions executed. event EventHandler<AgendaEventArgs> RuleFiredEvent Event Type EventHandler<AgendaEventArgs> RuleFiringEvent Raised before a rule is about to fire. event EventHandler<AgendaEventArgs> RuleFiringEvent Event Type EventHandler<AgendaEventArgs>"
  },
  "api/NRules.Diagnostics.IMetricsProvider.html": {
    "href": "api/NRules.Diagnostics.IMetricsProvider.html",
    "title": "Interface IMetricsProvider | NRules",
    "keywords": "Interface IMetricsProvider Namespace NRules.Diagnostics Assembly NRules.dll Provides access to performance metrics associated with individual nodes in the Rete network used to execute the rules. public interface IMetricsProvider Methods FindByNodeId(int) Retrieves performance metrics for a given Rete network node by the node id. INodeMetrics FindByNodeId(int nodeId) Parameters nodeId int Id of the node for which to retrieve the metrics. Returns INodeMetrics Rete network node performance metrics or null. GetAll() Retries performance metrics for all nodes in the Rete network. IEnumerable<INodeMetrics> GetAll() Returns IEnumerable<INodeMetrics> Collection of Rete network node metrics. Reset() Resets cumulative performance metrics associated with all nodes in the network. void Reset()"
  },
  "api/NRules.Diagnostics.INodeMetrics.html": {
    "href": "api/NRules.Diagnostics.INodeMetrics.html",
    "title": "Interface INodeMetrics | NRules",
    "keywords": "Interface INodeMetrics Namespace NRules.Diagnostics Assembly NRules.dll Performance metrics associated with a given node in the Rete network. public interface INodeMetrics Properties ElementCount Number of elements stored in the node. If a node does not store elements, this value is null. int? ElementCount { get; } Property Value int? InsertDurationMilliseconds Cumulative number of milliseconds spent in this node handling the elements passed through it during the propagation of inserted facts. This time is counted since the last reset or since the creation of the session. This duration is exclusive of any time spent propagating facts through the downstream nodes. long InsertDurationMilliseconds { get; } Property Value long InsertInputCount Cumulative number of elements that entered this node during the propagation of inserted facts. This number is counted since the last reset or since the creation of the session. int InsertInputCount { get; } Property Value int InsertOutputCount Cumulative number of elements that exited this node during the propagation of inserted facts. This number is counted since the last reset or since the creation of the session. int InsertOutputCount { get; } Property Value int NodeId Id of the node with which these metrics are associated. int NodeId { get; } Property Value int RetractDurationMilliseconds Cumulative number of milliseconds spent in this node handling the elements passed through it during the propagation of retracted facts. This time is counted since the last reset or since the creation of the session. This duration is exclusive of any time spent propagating facts through the downstream nodes. long RetractDurationMilliseconds { get; } Property Value long RetractInputCount Cumulative number of elements that entered this node during the propagation of retracted facts. This number is counted since the last reset or since the creation of the session. int RetractInputCount { get; } Property Value int RetractOutputCount Cumulative number of elements that exited this node during the propagation of retracted facts. This number is counted since the last reset or since the creation of the session. int RetractOutputCount { get; } Property Value int UpdateDurationMilliseconds Cumulative number of milliseconds spent in this node handling the elements passed through it during the propagation of updated facts. This time is counted since the last reset or since the creation of the session. This duration is exclusive of any time spent propagating facts through the downstream nodes. long UpdateDurationMilliseconds { get; } Property Value long UpdateInputCount Cumulative number of elements that entered this node during the propagation of updated facts. This number is counted since the last reset or since the creation of the session. int UpdateInputCount { get; } Property Value int UpdateOutputCount Cumulative number of elements that exited this node during the propagation of updated facts. This number is counted since the last reset or since the creation of the session. int UpdateOutputCount { get; } Property Value int Methods Reset() Resets cumulative metrics associated with this node. void Reset()"
  },
  "api/NRules.Diagnostics.IRecoverableError.html": {
    "href": "api/NRules.Diagnostics.IRecoverableError.html",
    "title": "Interface IRecoverableError | NRules",
    "keywords": "Interface IRecoverableError Namespace NRules.Diagnostics Assembly NRules.dll Error event that can be handled by the consumer. public interface IRecoverableError Properties Exception Exception that caused the error. Exception Exception { get; } Property Value Exception IsHandled Flag that indicates whether the exception was handled. If handler sets this to true then engine continues execution, otherwise exception is rethrown and terminates engine's execution. bool IsHandled { get; set; } Property Value bool"
  },
  "api/NRules.Diagnostics.ISessionSchemaProvider.html": {
    "href": "api/NRules.Diagnostics.ISessionSchemaProvider.html",
    "title": "Interface ISessionSchemaProvider | NRules",
    "keywords": "Interface ISessionSchemaProvider Namespace NRules.Diagnostics Assembly NRules.dll Provides the rules schema in a form of a Rete network graph, for diagnostics. public interface ISessionSchemaProvider Methods GetSchema() Returns the rules schema as a graph representing the structure of the underlying Rete network. ReteGraph GetSchema() Returns ReteGraph Session schema as a Rete graph."
  },
  "api/NRules.Diagnostics.LhsExpressionErrorEventArgs.html": {
    "href": "api/NRules.Diagnostics.LhsExpressionErrorEventArgs.html",
    "title": "Class LhsExpressionErrorEventArgs | NRules",
    "keywords": "Class LhsExpressionErrorEventArgs Namespace NRules.Diagnostics Assembly NRules.dll Information related to error events raised during left-hand side expression evaluation. public class LhsExpressionErrorEventArgs : LhsExpressionEventArgs, IRecoverableError Inheritance object EventArgs ExpressionEventArgs LhsExpressionEventArgs LhsExpressionErrorEventArgs Implements IRecoverableError Inherited Members LhsExpressionEventArgs.Facts LhsExpressionEventArgs.Rules ExpressionEventArgs.Expression ExpressionEventArgs.Exception ExpressionEventArgs.Arguments ExpressionEventArgs.Result EventArgs.Empty object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors LhsExpressionErrorEventArgs(Expression, Exception, object[], ITuple, IFact, IEnumerable<IRuleDefinition>) Initializes a new instance of the LhsExpressionErrorEventArgs class. public LhsExpressionErrorEventArgs(Expression expression, Exception exception, object[] arguments, ITuple tuple, IFact fact, IEnumerable<IRuleDefinition> rules) Parameters expression Expression Expression related to the event. exception Exception Exception related to the event. arguments object[] Expression arguments. tuple ITuple Tuple related to the event. fact IFact Fact related to the event. rules IEnumerable<IRuleDefinition> Rules that contain the expression that generated the event. Properties IsHandled Flag that indicates whether the exception was handled. If handler sets this to true then engine continues execution, otherwise exception is rethrown and terminates engine's execution. public bool IsHandled { get; set; } Property Value bool"
  },
  "api/NRules.Diagnostics.LhsExpressionEventArgs.html": {
    "href": "api/NRules.Diagnostics.LhsExpressionEventArgs.html",
    "title": "Class LhsExpressionEventArgs | NRules",
    "keywords": "Class LhsExpressionEventArgs Namespace NRules.Diagnostics Assembly NRules.dll Information related to events raised during left-hand side expression evaluation. public class LhsExpressionEventArgs : ExpressionEventArgs Inheritance object EventArgs ExpressionEventArgs LhsExpressionEventArgs Derived LhsExpressionErrorEventArgs Inherited Members ExpressionEventArgs.Expression ExpressionEventArgs.Exception ExpressionEventArgs.Arguments ExpressionEventArgs.Result EventArgs.Empty object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors LhsExpressionEventArgs(Expression, Exception, object[], object, ITuple, IFact, IEnumerable<IRuleDefinition>) Initializes a new instance of the LhsExpressionEventArgs class. public LhsExpressionEventArgs(Expression expression, Exception exception, object[] arguments, object result, ITuple tuple, IFact fact, IEnumerable<IRuleDefinition> rules) Parameters expression Expression Expression related to the event. exception Exception Exception related to the event. arguments object[] Expression arguments. result object Expression result. tuple ITuple Tuple related to the event. fact IFact Fact related to the event. rules IEnumerable<IRuleDefinition> Rules that contain the expression that generated the event. Properties Facts Facts related to the event. public IEnumerable<IFact> Facts { get; } Property Value IEnumerable<IFact> Rules Rules that contain the expression that generated the event. public IEnumerable<IRuleDefinition> Rules { get; } Property Value IEnumerable<IRuleDefinition>"
  },
  "api/NRules.Diagnostics.NodeType.html": {
    "href": "api/NRules.Diagnostics.NodeType.html",
    "title": "Enum NodeType | NRules",
    "keywords": "Enum NodeType Namespace NRules.Diagnostics Assembly NRules.dll Types of nodes in the Rete network. public enum NodeType Fields Root = 0 Type = 1 Selection = 2 AlphaMemory = 3 Dummy = 4 Join = 5 Adapter = 6 Exists = 7 Aggregate = 8 Not = 9 Binding = 10 BetaMemory = 11 Rule = 12"
  },
  "api/NRules.Diagnostics.ReteGraph.html": {
    "href": "api/NRules.Diagnostics.ReteGraph.html",
    "title": "Class ReteGraph | NRules",
    "keywords": "Class ReteGraph Namespace NRules.Diagnostics Assembly NRules.dll Rete network graph that corresponds to the compiled rules. public class ReteGraph Inheritance object ReteGraph Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors ReteGraph(IEnumerable<ReteNode>, IEnumerable<ReteLink>) Creates an instance of a Rete network graph as a collection of nodes and links between them. public ReteGraph(IEnumerable<ReteNode> nodes, IEnumerable<ReteLink> links) Parameters nodes IEnumerable<ReteNode> Rete network graph nodes. links IEnumerable<ReteLink> Links between Rete network nodes. Properties Links Links between nodes of the Rete network graph. public ReteLink[] Links { get; } Property Value ReteLink[] Nodes Nodes of the Rete network graph. public ReteNode[] Nodes { get; } Property Value ReteNode[]"
  },
  "api/NRules.Diagnostics.ReteLink.html": {
    "href": "api/NRules.Diagnostics.ReteLink.html",
    "title": "Class ReteLink | NRules",
    "keywords": "Class ReteLink Namespace NRules.Diagnostics Assembly NRules.dll Link between nodes in the rete network graph. public class ReteLink Inheritance object ReteLink Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Source Source node. public ReteNode Source { get; } Property Value ReteNode Target Target node. public ReteNode Target { get; } Property Value ReteNode"
  },
  "api/NRules.Diagnostics.ReteNode.html": {
    "href": "api/NRules.Diagnostics.ReteNode.html",
    "title": "Class ReteNode | NRules",
    "keywords": "Class ReteNode Namespace NRules.Diagnostics Assembly NRules.dll Node in the Rete network graph. public class ReteNode Inheritance object ReteNode Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Expressions Expressions associated with the node. public KeyValuePair<string, LambdaExpression>[] Expressions { get; } Property Value KeyValuePair<string, LambdaExpression>[] Id Node id, unique within a given instance of ISessionFactory. This id is stable for a given set of rules (same rules will get compiled into the same Rete network, and produce nodes with the same ids). public int Id { get; } Property Value int NodeType Type of the node in the Rete network. public NodeType NodeType { get; } Property Value NodeType OutputType Type of elements the node produces as output. public Type OutputType { get; } Property Value Type Properties Properties associated with the node. public KeyValuePair<string, object>[] Properties { get; } Property Value KeyValuePair<string, object>[] Rules Rules that this node participates in. public IRuleDefinition[] Rules { get; } Property Value IRuleDefinition[]"
  },
  "api/NRules.Diagnostics.RhsExpressionErrorEventArgs.html": {
    "href": "api/NRules.Diagnostics.RhsExpressionErrorEventArgs.html",
    "title": "Class RhsExpressionErrorEventArgs | NRules",
    "keywords": "Class RhsExpressionErrorEventArgs Namespace NRules.Diagnostics Assembly NRules.dll Information related to error events raised during right-hand side expression evaluation. public class RhsExpressionErrorEventArgs : RhsExpressionEventArgs, IRecoverableError Inheritance object EventArgs ExpressionEventArgs RhsExpressionEventArgs RhsExpressionErrorEventArgs Implements IRecoverableError Inherited Members RhsExpressionEventArgs.Match ExpressionEventArgs.Expression ExpressionEventArgs.Exception ExpressionEventArgs.Arguments ExpressionEventArgs.Result EventArgs.Empty object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors RhsExpressionErrorEventArgs(Expression, Exception, object[], IMatch) Initializes a new instance of the RhsExpressionErrorEventArgs class. public RhsExpressionErrorEventArgs(Expression expression, Exception exception, object[] arguments, IMatch match) Parameters expression Expression Expression related to the event. exception Exception Exception related to the event. arguments object[] Expression arguments. match IMatch Rule match related to the event. Properties IsHandled Flag that indicates whether the exception was handled. If handler sets this to true then engine continues execution, otherwise exception is rethrown and terminates engine's execution. public bool IsHandled { get; set; } Property Value bool"
  },
  "api/NRules.Diagnostics.RhsExpressionEventArgs.html": {
    "href": "api/NRules.Diagnostics.RhsExpressionEventArgs.html",
    "title": "Class RhsExpressionEventArgs | NRules",
    "keywords": "Class RhsExpressionEventArgs Namespace NRules.Diagnostics Assembly NRules.dll Information related to events raised during right-hand side expression evaluation. public class RhsExpressionEventArgs : ExpressionEventArgs Inheritance object EventArgs ExpressionEventArgs RhsExpressionEventArgs Derived RhsExpressionErrorEventArgs Inherited Members ExpressionEventArgs.Expression ExpressionEventArgs.Exception ExpressionEventArgs.Arguments ExpressionEventArgs.Result EventArgs.Empty object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors RhsExpressionEventArgs(Expression, Exception, object[], IMatch) Initializes a new instance of the RhsExpressionEventArgs class. public RhsExpressionEventArgs(Expression expression, Exception exception, object[] arguments, IMatch match) Parameters expression Expression Expression related to the event. exception Exception Exception related to the event. arguments object[] Expression arguments. match IMatch Rule match related to the event. Properties Match Rule match related to the event. public IMatch Match { get; } Property Value IMatch"
  },
  "api/NRules.Diagnostics.WorkingMemoryEventArgs.html": {
    "href": "api/NRules.Diagnostics.WorkingMemoryEventArgs.html",
    "title": "Class WorkingMemoryEventArgs | NRules",
    "keywords": "Class WorkingMemoryEventArgs Namespace NRules.Diagnostics Assembly NRules.dll Information related to working memory events. public class WorkingMemoryEventArgs : EventArgs Inheritance object EventArgs WorkingMemoryEventArgs Inherited Members EventArgs.Empty object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors WorkingMemoryEventArgs(IFact) Initializes a new instance of the WorkingMemoryEventArgs class. public WorkingMemoryEventArgs(IFact fact) Parameters fact IFact Fact related to the event. Properties Fact Fact related to the event. public IFact Fact { get; } Property Value IFact"
  },
  "api/NRules.Diagnostics.html": {
    "href": "api/NRules.Diagnostics.html",
    "title": "Namespace NRules.Diagnostics | NRules",
    "keywords": "Namespace NRules.Diagnostics Contains types that facilitate troubleshooting and monitoring of the rules engine execution. Classes AgendaEventArgs Information related to agenda events. AgendaExpressionErrorEventArgs Information related to error events raised during agenda expression evaluation. AgendaExpressionEventArgs Information related to events raised during agenda expression evaluation. ExpressionEventArgs Information related to expression evaluation events. LhsExpressionErrorEventArgs Information related to error events raised during left-hand side expression evaluation. LhsExpressionEventArgs Information related to events raised during left-hand side expression evaluation. ReteGraph Rete network graph that corresponds to the compiled rules. ReteLink Link between nodes in the rete network graph. ReteNode Node in the Rete network graph. RhsExpressionErrorEventArgs Information related to error events raised during right-hand side expression evaluation. RhsExpressionEventArgs Information related to events raised during right-hand side expression evaluation. WorkingMemoryEventArgs Information related to working memory events. Interfaces IEventProvider Provider of rules session events. IMetricsProvider Provides access to performance metrics associated with individual nodes in the Rete network used to execute the rules. INodeMetrics Performance metrics associated with a given node in the Rete network. IRecoverableError Error event that can be handled by the consumer. ISessionSchemaProvider Provides the rules schema in a form of a Rete network graph, for diagnostics. Enums NodeType Types of nodes in the Rete network."
  },
  "api/NRules.Extensibility.IActionInterceptor.html": {
    "href": "api/NRules.Extensibility.IActionInterceptor.html",
    "title": "Interface IActionInterceptor | NRules",
    "keywords": "Interface IActionInterceptor Namespace NRules.Extensibility Assembly NRules.dll Extension point for rule actions interception. An instance of IActionInterceptor can be assigned to ActionInterceptor or ActionInterceptor, so that invocation of all rule actions is delegated to the interceptor. The interceptor is free to add pre- or post-processing to action invocations, error handling, or decide not to invoke the actions. public interface IActionInterceptor Remarks When actions are invoked via IActionInterceptor, exceptions thrown by actions are not wrapped into RuleRhsExpressionEvaluationException. It is the responsibility of the interceptor to handle the exceptions. Exceptions thrown from the interceptor are not handled by the engine and just propagate up the stack. Methods Intercept(IContext, IEnumerable<IActionInvocation>) Called by the rules engine in place of the action invocations when a rule fires. The interceptor can add behavior to action invocation and choose to either proceed with the invocations or not. void Intercept(IContext context, IEnumerable<IActionInvocation> actions) Parameters context IContext Action context, containing information about the firing rule and matched facts. actions IEnumerable<IActionInvocation> Action invocations for rule actions being intercepted."
  },
  "api/NRules.Extensibility.IActionInvocation.html": {
    "href": "api/NRules.Extensibility.IActionInvocation.html",
    "title": "Interface IActionInvocation | NRules",
    "keywords": "Interface IActionInvocation Namespace NRules.Extensibility Assembly NRules.dll Represents invocation of the proxied rule action. public interface IActionInvocation Properties Arguments Action arguments. To get more information about the matched facts, whether they are passed to a given action or not, use IContext passed to the Intercept(IContext, IEnumerable<IActionInvocation>) method. object[] Arguments { get; } Property Value object[] Remarks Action arguments also include dependencies that are passed to the action method. Trigger Activation events that trigger this action. ActionTrigger Trigger { get; } Property Value ActionTrigger Methods Invoke() Invokes the action. void Invoke()"
  },
  "api/NRules.Extensibility.IDependencyResolver.html": {
    "href": "api/NRules.Extensibility.IDependencyResolver.html",
    "title": "Interface IDependencyResolver | NRules",
    "keywords": "Interface IDependencyResolver Namespace NRules.Extensibility Assembly NRules.dll Defines a mechanism to resolve rule dependencies at runtime. An instance of IDependencyResolver can be assigned to DependencyResolver or DependencyResolver, so that all requests for rule dependencies resolution are fulfilled by that resolver. public interface IDependencyResolver Remarks If dependency resolver is not configured, any attempt to resolve rule dependencies will result in exception. Methods Resolve(IResolutionContext, Type) Resolves a registered service (normally via an IoC container). object Resolve(IResolutionContext context, Type serviceType) Parameters context IResolutionContext Information about the context at which the resolution call is made. serviceType Type The type of requested service. Returns object Requested service."
  },
  "api/NRules.Extensibility.IExpressionCompiler.html": {
    "href": "api/NRules.Extensibility.IExpressionCompiler.html",
    "title": "Interface IExpressionCompiler | NRules",
    "keywords": "Interface IExpressionCompiler Namespace NRules.Extensibility Assembly NRules.dll Compiles expressions used in rules conditions and actions in a form of expression trees into executable delegates. The default implementation uses built-in .NET expression compiler. public interface IExpressionCompiler Methods Compile<TDelegate>(Expression<TDelegate>) Compiles an expression tree into an executable delegate. TDelegate Compile<TDelegate>(Expression<TDelegate> expression) where TDelegate : Delegate Parameters expression Expression<TDelegate> Expression tree to compile. Returns TDelegate The compiled delegate. Type Parameters TDelegate Type of the underlying expression delegate."
  },
  "api/NRules.Extensibility.IResolutionContext.html": {
    "href": "api/NRules.Extensibility.IResolutionContext.html",
    "title": "Interface IResolutionContext | NRules",
    "keywords": "Interface IResolutionContext Namespace NRules.Extensibility Assembly NRules.dll Context for dependency resolution. public interface IResolutionContext Properties Rule Rule that requested dependency resolution. IRuleDefinition Rule { get; } Property Value IRuleDefinition Session Rules engine session that requested dependency resolution. ISession Session { get; } Property Value ISession"
  },
  "api/NRules.Extensibility.html": {
    "href": "api/NRules.Extensibility.html",
    "title": "Namespace NRules.Extensibility | NRules",
    "keywords": "Namespace NRules.Extensibility Contains types that enable extensibility of the rules engine. Interfaces IActionInterceptor Extension point for rule actions interception. An instance of IActionInterceptor can be assigned to ActionInterceptor or ActionInterceptor, so that invocation of all rule actions is delegated to the interceptor. The interceptor is free to add pre- or post-processing to action invocations, error handling, or decide not to invoke the actions. IActionInvocation Represents invocation of the proxied rule action. IDependencyResolver Defines a mechanism to resolve rule dependencies at runtime. An instance of IDependencyResolver can be assigned to DependencyResolver or DependencyResolver, so that all requests for rule dependencies resolution are fulfilled by that resolver. IExpressionCompiler Compiles expressions used in rules conditions and actions in a form of expression trees into executable delegates. The default implementation uses built-in .NET expression compiler. IResolutionContext Context for dependency resolution."
  },
  "api/NRules.Fluent.DefaultRuleActivator.html": {
    "href": "api/NRules.Fluent.DefaultRuleActivator.html",
    "title": "Class DefaultRuleActivator | NRules",
    "keywords": "Class DefaultRuleActivator Namespace NRules.Fluent Assembly NRules.Fluent.dll Default rule activator that uses reflection to instantiate rules. public class DefaultRuleActivator : IRuleActivator Inheritance object DefaultRuleActivator Implements IRuleActivator Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods Activate(Type) Creates rule's instances from a CLR type. public IEnumerable<Rule> Activate(Type type) Parameters type Type Rule CLR type. Returns IEnumerable<Rule> Rule instances."
  },
  "api/NRules.Fluent.Dsl.ContextExtensions.html": {
    "href": "api/NRules.Fluent.Dsl.ContextExtensions.html",
    "title": "Class ContextExtensions | NRules",
    "keywords": "Class ContextExtensions Namespace NRules.Fluent.Dsl Assembly NRules.Fluent.dll public static class ContextExtensions Inheritance object ContextExtensions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods Resolve<TService>(IContext) Resolves a registered service (normally via an IoC container). public static TService Resolve<TService>(this IContext context) Parameters context IContext Context instance. Returns TService Service instance. Type Parameters TService Type of service to resolve. Update<T>(IContext, T, Action<T>) Updates existing fact in the rules engine's memory. First the update action is applied to the fact, then the fact is updated in the engine's memory. public static void Update<T>(this IContext context, T fact, Action<T> updateAction) Parameters context IContext Context instance. fact T Existing fact to update. updateAction Action<T> Action to apply to the fact. Type Parameters T"
  },
  "api/NRules.Fluent.Dsl.DescriptionAttribute.html": {
    "href": "api/NRules.Fluent.Dsl.DescriptionAttribute.html",
    "title": "Class DescriptionAttribute | NRules",
    "keywords": "Class DescriptionAttribute Namespace NRules.Fluent.Dsl Assembly NRules.Fluent.dll Sets rule's description. [AttributeUsage(AttributeTargets.Class, AllowMultiple = false, Inherited = false)] public sealed class DescriptionAttribute : Attribute Inheritance object Attribute DescriptionAttribute Inherited Members Attribute.Equals(object) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetHashCode() Attribute.IsDefaultAttribute() Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.Match(object) Attribute.TypeId object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) object.ToString() Constructors DescriptionAttribute(string) public DescriptionAttribute(string value) Parameters value string"
  },
  "api/NRules.Fluent.Dsl.ICollectQuery-1.html": {
    "href": "api/NRules.Fluent.Dsl.ICollectQuery-1.html",
    "title": "Interface ICollectQuery<TSource> | NRules",
    "keywords": "Interface ICollectQuery<TSource> Namespace NRules.Fluent.Dsl Assembly NRules.Fluent.dll Intermediate query chain element used for Collect modifiers. public interface ICollectQuery<out TSource> : IQuery<TSource> Type Parameters TSource Type of the element the query operates on. Extension Methods QueryExtensions.Collect<TSource>(IQuery<TSource>) QueryExtensions.GroupBy<TSource, TKey>(IQuery<TSource>, Expression<Func<TSource, TKey>>) QueryExtensions.GroupBy<TSource, TKey, TElement>(IQuery<TSource>, Expression<Func<TSource, TKey>>, Expression<Func<TSource, TElement>>) QueryExtensions.SelectMany<TSource, TResult>(IQuery<TSource>, Expression<Func<TSource, IEnumerable<TResult>>>) QueryExtensions.Select<TSource, TResult>(IQuery<TSource>, Expression<Func<TSource, TResult>>) QueryExtensions.Where<TSource>(IQuery<TSource>, params Expression<Func<TSource, bool>>[])"
  },
  "api/NRules.Fluent.Dsl.IDependencyExpression.html": {
    "href": "api/NRules.Fluent.Dsl.IDependencyExpression.html",
    "title": "Interface IDependencyExpression | NRules",
    "keywords": "Interface IDependencyExpression Namespace NRules.Fluent.Dsl Assembly NRules.Fluent.dll Rule's dependencies expression builder. public interface IDependencyExpression Methods Resolve<TDependency>(Expression<Func<TDependency>>) Configures the engine to inject the rules with a required dependency. IDependencyExpression Resolve<TDependency>(Expression<Func<TDependency>> alias) Parameters alias Expression<Func<TDependency>> Alias for the injected service. Returns IDependencyExpression Dependencies expression builder. Type Parameters TDependency Type of the service to inject."
  },
  "api/NRules.Fluent.Dsl.IFilterExpression.html": {
    "href": "api/NRules.Fluent.Dsl.IFilterExpression.html",
    "title": "Interface IFilterExpression | NRules",
    "keywords": "Interface IFilterExpression Namespace NRules.Fluent.Dsl Assembly NRules.Fluent.dll Rule's filters expression builder. public interface IFilterExpression Methods OnChange(params Expression<Func<object>>[]) Configures the engine to filter rule's matches, so that updates are only triggered if given keys changed. If multiple keys are configured, the match is accepted if any of the keys changed. IFilterExpression OnChange(params Expression<Func<object>>[] keySelectors) Parameters keySelectors Expression<Func<object>>[] Key selector expressions. Returns IFilterExpression Filters expression builder. Where(params Expression<Func<bool>>[]) Configures the engine to filter rule's matches given a set of predicates. If multiple predicates are configured, the match is accepted if all predicates are true. IFilterExpression Where(params Expression<Func<bool>>[] predicates) Parameters predicates Expression<Func<bool>>[] Predicate expressions. Returns IFilterExpression Filters expression builder."
  },
  "api/NRules.Fluent.Dsl.ILeftHandSideExpression.html": {
    "href": "api/NRules.Fluent.Dsl.ILeftHandSideExpression.html",
    "title": "Interface ILeftHandSideExpression | NRules",
    "keywords": "Interface ILeftHandSideExpression Namespace NRules.Fluent.Dsl Assembly NRules.Fluent.dll Rule's left-hand side (conditions) expression builder. public interface ILeftHandSideExpression Methods All<TFact>(Expression<Func<TFact, bool>>) Defines a pattern that triggers the rule only if all facts of a given type match the condition. ILeftHandSideExpression All<TFact>(Expression<Func<TFact, bool>> condition) Parameters condition Expression<Func<TFact, bool>> Condition that all facts of a given type must satisfy to trigger the rule. Returns ILeftHandSideExpression Left hand side expression builder. Type Parameters TFact Type of fact to match. All<TFact>(Expression<Func<TFact, bool>>, params Expression<Func<TFact, bool>>[]) Defines a pattern that triggers the rule only if all facts that match the base condition also match all the remaining conditions (universal quantifier). ILeftHandSideExpression All<TFact>(Expression<Func<TFact, bool>> baseCondition, params Expression<Func<TFact, bool>>[] conditions) Parameters baseCondition Expression<Func<TFact, bool>> Base condition that filters the facts to match the remaining conditions. conditions Expression<Func<TFact, bool>>[] Set of additional conditions that all matching facts must satisfy to trigger the rule. Returns ILeftHandSideExpression Left hand side expression builder. Type Parameters TFact Type of fact to match. And(Action<ILeftHandSideExpression>) Defines a group of patterns joined by an AND operator. If all of the patterns in the group match then the whole group matches. ILeftHandSideExpression And(Action<ILeftHandSideExpression> builder) Parameters builder Action<ILeftHandSideExpression> Group expression builder. Returns ILeftHandSideExpression Left hand side expression builder. Exists<TFact>(params Expression<Func<TFact, bool>>[]) Defines a pattern that triggers the rule only if there is at least one matching fact (existential quantifier). ILeftHandSideExpression Exists<TFact>(params Expression<Func<TFact, bool>>[] conditions) Parameters conditions Expression<Func<TFact, bool>>[] Set of conditions the facts must satisfy to trigger the rule. Returns ILeftHandSideExpression Left hand side expression builder. Type Parameters TFact Type of fact to match. Having(params Expression<Func<bool>>[]) Adds match conditions to existing rule patterns. ILeftHandSideExpression Having(params Expression<Func<bool>>[] conditions) Parameters conditions Expression<Func<bool>>[] Additional match conditions. Returns ILeftHandSideExpression Left hand side expression builder. Let<TResult>(Expression<Func<TResult>>, Expression<Func<TResult>>) Binds expression to a variable. Expression can use previously defined rule patterns. ILeftHandSideExpression Let<TResult>(Expression<Func<TResult>> alias, Expression<Func<TResult>> expression) Parameters alias Expression<Func<TResult>> Alias for the expression. expression Expression<Func<TResult>> Expression to bind. Returns ILeftHandSideExpression Left hand side expression builder. Type Parameters TResult Type of the expression result. Match<TFact>(params Expression<Func<TFact, bool>>[]) Defines a pattern for facts matching a set of conditions. Does not bind matching fact to a variable. Optionally, enables aggregation of matching facts. ILeftHandSideExpression Match<TFact>(params Expression<Func<TFact, bool>>[] conditions) Parameters conditions Expression<Func<TFact, bool>>[] Set of additional conditions the fact must satisfy to trigger the rule. Returns ILeftHandSideExpression Left hand side expression builder. Type Parameters TFact Match<TFact>(Expression<Func<TFact>>, params Expression<Func<TFact, bool>>[]) Defines a pattern for facts matching a set of conditions. Binds matching fact to a variable. ILeftHandSideExpression Match<TFact>(Expression<Func<TFact>> alias, params Expression<Func<TFact, bool>>[] conditions) Parameters alias Expression<Func<TFact>> Alias for the matching fact. conditions Expression<Func<TFact, bool>>[] Set of conditions the fact must satisfy to trigger the rule. Returns ILeftHandSideExpression Left hand side expression builder. Type Parameters TFact Type of fact to match. Not<TFact>(params Expression<Func<TFact, bool>>[]) Defines a pattern that triggers the rule only if there are no matching facts (negation quantifier). ILeftHandSideExpression Not<TFact>(params Expression<Func<TFact, bool>>[] conditions) Parameters conditions Expression<Func<TFact, bool>>[] Set of conditions the facts must not satisfy to trigger the rule. Returns ILeftHandSideExpression Left hand side expression builder. Type Parameters TFact Type of fact to match. Or(Action<ILeftHandSideExpression>) Defines a group of patterns joined by an OR operator. If either of the patterns in the group matches then the whole group matches. ILeftHandSideExpression Or(Action<ILeftHandSideExpression> builder) Parameters builder Action<ILeftHandSideExpression> Group expression builder. Returns ILeftHandSideExpression Left hand side expression builder. Query<TResult>(Expression<Func<TResult>>, Func<IQuery, IQuery<TResult>>) Queries rules engine for matching facts. ILeftHandSideExpression Query<TResult>(Expression<Func<TResult>> alias, Func<IQuery, IQuery<TResult>> queryExpression) Parameters alias Expression<Func<TResult>> Alias for the query results. queryExpression Func<IQuery, IQuery<TResult>> Query expression. Returns ILeftHandSideExpression Left hand side expression builder. Type Parameters TResult Query result type."
  },
  "api/NRules.Fluent.Dsl.IOrderedQuery-1.html": {
    "href": "api/NRules.Fluent.Dsl.IOrderedQuery-1.html",
    "title": "Interface IOrderedQuery<TSource> | NRules",
    "keywords": "Interface IOrderedQuery<TSource> Namespace NRules.Fluent.Dsl Assembly NRules.Fluent.dll Intermediate query chain element used for OrderBy modifiers. public interface IOrderedQuery<out TSource> : IQuery<TSource> Type Parameters TSource Type of the element the query operates on. Extension Methods QueryExtensions.Collect<TSource>(IQuery<TSource>) QueryExtensions.GroupBy<TSource, TKey>(IQuery<TSource>, Expression<Func<TSource, TKey>>) QueryExtensions.GroupBy<TSource, TKey, TElement>(IQuery<TSource>, Expression<Func<TSource, TKey>>, Expression<Func<TSource, TElement>>) QueryExtensions.SelectMany<TSource, TResult>(IQuery<TSource>, Expression<Func<TSource, IEnumerable<TResult>>>) QueryExtensions.Select<TSource, TResult>(IQuery<TSource>, Expression<Func<TSource, TResult>>) QueryExtensions.Where<TSource>(IQuery<TSource>, params Expression<Func<TSource, bool>>[])"
  },
  "api/NRules.Fluent.Dsl.IQuery-1.html": {
    "href": "api/NRules.Fluent.Dsl.IQuery-1.html",
    "title": "Interface IQuery<TSource> | NRules",
    "keywords": "Interface IQuery<TSource> Namespace NRules.Fluent.Dsl Assembly NRules.Fluent.dll Intermediate query chain element. public interface IQuery<out TSource> Type Parameters TSource Type of the element the query operates on. Extension Methods QueryExtensions.Collect<TSource>(IQuery<TSource>) QueryExtensions.GroupBy<TSource, TKey>(IQuery<TSource>, Expression<Func<TSource, TKey>>) QueryExtensions.GroupBy<TSource, TKey, TElement>(IQuery<TSource>, Expression<Func<TSource, TKey>>, Expression<Func<TSource, TElement>>) QueryExtensions.SelectMany<TSource, TResult>(IQuery<TSource>, Expression<Func<TSource, IEnumerable<TResult>>>) QueryExtensions.Select<TSource, TResult>(IQuery<TSource>, Expression<Func<TSource, TResult>>) QueryExtensions.Where<TSource>(IQuery<TSource>, params Expression<Func<TSource, bool>>[])"
  },
  "api/NRules.Fluent.Dsl.IQuery.html": {
    "href": "api/NRules.Fluent.Dsl.IQuery.html",
    "title": "Interface IQuery | NRules",
    "keywords": "Interface IQuery Namespace NRules.Fluent.Dsl Assembly NRules.Fluent.dll Root of the query method chain. public interface IQuery Extension Methods QueryExtensions.From<TFact>(IQuery, Expression<Func<TFact>>) QueryExtensions.Match<TFact>(IQuery, params Expression<Func<TFact, bool>>[])"
  },
  "api/NRules.Fluent.Dsl.IQueryBuilder.html": {
    "href": "api/NRules.Fluent.Dsl.IQueryBuilder.html",
    "title": "Interface IQueryBuilder | NRules",
    "keywords": "Interface IQueryBuilder Namespace NRules.Fluent.Dsl Assembly NRules.Fluent.dll Internal builder for queries. public interface IQueryBuilder Methods Aggregate<TSource, TResult>(string, IEnumerable<KeyValuePair<string, LambdaExpression>>) void Aggregate<TSource, TResult>(string name, IEnumerable<KeyValuePair<string, LambdaExpression>> expressions) Parameters name string expressions IEnumerable<KeyValuePair<string, LambdaExpression>> Type Parameters TSource TResult Aggregate<TSource, TResult>(string, IEnumerable<KeyValuePair<string, LambdaExpression>>, Type) void Aggregate<TSource, TResult>(string name, IEnumerable<KeyValuePair<string, LambdaExpression>> expressions, Type customFactoryType) Parameters name string expressions IEnumerable<KeyValuePair<string, LambdaExpression>> customFactoryType Type Type Parameters TSource TResult Collect<TSource>() void Collect<TSource>() Type Parameters TSource FactQuery<TSource>(Expression<Func<TSource, bool>>[]) void FactQuery<TSource>(Expression<Func<TSource, bool>>[] conditions) Parameters conditions Expression<Func<TSource, bool>>[] Type Parameters TSource From<TSource>(Expression<Func<TSource>>) void From<TSource>(Expression<Func<TSource>> source) Parameters source Expression<Func<TSource>> Type Parameters TSource GroupBy<TSource, TKey, TElement>(Expression<Func<TSource, TKey>>, Expression<Func<TSource, TElement>>) void GroupBy<TSource, TKey, TElement>(Expression<Func<TSource, TKey>> keySelector, Expression<Func<TSource, TElement>> elementSelector) Parameters keySelector Expression<Func<TSource, TKey>> elementSelector Expression<Func<TSource, TElement>> Type Parameters TSource TKey TElement OrderBy<TSource, TKey>(Expression<Func<TSource, TKey>>, SortDirection) void OrderBy<TSource, TKey>(Expression<Func<TSource, TKey>> keySelector, SortDirection sortDirection) Parameters keySelector Expression<Func<TSource, TKey>> sortDirection SortDirection Type Parameters TSource TKey SelectMany<TSource, TResult>(Expression<Func<TSource, IEnumerable<TResult>>>) void SelectMany<TSource, TResult>(Expression<Func<TSource, IEnumerable<TResult>>> selector) Parameters selector Expression<Func<TSource, IEnumerable<TResult>>> Type Parameters TSource TResult Select<TSource, TResult>(Expression<Func<TSource, TResult>>) void Select<TSource, TResult>(Expression<Func<TSource, TResult>> selector) Parameters selector Expression<Func<TSource, TResult>> Type Parameters TSource TResult ToLookup<TSource, TKey, TElement>(Expression<Func<TSource, TKey>>, Expression<Func<TSource, TElement>>) void ToLookup<TSource, TKey, TElement>(Expression<Func<TSource, TKey>> keySelector, Expression<Func<TSource, TElement>> elementSelector) Parameters keySelector Expression<Func<TSource, TKey>> elementSelector Expression<Func<TSource, TElement>> Type Parameters TSource TKey TElement Where<TSource>(Expression<Func<TSource, bool>>[]) void Where<TSource>(Expression<Func<TSource, bool>>[] predicates) Parameters predicates Expression<Func<TSource, bool>>[] Type Parameters TSource"
  },
  "api/NRules.Fluent.Dsl.IRightHandSideExpression.html": {
    "href": "api/NRules.Fluent.Dsl.IRightHandSideExpression.html",
    "title": "Interface IRightHandSideExpression | NRules",
    "keywords": "Interface IRightHandSideExpression Namespace NRules.Fluent.Dsl Assembly NRules.Fluent.dll Rule's right-hand side (actions) expression builder. public interface IRightHandSideExpression Methods Action(Expression<Action<IContext>>, ActionTrigger) Defines rule's action that engine executes for a given trigger. IRightHandSideExpression Action(Expression<Action<IContext>> action, ActionTrigger actionTrigger) Parameters action Expression<Action<IContext>> Action expression. actionTrigger ActionTrigger Events that should trigger this action. Returns IRightHandSideExpression Right hand side expression builder. Do(Expression<Action<IContext>>) Defines rule's action that engine executes when the rule fires due to the initial rule match or due to an update. IRightHandSideExpression Do(Expression<Action<IContext>> action) Parameters action Expression<Action<IContext>> Action expression. Returns IRightHandSideExpression Right hand side expression builder. Undo(Expression<Action<IContext>>) Defines rule's action that engine executes when the rule fires due to the match removal (provided the rule previously fired on the match). IRightHandSideExpression Undo(Expression<Action<IContext>> action) Parameters action Expression<Action<IContext>> Action expression. Returns IRightHandSideExpression Right hand side expression builder. Yield<TFact>(Expression<Func<IContext, TFact>>) Defines rule's action that yields a linked fact when the rule fires. If the rule fires due to an update, the linked fact is also updated with the new yielded value. IRightHandSideExpression Yield<TFact>(Expression<Func<IContext, TFact>> yield) Parameters yield Expression<Func<IContext, TFact>> Action expression that yields the linked fact. Returns IRightHandSideExpression Right hand side expression builder. Type Parameters TFact Type of fact to yield. Yield<TFact>(Expression<Func<IContext, TFact>>, Expression<Func<IContext, TFact, TFact>>) Defines rule's action that yields a linked fact when the rule fires. If the rule fires due to an update, the update expression is evaluated to produce an updated linked fact. IRightHandSideExpression Yield<TFact>(Expression<Func<IContext, TFact>> yieldInsert, Expression<Func<IContext, TFact, TFact>> yieldUpdate) Parameters yieldInsert Expression<Func<IContext, TFact>> Action expression that yields a new linked fact. yieldUpdate Expression<Func<IContext, TFact, TFact>> Action expression that yields an updated linked fact. Returns IRightHandSideExpression Right hand side expression builder. Type Parameters TFact Type of fact to yield."
  },
  "api/NRules.Fluent.Dsl.NameAttribute.html": {
    "href": "api/NRules.Fluent.Dsl.NameAttribute.html",
    "title": "Class NameAttribute | NRules",
    "keywords": "Class NameAttribute Namespace NRules.Fluent.Dsl Assembly NRules.Fluent.dll Sets rule's name. Name set via the attribute overrides the default name, which is the fully qualified class name. [AttributeUsage(AttributeTargets.Class, AllowMultiple = false, Inherited = false)] public sealed class NameAttribute : Attribute Inheritance object Attribute NameAttribute Inherited Members Attribute.Equals(object) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetHashCode() Attribute.IsDefaultAttribute() Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.Match(object) Attribute.TypeId object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) object.ToString() Constructors NameAttribute(string) public NameAttribute(string value) Parameters value string"
  },
  "api/NRules.Fluent.Dsl.PriorityAttribute.html": {
    "href": "api/NRules.Fluent.Dsl.PriorityAttribute.html",
    "title": "Class PriorityAttribute | NRules",
    "keywords": "Class PriorityAttribute Namespace NRules.Fluent.Dsl Assembly NRules.Fluent.dll Sets rule's priority. If multiple rules get activated at the same time, rules with higher priority get executed first. Priority value can be positive, negative or zero. Default priority is zero. [AttributeUsage(AttributeTargets.Class, AllowMultiple = false, Inherited = true)] public sealed class PriorityAttribute : Attribute Inheritance object Attribute PriorityAttribute Inherited Members Attribute.Equals(object) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetHashCode() Attribute.IsDefaultAttribute() Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.Match(object) Attribute.TypeId object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) object.ToString() Constructors PriorityAttribute(int) public PriorityAttribute(int value) Parameters value int"
  },
  "api/NRules.Fluent.Dsl.QueryExpression-1.html": {
    "href": "api/NRules.Fluent.Dsl.QueryExpression-1.html",
    "title": "Class QueryExpression<TSource> | NRules",
    "keywords": "Class QueryExpression<TSource> Namespace NRules.Fluent.Dsl Assembly NRules.Fluent.dll Expression builder for queries. public class QueryExpression<TSource> : ICollectQuery<TSource>, IOrderedQuery<TSource>, IQuery<TSource> Type Parameters TSource Type of query source. Inheritance object QueryExpression<TSource> Implements ICollectQuery<TSource> IOrderedQuery<TSource> IQuery<TSource> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Extension Methods QueryExtensions.Collect<TSource>(IQuery<TSource>) QueryExtensions.GroupBy<TSource, TKey>(IQuery<TSource>, Expression<Func<TSource, TKey>>) QueryExtensions.GroupBy<TSource, TKey, TElement>(IQuery<TSource>, Expression<Func<TSource, TKey>>, Expression<Func<TSource, TElement>>) QueryExtensions.SelectMany<TSource, TResult>(IQuery<TSource>, Expression<Func<TSource, IEnumerable<TResult>>>) QueryExtensions.Select<TSource, TResult>(IQuery<TSource>, Expression<Func<TSource, TResult>>) QueryExtensions.Where<TSource>(IQuery<TSource>, params Expression<Func<TSource, bool>>[]) Constructors QueryExpression(IQueryBuilder) Constructs a query expression builder that wraps a IQueryBuilder. public QueryExpression(IQueryBuilder builder) Parameters builder IQueryBuilder Query builder to wrap. Properties Builder Wrapped IQueryBuilder. public IQueryBuilder Builder { get; } Property Value IQueryBuilder"
  },
  "api/NRules.Fluent.Dsl.QueryExtensions.html": {
    "href": "api/NRules.Fluent.Dsl.QueryExtensions.html",
    "title": "Class QueryExtensions | NRules",
    "keywords": "Class QueryExtensions Namespace NRules.Fluent.Dsl Assembly NRules.Fluent.dll public static class QueryExtensions Inheritance object QueryExtensions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods Collect<TSource>(IQuery<TSource>) Aggregates matching facts into a collection. public static ICollectQuery<IEnumerable<TSource>> Collect<TSource>(this IQuery<TSource> source) Parameters source IQuery<TSource> Query expression builder. Returns ICollectQuery<IEnumerable<TSource>> Query expression builder. Type Parameters TSource Type of source facts. From<TFact>(IQuery, Expression<Func<TFact>>) Creates a query from a given expression. public static IQuery<TFact> From<TFact>(this IQuery query, Expression<Func<TFact>> source) Parameters query IQuery Query expression builder. source Expression<Func<TFact>> Expression that generates source facts. Returns IQuery<TFact> Query expression builder. Type Parameters TFact Type of facts to query. GroupBy<TSource, TKey>(IQuery<TSource>, Expression<Func<TSource, TKey>>) Aggregates source facts into groups based on a grouping key. public static IQuery<IGrouping<TKey, TSource>> GroupBy<TSource, TKey>(this IQuery<TSource> source, Expression<Func<TSource, TKey>> keySelector) Parameters source IQuery<TSource> Query expression builder. keySelector Expression<Func<TSource, TKey>> Grouping key selection expression. Returns IQuery<IGrouping<TKey, TSource>> Query expression builder. Type Parameters TSource Type of source facts. TKey Type of grouping key. GroupBy<TSource, TKey, TElement>(IQuery<TSource>, Expression<Func<TSource, TKey>>, Expression<Func<TSource, TElement>>) Aggregates source facts into groups based on a grouping key. Projects facts as part of grouping based on a value selection expression. public static IQuery<IGrouping<TKey, TElement>> GroupBy<TSource, TKey, TElement>(this IQuery<TSource> source, Expression<Func<TSource, TKey>> keySelector, Expression<Func<TSource, TElement>> elementSelector) Parameters source IQuery<TSource> Query expression builder. keySelector Expression<Func<TSource, TKey>> Grouping key selection expression. elementSelector Expression<Func<TSource, TElement>> Projected fact selection expression. Returns IQuery<IGrouping<TKey, TElement>> Query expression builder. Type Parameters TSource Type of source facts. TKey Type of grouping key. TElement Type of projected facts. Match<TFact>(IQuery, params Expression<Func<TFact, bool>>[]) Creates a query from matching facts in the engine's working memory. public static IQuery<TFact> Match<TFact>(this IQuery query, params Expression<Func<TFact, bool>>[] conditions) Parameters query IQuery Query expression builder. conditions Expression<Func<TFact, bool>>[] Set of conditions the fact must satisfy. Returns IQuery<TFact> Query expression builder. Type Parameters TFact Type of facts to query. OrderByDescending<TSource, TKey>(ICollectQuery<IEnumerable<TSource>>, Expression<Func<TSource, TKey>>) Configures collected matching facts to be sorted descending by key. public static IOrderedQuery<IEnumerable<TSource>> OrderByDescending<TSource, TKey>(this ICollectQuery<IEnumerable<TSource>> source, Expression<Func<TSource, TKey>> keySelector) Parameters source ICollectQuery<IEnumerable<TSource>> Query expression builder. keySelector Expression<Func<TSource, TKey>> Key selection expression used for sorting. Returns IOrderedQuery<IEnumerable<TSource>> Query expression builder. Type Parameters TSource Type of source facts. TKey Type of sorting key. OrderBy<TSource, TKey>(ICollectQuery<IEnumerable<TSource>>, Expression<Func<TSource, TKey>>) Configures collected matching facts to be sorted ascending by key. public static IOrderedQuery<IEnumerable<TSource>> OrderBy<TSource, TKey>(this ICollectQuery<IEnumerable<TSource>> source, Expression<Func<TSource, TKey>> keySelector) Parameters source ICollectQuery<IEnumerable<TSource>> Query expression builder. keySelector Expression<Func<TSource, TKey>> Key selection expression used for sorting. Returns IOrderedQuery<IEnumerable<TSource>> Query expression builder. Type Parameters TSource Type of source facts. TKey Type of sorting key. SelectMany<TSource, TResult>(IQuery<TSource>, Expression<Func<TSource, IEnumerable<TResult>>>) Flattens source facts using collection selector expression. public static IQuery<TResult> SelectMany<TSource, TResult>(this IQuery<TSource> source, Expression<Func<TSource, IEnumerable<TResult>>> selector) Parameters source IQuery<TSource> Query expression builder. selector Expression<Func<TSource, IEnumerable<TResult>>> Collection flattening expression. Returns IQuery<TResult> Query expression builder. Type Parameters TSource Type of source facts. TResult Type of flattened facts. Select<TSource, TResult>(IQuery<TSource>, Expression<Func<TSource, TResult>>) Projects source facts using selector expression. public static IQuery<TResult> Select<TSource, TResult>(this IQuery<TSource> source, Expression<Func<TSource, TResult>> selector) Parameters source IQuery<TSource> Query expression builder. selector Expression<Func<TSource, TResult>> Projection expression. Returns IQuery<TResult> Query expression builder. Type Parameters TSource Type of source facts. TResult Type of projected facts. ThenByDescending<TSource, TKey>(IOrderedQuery<IEnumerable<TSource>>, Expression<Func<TSource, TKey>>) Configures sorted matching facts to subsequently be sorted descending by key. public static IOrderedQuery<IEnumerable<TSource>> ThenByDescending<TSource, TKey>(this IOrderedQuery<IEnumerable<TSource>> source, Expression<Func<TSource, TKey>> keySelector) Parameters source IOrderedQuery<IEnumerable<TSource>> Query expression builder. keySelector Expression<Func<TSource, TKey>> Key selection expression used for sorting. Returns IOrderedQuery<IEnumerable<TSource>> Query expression builder. Type Parameters TSource Type of source facts. TKey Type of sorting key. ThenBy<TSource, TKey>(IOrderedQuery<IEnumerable<TSource>>, Expression<Func<TSource, TKey>>) Configures sorted matching facts to subsequently be sorted ascending by key. public static IOrderedQuery<IEnumerable<TSource>> ThenBy<TSource, TKey>(this IOrderedQuery<IEnumerable<TSource>> source, Expression<Func<TSource, TKey>> keySelector) Parameters source IOrderedQuery<IEnumerable<TSource>> Query expression builder. keySelector Expression<Func<TSource, TKey>> Key selection expression used for sorting. Returns IOrderedQuery<IEnumerable<TSource>> Query expression builder. Type Parameters TSource Type of source facts. TKey Type of sorting key. ToLookup<TSource>(ICollectQuery<IEnumerable<TSource>>) Configures collected matching facts to be arranged into a lookup keyed on the fact itself. public static IQuery<IKeyedLookup<TSource, TSource>> ToLookup<TSource>(this ICollectQuery<IEnumerable<TSource>> source) Parameters source ICollectQuery<IEnumerable<TSource>> Query expression builder. Returns IQuery<IKeyedLookup<TSource, TSource>> Query expression builder. Type Parameters TSource Type of source facts. ToLookup<TSource, TKey>(ICollectQuery<IEnumerable<TSource>>, Expression<Func<TSource, TKey>>) Configures collected matching facts to be arranged into a lookup based on a grouping key. public static IQuery<IKeyedLookup<TKey, TSource>> ToLookup<TSource, TKey>(this ICollectQuery<IEnumerable<TSource>> source, Expression<Func<TSource, TKey>> keySelector) Parameters source ICollectQuery<IEnumerable<TSource>> Query expression builder. keySelector Expression<Func<TSource, TKey>> Grouping key selection expression. Returns IQuery<IKeyedLookup<TKey, TSource>> Query expression builder. Type Parameters TSource Type of source facts. TKey Type of grouping key. ToLookup<TSource, TKey, TElement>(ICollectQuery<IEnumerable<TSource>>, Expression<Func<TSource, TKey>>, Expression<Func<TSource, TElement>>) Configures collected matching facts to be arranged into a lookup based on a grouping key. Projects facts collected into a lookup based on a value selection expression. public static IQuery<IKeyedLookup<TKey, TElement>> ToLookup<TSource, TKey, TElement>(this ICollectQuery<IEnumerable<TSource>> source, Expression<Func<TSource, TKey>> keySelector, Expression<Func<TSource, TElement>> elementSelector) Parameters source ICollectQuery<IEnumerable<TSource>> Query expression builder. keySelector Expression<Func<TSource, TKey>> Grouping key selection expression. elementSelector Expression<Func<TSource, TElement>> Projected fact selection expression. Returns IQuery<IKeyedLookup<TKey, TElement>> Query expression builder. Type Parameters TSource Type of source facts. TKey Type of grouping key. TElement Type of projected facts. Where<TSource>(IQuery<TSource>, params Expression<Func<TSource, bool>>[]) Filters source facts using a set of predicate expressions. The facts must match all predicate expressions in order to pass the filter. public static IQuery<TSource> Where<TSource>(this IQuery<TSource> source, params Expression<Func<TSource, bool>>[] predicates) Parameters source IQuery<TSource> Query expression builder. predicates Expression<Func<TSource, bool>>[] Filter expressions. Returns IQuery<TSource> Query expression builder. Type Parameters TSource Type of facts to filter."
  },
  "api/NRules.Fluent.Dsl.RepeatabilityAttribute.html": {
    "href": "api/NRules.Fluent.Dsl.RepeatabilityAttribute.html",
    "title": "Class RepeatabilityAttribute | NRules",
    "keywords": "Class RepeatabilityAttribute Namespace NRules.Fluent.Dsl Assembly NRules.Fluent.dll Sets rule's repeatability, that is, how it behaves when it is activated with the same set of facts multiple times, which is important for recursion control. By default rules are Repeatable, which means a rule will fire every time it is activated with the same set of facts. If repeatability is set to NonRepeatable then the rule will not fire with the same combination of facts, unless that combination was previously deactivated (i.e. through retraction). [AttributeUsage(AttributeTargets.Class, AllowMultiple = false, Inherited = false)] public sealed class RepeatabilityAttribute : Attribute Inheritance object Attribute RepeatabilityAttribute Inherited Members Attribute.Equals(object) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetHashCode() Attribute.IsDefaultAttribute() Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.Match(object) Attribute.TypeId object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) object.ToString() Constructors RepeatabilityAttribute(RuleRepeatability) public RepeatabilityAttribute(RuleRepeatability value) Parameters value RuleRepeatability"
  },
  "api/NRules.Fluent.Dsl.Rule.html": {
    "href": "api/NRules.Fluent.Dsl.Rule.html",
    "title": "Class Rule | NRules",
    "keywords": "Class Rule Namespace NRules.Fluent.Dsl Assembly NRules.Fluent.dll Base class for inline rule definitions. To create a rule using internal DSL, create a class that inherits from NRules.Fluent.Dsl.Rule and override Define() method. Use When() and Then() methods to define rule's conditions and actions correspondingly. A rule can also be decorated with attributes to add relevant metadata: NameAttribute, DescriptionAttribute, TagAttribute, PriorityAttribute, RepeatabilityAttribute. public abstract class Rule Inheritance object Rule Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors Rule() protected Rule() Methods Define() Method called by the rules engine to define the rule. public abstract void Define() Dependency() Returns expression builder for rule's dependencies. protected IDependencyExpression Dependency() Returns IDependencyExpression Dependencies expression builder. Filter() Returns expression builder for rule's filters. protected IFilterExpression Filter() Returns IFilterExpression Filters expression builder. Name(string) Sets rule's name. Name value set at this level overrides the values specified via NameAttribute attribute. protected void Name(string value) Parameters value string Rule name value. Priority(int) Sets rule's priority. Priority value set at this level overrides the value specified via PriorityAttribute attribute. protected void Priority(int value) Parameters value int Priority value. Then() Returns expression builder for rule's right-hand side (actions). protected IRightHandSideExpression Then() Returns IRightHandSideExpression Right hand side expression builder. When() Returns expression builder for rule's left-hand side (conditions). protected ILeftHandSideExpression When() Returns ILeftHandSideExpression Left hand side expression builder."
  },
  "api/NRules.Fluent.Dsl.TagAttribute.html": {
    "href": "api/NRules.Fluent.Dsl.TagAttribute.html",
    "title": "Class TagAttribute | NRules",
    "keywords": "Class TagAttribute Namespace NRules.Fluent.Dsl Assembly NRules.Fluent.dll Adds a tag to rule's metadata. A rule class can have multiple tag attributes, and also inherits tag attributes from its parent classes. Tags can be used to filter rules when loading them through fluent load specification. [AttributeUsage(AttributeTargets.Class, AllowMultiple = true, Inherited = true)] public class TagAttribute : Attribute Inheritance object Attribute TagAttribute Inherited Members Attribute.Equals(object) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetHashCode() Attribute.IsDefaultAttribute() Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.Match(object) Attribute.TypeId object.Equals(object, object) object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Remarks A custom tag attribute class could be inherited from the TagAttribute to provide strongly-typed version of a tag. Constructors TagAttribute(string) public TagAttribute(string value) Parameters value string"
  },
  "api/NRules.Fluent.Dsl.html": {
    "href": "api/NRules.Fluent.Dsl.html",
    "title": "Namespace NRules.Fluent.Dsl | NRules",
    "keywords": "Namespace NRules.Fluent.Dsl Contains types that allow specifying rules using internal DSL in C#. Classes ContextExtensions DescriptionAttribute Sets rule's description. NameAttribute Sets rule's name. Name set via the attribute overrides the default name, which is the fully qualified class name. PriorityAttribute Sets rule's priority. If multiple rules get activated at the same time, rules with higher priority get executed first. Priority value can be positive, negative or zero. Default priority is zero. QueryExpression<TSource> Expression builder for queries. QueryExtensions RepeatabilityAttribute Sets rule's repeatability, that is, how it behaves when it is activated with the same set of facts multiple times, which is important for recursion control. By default rules are Repeatable, which means a rule will fire every time it is activated with the same set of facts. If repeatability is set to NonRepeatable then the rule will not fire with the same combination of facts, unless that combination was previously deactivated (i.e. through retraction). Rule Base class for inline rule definitions. To create a rule using internal DSL, create a class that inherits from NRules.Fluent.Dsl.Rule and override Define() method. Use When() and Then() methods to define rule's conditions and actions correspondingly. A rule can also be decorated with attributes to add relevant metadata: NameAttribute, DescriptionAttribute, TagAttribute, PriorityAttribute, RepeatabilityAttribute. TagAttribute Adds a tag to rule's metadata. A rule class can have multiple tag attributes, and also inherits tag attributes from its parent classes. Tags can be used to filter rules when loading them through fluent load specification. Interfaces ICollectQuery<TSource> Intermediate query chain element used for Collect modifiers. IDependencyExpression Rule's dependencies expression builder. IFilterExpression Rule's filters expression builder. ILeftHandSideExpression Rule's left-hand side (conditions) expression builder. IOrderedQuery<TSource> Intermediate query chain element used for OrderBy modifiers. IQuery Root of the query method chain. IQueryBuilder Internal builder for queries. IQuery<TSource> Intermediate query chain element. IRightHandSideExpression Rule's right-hand side (actions) expression builder."
  },
  "api/NRules.Fluent.IRuleActivator.html": {
    "href": "api/NRules.Fluent.IRuleActivator.html",
    "title": "Interface IRuleActivator | NRules",
    "keywords": "Interface IRuleActivator Namespace NRules.Fluent Assembly NRules.Fluent.dll Rule activator that instantiates rules based on the CLR types. Default activator uses reflection activator. An instance of IRuleActivator can be assigned to Activator, so that all rule instantiation requests are delegated to the rule activator. public interface IRuleActivator Methods Activate(Type) Creates rule's instances from a CLR type. IEnumerable<Rule> Activate(Type type) Parameters type Type Rule CLR type. Returns IEnumerable<Rule> Rule instances. Remarks The same rule type may be instantiated multiple times with different parameters. Each instance is considered as separate rule, and should have a unique name."
  },
  "api/NRules.Fluent.IRuleLoadSpec.html": {
    "href": "api/NRules.Fluent.IRuleLoadSpec.html",
    "title": "Interface IRuleLoadSpec | NRules",
    "keywords": "Interface IRuleLoadSpec Namespace NRules.Fluent Assembly NRules.Fluent.dll Fluent specification to load rule definitions via reflection. public interface IRuleLoadSpec Methods From(Action<IRuleTypeScanner>) Specifies to load rule definitions by scanning types/assemblies. IRuleLoadSpec From(Action<IRuleTypeScanner> scanAction) Parameters scanAction Action<IRuleTypeScanner> Assembly/type scan action. Returns IRuleLoadSpec Spec to continue fluent configuration. From(IEnumerable<Assembly>) Specifies to load all rule definitions from a given collection of assemblies. IRuleLoadSpec From(IEnumerable<Assembly> assemblies) Parameters assemblies IEnumerable<Assembly> Assemblies to load from. Returns IRuleLoadSpec Spec to continue fluent configuration. From(IEnumerable<Type>) Specifies to load rule definitions from a given collection of types. IRuleLoadSpec From(IEnumerable<Type> types) Parameters types IEnumerable<Type> Types that represent rule definitions. Returns IRuleLoadSpec Spec to continue fluent configuration. From(params Assembly[]) Specifies to load all rule definitions from a given collection of assemblies. IRuleLoadSpec From(params Assembly[] assemblies) Parameters assemblies Assembly[] Assemblies to load from. Returns IRuleLoadSpec Spec to continue fluent configuration. From(params Type[]) Specifies to load rule definitions from a given collection of types. IRuleLoadSpec From(params Type[] types) Parameters types Type[] Types that represent rule definitions. Returns IRuleLoadSpec Spec to continue fluent configuration. NestedTypes(bool) Enables/disables discovery of nested rule classes. Default is off. IRuleLoadSpec NestedTypes(bool include = true) Parameters include bool Include nested types if true, don't include otherwise. Returns IRuleLoadSpec Spec to continue fluent configuration. PrivateTypes(bool) Enables/disables discovery of private rule classes. Default is off. IRuleLoadSpec PrivateTypes(bool include = true) Parameters include bool Include private types if true, don't include otherwise. Returns IRuleLoadSpec Spec to continue fluent configuration. To(string) Specifies the name of the rule set where the rules are loaded to. If not provided, loads rules into default rule set. IRuleLoadSpec To(string ruleSetName) Parameters ruleSetName string Name of the rule set to load rules to. Returns IRuleLoadSpec Spec to continue fluent configuration. Where(Func<IRuleMetadata, bool>) Specifies which rules to load by filtering on rule's metadata. IRuleLoadSpec Where(Func<IRuleMetadata, bool> filter) Parameters filter Func<IRuleMetadata, bool> Filter condition based on rule's metadata. Returns IRuleLoadSpec Spec to continue fluent configuration."
  },
  "api/NRules.Fluent.IRuleMetadata.html": {
    "href": "api/NRules.Fluent.IRuleMetadata.html",
    "title": "Interface IRuleMetadata | NRules",
    "keywords": "Interface IRuleMetadata Namespace NRules.Fluent Assembly NRules.Fluent.dll Metadata associated with a rule defined using internal DSL. public interface IRuleMetadata Extension Methods RuleMetadataExtensions.IsTagged(IRuleMetadata, string) Properties Description Rule's description. string Description { get; } Property Value string Name Rule's name. string Name { get; } Property Value string RuleType Rule's CLR type. Type RuleType { get; } Property Value Type Tags Tags applied to the rule. string[] Tags { get; } Property Value string[]"
  },
  "api/NRules.Fluent.IRuleTypeScanner.html": {
    "href": "api/NRules.Fluent.IRuleTypeScanner.html",
    "title": "Interface IRuleTypeScanner | NRules",
    "keywords": "Interface IRuleTypeScanner Namespace NRules.Fluent Assembly NRules.Fluent.dll Assembly scanner that finds fluent rule classes. public interface IRuleTypeScanner Methods Assembly(params Assembly[]) Finds rule types in the specified assemblies. IRuleTypeScanner Assembly(params Assembly[] assemblies) Parameters assemblies Assembly[] Assemblies to scan. Returns IRuleTypeScanner Rule type scanner to continue scanning specification. AssemblyOf(Type) Finds rule types in the assembly of the specified type. IRuleTypeScanner AssemblyOf(Type type) Parameters type Type Type, whose assembly to scan. Returns IRuleTypeScanner Rule type scanner to continue scanning specification. AssemblyOf<T>() Finds rule types in the assembly of the specified type. IRuleTypeScanner AssemblyOf<T>() Returns IRuleTypeScanner Rule type scanner to continue scanning specification. Type Parameters T Type, whose assembly to scan. NestedTypes(bool) Enables/disables discovery of nested rule classes. Default is off. IRuleTypeScanner NestedTypes(bool include = true) Parameters include bool Include nested types if true, don't include otherwise. Returns IRuleTypeScanner Rule type scanner to continue scanning specification. PrivateTypes(bool) Enables/disables discovery of private rule classes. Default is off. IRuleTypeScanner PrivateTypes(bool include = true) Parameters include bool Include private types if true, don't include otherwise. Returns IRuleTypeScanner Rule type scanner to continue scanning specification. Type(params Type[]) Finds rule types in the specifies types. IRuleTypeScanner Type(params Type[] types) Parameters types Type[] Types to scan. Returns IRuleTypeScanner Rule type scanner to continue scanning specification."
  },
  "api/NRules.Fluent.RuleActivationException.html": {
    "href": "api/NRules.Fluent.RuleActivationException.html",
    "title": "Class RuleActivationException | NRules",
    "keywords": "Class RuleActivationException Namespace NRules.Fluent Assembly NRules.Fluent.dll Represents errors that occur when instantiating rule classes. [Serializable] public class RuleActivationException : Exception, ISerializable Inheritance object Exception RuleActivationException Implements ISerializable Inherited Members Exception.GetBaseException() Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState object.Equals(object) object.Equals(object, object) object.GetHashCode() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors RuleActivationException(SerializationInfo, StreamingContext) protected RuleActivationException(SerializationInfo info, StreamingContext context) Parameters info SerializationInfo context StreamingContext Properties Message Gets a message that describes the current exception. public override string Message { get; } Property Value string The error message that explains the reason for the exception, or an empty string (\"\"). RuleType Rule CLR type that caused exception. public Type RuleType { get; } Property Value Type RuleTypeName Rule CLR type name that caused exception. public string RuleTypeName { get; } Property Value string Methods GetObjectData(SerializationInfo, StreamingContext) When overridden in a derived class, sets the SerializationInfo with information about the exception. [SecurityCritical] public override void GetObjectData(SerializationInfo info, StreamingContext context) Parameters info SerializationInfo The SerializationInfo that holds the serialized object data about the exception being thrown. context StreamingContext The StreamingContext that contains contextual information about the source or destination. Exceptions ArgumentNullException The info parameter is a null reference (Nothing in Visual Basic)."
  },
  "api/NRules.Fluent.RuleDefinitionException.html": {
    "href": "api/NRules.Fluent.RuleDefinitionException.html",
    "title": "Class RuleDefinitionException | NRules",
    "keywords": "Class RuleDefinitionException Namespace NRules.Fluent Assembly NRules.Fluent.dll Represents errors that occur while building rule definition using fluent DSL. [Serializable] public class RuleDefinitionException : Exception, ISerializable Inheritance object Exception RuleDefinitionException Implements ISerializable Inherited Members Exception.GetBaseException() Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState object.Equals(object) object.Equals(object, object) object.GetHashCode() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors RuleDefinitionException(SerializationInfo, StreamingContext) protected RuleDefinitionException(SerializationInfo info, StreamingContext context) Parameters info SerializationInfo context StreamingContext Properties Message Gets a message that describes the current exception. public override string Message { get; } Property Value string The error message that explains the reason for the exception, or an empty string (\"\"). RuleType Rule CLR type that caused exception. public Type RuleType { get; } Property Value Type RuleTypeName Rule CLR type name that caused exception. public string RuleTypeName { get; } Property Value string Methods GetObjectData(SerializationInfo, StreamingContext) When overridden in a derived class, sets the SerializationInfo with information about the exception. [SecurityCritical] public override void GetObjectData(SerializationInfo info, StreamingContext context) Parameters info SerializationInfo The SerializationInfo that holds the serialized object data about the exception being thrown. context StreamingContext The StreamingContext that contains contextual information about the source or destination. Exceptions ArgumentNullException The info parameter is a null reference (Nothing in Visual Basic)."
  },
  "api/NRules.Fluent.RuleDefinitionFactory.html": {
    "href": "api/NRules.Fluent.RuleDefinitionFactory.html",
    "title": "Class RuleDefinitionFactory | NRules",
    "keywords": "Class RuleDefinitionFactory Namespace NRules.Fluent Assembly NRules.Fluent.dll Creates instances of IRuleDefinition from the fluent DSL Rule instances. public class RuleDefinitionFactory Inheritance object RuleDefinitionFactory Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods Create(Rule) Creates a IRuleDefinition for an instance of a fluent DSL Rule. public IRuleDefinition Create(Rule rule) Parameters rule Rule Fluent DSL Rule instance. Returns IRuleDefinition Corresponding instance of IRuleDefinition. Create(IEnumerable<Rule>) Creates instances of IRuleDefinition from the fluent DSL Rule instances. public IEnumerable<IRuleDefinition> Create(IEnumerable<Rule> rules) Parameters rules IEnumerable<Rule> Fluent DSL Rule instances. Returns IEnumerable<IRuleDefinition> Corresponding instances of IRuleDefinition."
  },
  "api/NRules.Fluent.RuleMetadata.html": {
    "href": "api/NRules.Fluent.RuleMetadata.html",
    "title": "Class RuleMetadata | NRules",
    "keywords": "Class RuleMetadata Namespace NRules.Fluent Assembly NRules.Fluent.dll Metadata associated with a rule defined using internal DSL. public class RuleMetadata : IRuleMetadata Inheritance object RuleMetadata Implements IRuleMetadata Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Extension Methods RuleMetadataExtensions.IsTagged(IRuleMetadata, string) Constructors RuleMetadata(Type) public RuleMetadata(Type ruleType) Parameters ruleType Type Properties Description Rule's description. public string Description { get; } Property Value string Name Rule's name. public string Name { get; } Property Value string Priority Rule's priority. public int? Priority { get; } Property Value int? Repeatability Rule's repeatability. public RuleRepeatability? Repeatability { get; } Property Value RuleRepeatability? RuleType Rule's CLR type. public Type RuleType { get; } Property Value Type Tags Tags applied to the rule. public string[] Tags { get; } Property Value string[]"
  },
  "api/NRules.Fluent.RuleMetadataExtensions.html": {
    "href": "api/NRules.Fluent.RuleMetadataExtensions.html",
    "title": "Class RuleMetadataExtensions | NRules",
    "keywords": "Class RuleMetadataExtensions Namespace NRules.Fluent Assembly NRules.Fluent.dll public static class RuleMetadataExtensions Inheritance object RuleMetadataExtensions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods IsTagged(IRuleMetadata, string) Tests if the rule is tagged with a given tag. public static bool IsTagged(this IRuleMetadata metadata, string tag) Parameters metadata IRuleMetadata Rule metadata instance. tag string Tag to test. Returns bool true if the rule is tagged, false otherwise."
  },
  "api/NRules.Fluent.RuleProperties.html": {
    "href": "api/NRules.Fluent.RuleProperties.html",
    "title": "Class RuleProperties | NRules",
    "keywords": "Class RuleProperties Namespace NRules.Fluent Assembly NRules.Fluent.dll Rule property names. public static class RuleProperties Inheritance object RuleProperties Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields ClrType CLR Type of the fluent DSL rule class. public const string ClrType = \"Fluent::ClrType\" Field Value string"
  },
  "api/NRules.Fluent.RuleRepository.html": {
    "href": "api/NRules.Fluent.RuleRepository.html",
    "title": "Class RuleRepository | NRules",
    "keywords": "Class RuleRepository Namespace NRules.Fluent Assembly NRules.Fluent.dll Rules repository based on the rules defined inline using internal DSL. Use Load(Action<IRuleLoadSpec>) method to fluently load rules into the repository. public class RuleRepository : IRuleRepository Inheritance object RuleRepository Implements IRuleRepository Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Extension Methods RuleRepositoryExtensions.Compile(IRuleRepository) RuleRepositoryExtensions.Compile(IRuleRepository, CancellationToken) RuleRepositoryExtensions.GetRules(IRuleRepository) Constructors RuleRepository() Creates an empty rule repository with the default IRuleActivator. public RuleRepository() See Also DefaultRuleActivator RuleRepository(IRuleActivator) Creates an empty rule repository with the specified IRuleActivator. public RuleRepository(IRuleActivator activator) Parameters activator IRuleActivator Properties Activator Rules activator that instantiates rules based on a CLR type. public IRuleActivator Activator { get; set; } Property Value IRuleActivator Methods Add(IRuleSet) Adds a new rule set to the rule repository. public void Add(IRuleSet ruleSet) Parameters ruleSet IRuleSet Rule set to add. Exceptions ArgumentException A rule set with the same name already exists. GetRuleSets() Retrieves all rule sets contained in the repository. public IEnumerable<IRuleSet> GetRuleSets() Returns IEnumerable<IRuleSet> Collection of rule sets. Load(Action<IRuleLoadSpec>) Loads rules into a rule set using provided loader specification. IRuleLoadSpec public void Load(Action<IRuleLoadSpec> specAction) Parameters specAction Action<IRuleLoadSpec> Rule loader specification."
  },
  "api/NRules.Fluent.RuleTypeScanner.html": {
    "href": "api/NRules.Fluent.RuleTypeScanner.html",
    "title": "Class RuleTypeScanner | NRules",
    "keywords": "Class RuleTypeScanner Namespace NRules.Fluent Assembly NRules.Fluent.dll Assembly scanner that finds fluent rule classes. public class RuleTypeScanner : IRuleTypeScanner Inheritance object RuleTypeScanner Implements IRuleTypeScanner Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods Assembly(params Assembly[]) Finds rule types in the specified assemblies. public IRuleTypeScanner Assembly(params Assembly[] assemblies) Parameters assemblies Assembly[] Assemblies to scan. Returns IRuleTypeScanner Rule type scanner to continue scanning specification. AssemblyOf(Type) Finds rule types in the assembly of the specified type. public IRuleTypeScanner AssemblyOf(Type type) Parameters type Type Type, whose assembly to scan. Returns IRuleTypeScanner Rule type scanner to continue scanning specification. AssemblyOf<T>() Finds rule types in the assembly of the specified type. public IRuleTypeScanner AssemblyOf<T>() Returns IRuleTypeScanner Rule type scanner to continue scanning specification. Type Parameters T Type, whose assembly to scan. GetRuleTypes() Retrieves found types. public Type[] GetRuleTypes() Returns Type[] Rule types. IsRuleType(Type) Determines if a given CLR type is a rule type. public static bool IsRuleType(Type type) Parameters type Type Type to check. Returns bool Result of the check. NestedTypes(bool) Enables/disables discovery of nested rule classes. Default is off. public IRuleTypeScanner NestedTypes(bool include = true) Parameters include bool Include nested types if true, don't include otherwise. Returns IRuleTypeScanner Rule type scanner to continue scanning specification. PrivateTypes(bool) Enables/disables discovery of private rule classes. Default is off. public IRuleTypeScanner PrivateTypes(bool include = true) Parameters include bool Include private types if true, don't include otherwise. Returns IRuleTypeScanner Rule type scanner to continue scanning specification. Type(params Type[]) Finds rule types in the specifies types. public IRuleTypeScanner Type(params Type[] types) Parameters types Type[] Types to scan. Returns IRuleTypeScanner Rule type scanner to continue scanning specification."
  },
  "api/NRules.Fluent.html": {
    "href": "api/NRules.Fluent.html",
    "title": "Namespace NRules.Fluent | NRules",
    "keywords": "Namespace NRules.Fluent Contains types that allow loading internal DSL rules via reflection. Classes DefaultRuleActivator Default rule activator that uses reflection to instantiate rules. RuleActivationException Represents errors that occur when instantiating rule classes. RuleDefinitionException Represents errors that occur while building rule definition using fluent DSL. RuleDefinitionFactory Creates instances of IRuleDefinition from the fluent DSL Rule instances. RuleMetadata Metadata associated with a rule defined using internal DSL. RuleMetadataExtensions RuleProperties Rule property names. RuleRepository Rules repository based on the rules defined inline using internal DSL. Use Load(Action<IRuleLoadSpec>) method to fluently load rules into the repository. RuleTypeScanner Assembly scanner that finds fluent rule classes. Interfaces IRuleActivator Rule activator that instantiates rules based on the CLR types. Default activator uses reflection activator. An instance of IRuleActivator can be assigned to Activator, so that all rule instantiation requests are delegated to the rule activator. IRuleLoadSpec Fluent specification to load rule definitions via reflection. IRuleMetadata Metadata associated with a rule defined using internal DSL. IRuleTypeScanner Assembly scanner that finds fluent rule classes."
  },
  "api/NRules.IAgenda.html": {
    "href": "api/NRules.IAgenda.html",
    "title": "Interface IAgenda | NRules",
    "keywords": "Interface IAgenda Namespace NRules Assembly NRules.dll Agenda stores matches between rules and facts. These matches are called activations. Multiple activations are ordered according to the conflict resolution strategy. public interface IAgenda Properties IsEmpty Indicates whether there are any activations in the agenda. bool IsEmpty { get; } Property Value bool If agenda is empty then true otherwise false. Methods AddFilter(IAgendaFilter) Adds a global filter to the agenda. void AddFilter(IAgendaFilter filter) Parameters filter IAgendaFilter Filter to be applied to all activations before they are placed on the agenda. AddFilter(IRuleDefinition, IAgendaFilter) Adds a rule-level filter to the agenda. void AddFilter(IRuleDefinition rule, IAgendaFilter filter) Parameters rule IRuleDefinition Rule, whose activations are to be filtered before placing them on the agenda. filter IAgendaFilter Filter to be applied to all activations for a given rule before they are placed on the agenda. Clear() Removes all matches from agenda. void Clear() Peek() Retrieves the next match, without removing it from agenda. IMatch Peek() Returns IMatch Next match. Remarks Throws InvalidOperationException if agenda is empty. See Also IMatch IAgendaFilter"
  },
  "api/NRules.IFactResult.html": {
    "href": "api/NRules.IFactResult.html",
    "title": "Interface IFactResult | NRules",
    "keywords": "Interface IFactResult Namespace NRules Assembly NRules.dll Result of an operation on a set of facts. public interface IFactResult Properties Failed Facts on which the operation failed. IEnumerable<object> Failed { get; } Property Value IEnumerable<object> FailedCount Number of facts on which the operation failed. int FailedCount { get; } Property Value int"
  },
  "api/NRules.ILinkedFactSet.html": {
    "href": "api/NRules.ILinkedFactSet.html",
    "title": "Interface ILinkedFactSet | NRules",
    "keywords": "Interface ILinkedFactSet Namespace NRules Assembly NRules.dll Collection of linked facts propagated as a set. public interface ILinkedFactSet Properties Action Action taken on the linked fact. LinkedFactAction Action { get; } Property Value LinkedFactAction FactCount Number of linked facts in the set. int FactCount { get; } Property Value int Facts Linked facts in the set. IEnumerable<IFact> Facts { get; } Property Value IEnumerable<IFact>"
  },
  "api/NRules.ILinkedFactSource.html": {
    "href": "api/NRules.ILinkedFactSource.html",
    "title": "Interface ILinkedFactSource | NRules",
    "keywords": "Interface ILinkedFactSource Namespace NRules Assembly NRules.dll Fact source for linked facts. public interface ILinkedFactSource : IFactSource Inherited Members IFactSource.SourceType IFactSource.Facts Properties Rule Rule that generated the linked fact. IRuleDefinition Rule { get; } Property Value IRuleDefinition"
  },
  "api/NRules.ISession.html": {
    "href": "api/NRules.ISession.html",
    "title": "Interface ISession | NRules",
    "keywords": "Interface ISession Namespace NRules Assembly NRules.dll Represents a rules engine session. Created by ISessionFactory. Each session has its own working memory, and exposes operations that manipulate facts in it, as well as fire matching rules. public interface ISession : ISessionSchemaProvider Inherited Members ISessionSchemaProvider.GetSchema() Properties ActionInterceptor Action interceptor for the current rules session. If provided, invocation of rule actions is delegated to the interceptor. IActionInterceptor ActionInterceptor { get; set; } Property Value IActionInterceptor Exceptions RuleLhsExpressionEvaluationException Error while evaluating any of the rules' left-hand side expressons. This exception can also be observed as an event LhsExpressionEvaluatedEvent. AgendaExpressionEvaluationException Error while evaluating any of the agenda expressions. This exception can also be observed as an event AgendaExpressionFailedEvent. RuleRhsExpressionEvaluationException Error while evaluating any of the rules' right-hand side expressions. This exception can also be observed as an event RhsExpressionFailedEvent. Agenda Agenda, which represents a store for rule matches. IAgenda Agenda { get; } Property Value IAgenda Exceptions RuleLhsExpressionEvaluationException Error while evaluating any of the rules' left-hand side expressons. This exception can also be observed as an event LhsExpressionEvaluatedEvent. AgendaExpressionEvaluationException Error while evaluating any of the agenda expressions. This exception can also be observed as an event AgendaExpressionFailedEvent. RuleRhsExpressionEvaluationException Error while evaluating any of the rules' right-hand side expressions. This exception can also be observed as an event RhsExpressionFailedEvent. AutoPropagateLinkedFacts Controls how the engine propagates linked facts from rules that insert/update/retract linked facts in their actions. By default, AutoPropagateLinkedFacts is true and the engine automatically propagates linked facts at the end of the rule's actions. If AutoPropagateLinkedFacts is false, linked facts are queued, and have to be explicitly propagated by calling PropagateLinked() method. bool AutoPropagateLinkedFacts { get; set; } Property Value bool Exceptions RuleLhsExpressionEvaluationException Error while evaluating any of the rules' left-hand side expressons. This exception can also be observed as an event LhsExpressionEvaluatedEvent. AgendaExpressionEvaluationException Error while evaluating any of the agenda expressions. This exception can also be observed as an event AgendaExpressionFailedEvent. RuleRhsExpressionEvaluationException Error while evaluating any of the rules' right-hand side expressions. This exception can also be observed as an event RhsExpressionFailedEvent. DependencyResolver Rules dependency resolver for the current rules session. IDependencyResolver DependencyResolver { get; set; } Property Value IDependencyResolver Exceptions RuleLhsExpressionEvaluationException Error while evaluating any of the rules' left-hand side expressons. This exception can also be observed as an event LhsExpressionEvaluatedEvent. AgendaExpressionEvaluationException Error while evaluating any of the agenda expressions. This exception can also be observed as an event AgendaExpressionFailedEvent. RuleRhsExpressionEvaluationException Error while evaluating any of the rules' right-hand side expressions. This exception can also be observed as an event RhsExpressionFailedEvent. Events Provider of events from the current rule session. Use it to subscribe to various rules engine lifecycle events. IEventProvider Events { get; } Property Value IEventProvider Exceptions RuleLhsExpressionEvaluationException Error while evaluating any of the rules' left-hand side expressons. This exception can also be observed as an event LhsExpressionEvaluatedEvent. AgendaExpressionEvaluationException Error while evaluating any of the agenda expressions. This exception can also be observed as an event AgendaExpressionFailedEvent. RuleRhsExpressionEvaluationException Error while evaluating any of the rules' right-hand side expressions. This exception can also be observed as an event RhsExpressionFailedEvent. Metrics Provider of session performance metrics for the current rule session. IMetricsProvider Metrics { get; } Property Value IMetricsProvider Exceptions RuleLhsExpressionEvaluationException Error while evaluating any of the rules' left-hand side expressons. This exception can also be observed as an event LhsExpressionEvaluatedEvent. AgendaExpressionEvaluationException Error while evaluating any of the agenda expressions. This exception can also be observed as an event AgendaExpressionFailedEvent. RuleRhsExpressionEvaluationException Error while evaluating any of the rules' right-hand side expressions. This exception can also be observed as an event RhsExpressionFailedEvent. Methods Fire() Starts rules execution cycle. This method blocks until there are no more rules to fire. int Fire() Returns int Number of rules that fired. Exceptions RuleLhsExpressionEvaluationException Error while evaluating any of the rules' left-hand side expressons. This exception can also be observed as an event LhsExpressionEvaluatedEvent. AgendaExpressionEvaluationException Error while evaluating any of the agenda expressions. This exception can also be observed as an event AgendaExpressionFailedEvent. RuleRhsExpressionEvaluationException Error while evaluating any of the rules' right-hand side expressions. This exception can also be observed as an event RhsExpressionFailedEvent. Fire(int) Starts rules execution cycle. This method blocks until maximum number of rules fired or there are no more rules to fire. int Fire(int maxRulesNumber) Parameters maxRulesNumber int Maximum number of rules to fire. Returns int Number of rules that fired. Exceptions RuleLhsExpressionEvaluationException Error while evaluating any of the rules' left-hand side expressons. This exception can also be observed as an event LhsExpressionEvaluatedEvent. AgendaExpressionEvaluationException Error while evaluating any of the agenda expressions. This exception can also be observed as an event AgendaExpressionFailedEvent. RuleRhsExpressionEvaluationException Error while evaluating any of the rules' right-hand side expressions. This exception can also be observed as an event RhsExpressionFailedEvent. Fire(int, CancellationToken) Starts rules execution cycle. This method blocks until maximum number of rules fired, cancellation is requested or there are no more rules to fire. int Fire(int maxRulesNumber, CancellationToken cancellationToken) Parameters maxRulesNumber int Maximum number of rules to fire. cancellationToken CancellationToken Enables cooperative cancellation of the rules execution cycle. Returns int Number of rules that fired. Exceptions RuleLhsExpressionEvaluationException Error while evaluating any of the rules' left-hand side expressons. This exception can also be observed as an event LhsExpressionEvaluatedEvent. AgendaExpressionEvaluationException Error while evaluating any of the agenda expressions. This exception can also be observed as an event AgendaExpressionFailedEvent. RuleRhsExpressionEvaluationException Error while evaluating any of the rules' right-hand side expressions. This exception can also be observed as an event RhsExpressionFailedEvent. Fire(CancellationToken) Starts rules execution cycle. This method blocks until there are no more rules to fire or cancellation is requested. int Fire(CancellationToken cancellationToken) Parameters cancellationToken CancellationToken Enables cooperative cancellation of the rules execution cycle. Returns int Number of rules that fired. Exceptions RuleLhsExpressionEvaluationException Error while evaluating any of the rules' left-hand side expressons. This exception can also be observed as an event LhsExpressionEvaluatedEvent. AgendaExpressionEvaluationException Error while evaluating any of the agenda expressions. This exception can also be observed as an event AgendaExpressionFailedEvent. RuleRhsExpressionEvaluationException Error while evaluating any of the rules' right-hand side expressions. This exception can also be observed as an event RhsExpressionFailedEvent. Insert(object) Inserts new fact to the rules engine memory. void Insert(object fact) Parameters fact object Facts to insert. Remarks Bulk session operations are more performant than individual operations on a set of facts. Exceptions ArgumentException If fact already exists in working memory. InsertAll(IEnumerable<object>) Inserts new facts to the rules engine memory. void InsertAll(IEnumerable<object> facts) Parameters facts IEnumerable<object> Facts to insert. Remarks Bulk session operations are more performant than individual operations on a set of facts. Exceptions ArgumentException If any fact already exists in working memory. PropagateLinked() Propagates all queued linked facts. IEnumerable<ILinkedFactSet> PropagateLinked() Returns IEnumerable<ILinkedFactSet> Collection of propagated sets of linked facts. Exceptions RuleLhsExpressionEvaluationException Error while evaluating any of the rules' left-hand side expressons. This exception can also be observed as an event LhsExpressionEvaluatedEvent. AgendaExpressionEvaluationException Error while evaluating any of the agenda expressions. This exception can also be observed as an event AgendaExpressionFailedEvent. RuleRhsExpressionEvaluationException Error while evaluating any of the rules' right-hand side expressions. This exception can also be observed as an event RhsExpressionFailedEvent. Query<TFact>() Creates a LINQ query to retrieve facts of a given type from the rules engine's memory. IQueryable<TFact> Query<TFact>() Returns IQueryable<TFact> Queryable working memory of the rules engine. Type Parameters TFact Type of facts to query. Use object to query all facts. Exceptions RuleLhsExpressionEvaluationException Error while evaluating any of the rules' left-hand side expressons. This exception can also be observed as an event LhsExpressionEvaluatedEvent. AgendaExpressionEvaluationException Error while evaluating any of the agenda expressions. This exception can also be observed as an event AgendaExpressionFailedEvent. RuleRhsExpressionEvaluationException Error while evaluating any of the rules' right-hand side expressions. This exception can also be observed as an event RhsExpressionFailedEvent. Retract(object) Removes existing fact from the rules engine memory. void Retract(object fact) Parameters fact object Fact to remove. Remarks Bulk session operations are more performant than individual operations on a set of facts. Exceptions ArgumentException If fact does not exist in working memory. RetractAll(IEnumerable<object>) Removes existing facts from the rules engine memory. void RetractAll(IEnumerable<object> facts) Parameters facts IEnumerable<object> Facts to remove. Remarks Bulk session operations are more performant than individual operations on a set of facts. Exceptions ArgumentException If any fact does not exist in working memory. TryInsert(object) Inserts a fact to the rules engine memory if the fact does not exist. bool TryInsert(object fact) Parameters fact object Fact to insert. Returns bool Whether the fact was inserted or not. Remarks Bulk session operations are more performant than individual operations on a set of facts. Exceptions RuleLhsExpressionEvaluationException Error while evaluating any of the rules' left-hand side expressons. This exception can also be observed as an event LhsExpressionEvaluatedEvent. AgendaExpressionEvaluationException Error while evaluating any of the agenda expressions. This exception can also be observed as an event AgendaExpressionFailedEvent. RuleRhsExpressionEvaluationException Error while evaluating any of the rules' right-hand side expressions. This exception can also be observed as an event RhsExpressionFailedEvent. TryInsertAll(IEnumerable<object>) Inserts new facts to the rules engine memory if the facts don't exist. If any of the facts exists in the engine, none of the facts are inserted. IFactResult TryInsertAll(IEnumerable<object> facts) Parameters facts IEnumerable<object> Facts to insert. Returns IFactResult Result of facts insertion. Remarks Bulk session operations are more performant than individual operations on a set of facts. Exceptions RuleLhsExpressionEvaluationException Error while evaluating any of the rules' left-hand side expressons. This exception can also be observed as an event LhsExpressionEvaluatedEvent. AgendaExpressionEvaluationException Error while evaluating any of the agenda expressions. This exception can also be observed as an event AgendaExpressionFailedEvent. RuleRhsExpressionEvaluationException Error while evaluating any of the rules' right-hand side expressions. This exception can also be observed as an event RhsExpressionFailedEvent. TryInsertAll(IEnumerable<object>, BatchOptions) Inserts new facts to the rules engine memory if the facts don't exist. If any of the facts exists in the engine, the behavior is defined by BatchOptions. IFactResult TryInsertAll(IEnumerable<object> facts, BatchOptions options) Parameters facts IEnumerable<object> Facts to insert. options BatchOptions Options that define behavior of the batch operation. Returns IFactResult Result of facts insertion. Remarks Bulk session operations are more performant than individual operations on a set of facts. Exceptions RuleLhsExpressionEvaluationException Error while evaluating any of the rules' left-hand side expressons. This exception can also be observed as an event LhsExpressionEvaluatedEvent. AgendaExpressionEvaluationException Error while evaluating any of the agenda expressions. This exception can also be observed as an event AgendaExpressionFailedEvent. RuleRhsExpressionEvaluationException Error while evaluating any of the rules' right-hand side expressions. This exception can also be observed as an event RhsExpressionFailedEvent. TryRetract(object) Removes a fact from the rules engine memory if the fact exists. bool TryRetract(object facts) Parameters facts object Fact to remove. Returns bool Whether the fact was retracted or not. Remarks Bulk session operations are more performant than individual operations on a set of facts. Exceptions RuleLhsExpressionEvaluationException Error while evaluating any of the rules' left-hand side expressons. This exception can also be observed as an event LhsExpressionEvaluatedEvent. AgendaExpressionEvaluationException Error while evaluating any of the agenda expressions. This exception can also be observed as an event AgendaExpressionFailedEvent. RuleRhsExpressionEvaluationException Error while evaluating any of the rules' right-hand side expressions. This exception can also be observed as an event RhsExpressionFailedEvent. TryRetractAll(IEnumerable<object>) Removes existing facts from the rules engine memory if the facts exist. If any of the facts don't exist in the engine, none of the facts are removed. IFactResult TryRetractAll(IEnumerable<object> facts) Parameters facts IEnumerable<object> Facts to remove. Returns IFactResult Result of facts removal. Remarks Bulk session operations are more performant than individual operations on a set of facts. Exceptions RuleLhsExpressionEvaluationException Error while evaluating any of the rules' left-hand side expressons. This exception can also be observed as an event LhsExpressionEvaluatedEvent. AgendaExpressionEvaluationException Error while evaluating any of the agenda expressions. This exception can also be observed as an event AgendaExpressionFailedEvent. RuleRhsExpressionEvaluationException Error while evaluating any of the rules' right-hand side expressions. This exception can also be observed as an event RhsExpressionFailedEvent. TryRetractAll(IEnumerable<object>, BatchOptions) Removes existing facts from the rules engine memory if the facts exist. If any of the facts don't exist in the engine, the behavior is defined by BatchOptions. IFactResult TryRetractAll(IEnumerable<object> facts, BatchOptions options) Parameters facts IEnumerable<object> Facts to remove. options BatchOptions Options that define behavior of the batch operation. Returns IFactResult Result of facts removal. Remarks Bulk session operations are more performant than individual operations on a set of facts. Exceptions RuleLhsExpressionEvaluationException Error while evaluating any of the rules' left-hand side expressons. This exception can also be observed as an event LhsExpressionEvaluatedEvent. AgendaExpressionEvaluationException Error while evaluating any of the agenda expressions. This exception can also be observed as an event AgendaExpressionFailedEvent. RuleRhsExpressionEvaluationException Error while evaluating any of the rules' right-hand side expressions. This exception can also be observed as an event RhsExpressionFailedEvent. TryUpdate(object) Updates a fact in the rules engine memory if the fact exists. bool TryUpdate(object fact) Parameters fact object Fact to update. Returns bool Whether the fact was updated or not. Remarks Bulk session operations are more performant than individual operations on a set of facts. Exceptions RuleLhsExpressionEvaluationException Error while evaluating any of the rules' left-hand side expressons. This exception can also be observed as an event LhsExpressionEvaluatedEvent. AgendaExpressionEvaluationException Error while evaluating any of the agenda expressions. This exception can also be observed as an event AgendaExpressionFailedEvent. RuleRhsExpressionEvaluationException Error while evaluating any of the rules' right-hand side expressions. This exception can also be observed as an event RhsExpressionFailedEvent. TryUpdateAll(IEnumerable<object>) Updates existing facts in the rules engine memory if the facts exist. If any of the facts don't exist in the engine, none of the facts are updated. IFactResult TryUpdateAll(IEnumerable<object> facts) Parameters facts IEnumerable<object> Facts to update. Returns IFactResult Result of facts update. Remarks Bulk session operations are more performant than individual operations on a set of facts. Exceptions RuleLhsExpressionEvaluationException Error while evaluating any of the rules' left-hand side expressons. This exception can also be observed as an event LhsExpressionEvaluatedEvent. AgendaExpressionEvaluationException Error while evaluating any of the agenda expressions. This exception can also be observed as an event AgendaExpressionFailedEvent. RuleRhsExpressionEvaluationException Error while evaluating any of the rules' right-hand side expressions. This exception can also be observed as an event RhsExpressionFailedEvent. TryUpdateAll(IEnumerable<object>, BatchOptions) Updates existing facts in the rules engine memory if the facts exist. If any of the facts don't exist in the engine, the behavior is defined by BatchOptions. IFactResult TryUpdateAll(IEnumerable<object> facts, BatchOptions options) Parameters facts IEnumerable<object> Facts to update. options BatchOptions Options that define behavior of the batch operation. Returns IFactResult Result of facts update. Remarks Bulk session operations are more performant than individual operations on a set of facts. Exceptions RuleLhsExpressionEvaluationException Error while evaluating any of the rules' left-hand side expressons. This exception can also be observed as an event LhsExpressionEvaluatedEvent. AgendaExpressionEvaluationException Error while evaluating any of the agenda expressions. This exception can also be observed as an event AgendaExpressionFailedEvent. RuleRhsExpressionEvaluationException Error while evaluating any of the rules' right-hand side expressions. This exception can also be observed as an event RhsExpressionFailedEvent. Update(object) Updates existing fact in the rules engine memory. void Update(object fact) Parameters fact object Fact to update. Remarks Bulk session operations are more performant than individual operations on a set of facts. Exceptions ArgumentException If fact does not exist in working memory. UpdateAll(IEnumerable<object>) Updates existing facts in the rules engine memory. void UpdateAll(IEnumerable<object> facts) Parameters facts IEnumerable<object> Facts to update. Remarks Bulk session operations are more performant than individual operations on a set of facts. Exceptions ArgumentException If any fact does not exist in working memory. See Also ISessionFactory"
  },
  "api/NRules.ISessionFactory.html": {
    "href": "api/NRules.ISessionFactory.html",
    "title": "Interface ISessionFactory | NRules",
    "keywords": "Interface ISessionFactory Namespace NRules Assembly NRules.dll Represents compiled production rules that can be used to create rules sessions. Created by RuleCompiler by compiling rule model into an executable form. public interface ISessionFactory : ISessionSchemaProvider Inherited Members ISessionSchemaProvider.GetSchema() Remarks Session factory is expensive to create (because rules need to be compiled into an executable form). Therefore there needs to be only a single instance of session factory for a given set of rules for the lifetime of the application. If repeatedly running rules for different sets of facts, don't create a new session factory for each rules run. Instead, have a single session factory and create a new rules session for each independent universe of facts. Properties ActionInterceptor Action interceptor for all rules sessions. If provided, invocation of rule actions is delegated to the interceptor. IActionInterceptor ActionInterceptor { get; set; } Property Value IActionInterceptor DependencyResolver Rules dependency resolver for all rules sessions. IDependencyResolver DependencyResolver { get; set; } Property Value IDependencyResolver Events Provider of events aggregated across all rule sessions. Event sender is used to convey the session instance responsible for the event. Use it to subscribe to various rules engine lifecycle events. IEventProvider Events { get; } Property Value IEventProvider Methods CreateSession() Creates a new rules session. ISession CreateSession() Returns ISession New rules session. CreateSession(Action<ISession>) Creates a new rules session. ISession CreateSession(Action<ISession> initializationAction) Parameters initializationAction Action<ISession> Action invoked on the newly created session, before the session is activated (which could result in rule matches placed on the agenda). Returns ISession New rules session. See Also ISession RuleCompiler"
  },
  "api/NRules.Integration.Autofac.AutofacDependencyResolver.html": {
    "href": "api/NRules.Integration.Autofac.AutofacDependencyResolver.html",
    "title": "Class AutofacDependencyResolver | NRules",
    "keywords": "Class AutofacDependencyResolver Namespace NRules.Integration.Autofac Assembly NRules.Integration.Autofac.dll Dependency resolver that uses Autofac DI container. public class AutofacDependencyResolver : IDependencyResolver Inheritance object AutofacDependencyResolver Implements IDependencyResolver Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors AutofacDependencyResolver(ILifetimeScope) public AutofacDependencyResolver(ILifetimeScope container) Parameters container ILifetimeScope Methods Resolve(IResolutionContext, Type) Resolves a registered service (normally via an IoC container). public object Resolve(IResolutionContext context, Type serviceType) Parameters context IResolutionContext Information about the context at which the resolution call is made. serviceType Type The type of requested service. Returns object Requested service."
  },
  "api/NRules.Integration.Autofac.AutofacRuleActivator.html": {
    "href": "api/NRules.Integration.Autofac.AutofacRuleActivator.html",
    "title": "Class AutofacRuleActivator | NRules",
    "keywords": "Class AutofacRuleActivator Namespace NRules.Integration.Autofac Assembly NRules.Integration.Autofac.dll Rule activator that uses Autofac DI container. public class AutofacRuleActivator : IRuleActivator Inheritance object AutofacRuleActivator Implements IRuleActivator Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors AutofacRuleActivator(ILifetimeScope) public AutofacRuleActivator(ILifetimeScope container) Parameters container ILifetimeScope Methods Activate(Type) Creates rule's instances from a CLR type. public IEnumerable<Rule> Activate(Type type) Parameters type Type Rule CLR type. Returns IEnumerable<Rule> Rule instances. Remarks The same rule type may be instantiated multiple times with different parameters. Each instance is considered as separate rule, and should have a unique name."
  },
  "api/NRules.Integration.Autofac.RegistrationExtensions.html": {
    "href": "api/NRules.Integration.Autofac.RegistrationExtensions.html",
    "title": "Class RegistrationExtensions | NRules",
    "keywords": "Class RegistrationExtensions Namespace NRules.Integration.Autofac Assembly NRules.Integration.Autofac.dll public static class RegistrationExtensions Inheritance object RegistrationExtensions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods RegisterRuleRepository(ContainerBuilder, Action<IRuleTypeScanner>) Registers fluent rule types with the container, registers RuleRepository with the container and loads registered rules into the repository. By default repository is registered as a single instance and is wired with a IRuleActivator. public static IRegistrationBuilder<RuleRepository, ConcreteReflectionActivatorData, SingleRegistrationStyle> RegisterRuleRepository(this ContainerBuilder builder, Action<IRuleTypeScanner> scanAction) Parameters builder ContainerBuilder Container builder. scanAction Action<IRuleTypeScanner> Configuration action on the rule type scanner. Returns IRegistrationBuilder<RuleRepository, ConcreteReflectionActivatorData, SingleRegistrationStyle> Registration builder for RuleRepository to specify additional registration configuration. RegisterSession(ContainerBuilder) Registers ISession with the container. By default session is registered as an instance per lifetime scope. public static IRegistrationBuilder<ISession, SimpleActivatorData, SingleRegistrationStyle> RegisterSession(this ContainerBuilder builder) Parameters builder ContainerBuilder Container builder. Returns IRegistrationBuilder<ISession, SimpleActivatorData, SingleRegistrationStyle> Registration builder for ISession to specify additional registration configuration. RegisterSession(ContainerBuilder, Func<IComponentContext, ISession>) Registers ISession with the container. By default session is registered as an instance per lifetime scope. public static IRegistrationBuilder<ISession, SimpleActivatorData, SingleRegistrationStyle> RegisterSession(this ContainerBuilder builder, Func<IComponentContext, ISession> factoryFunc) Parameters builder ContainerBuilder Container builder. factoryFunc Func<IComponentContext, ISession> Factory function that creates an instance of ISession. Returns IRegistrationBuilder<ISession, SimpleActivatorData, SingleRegistrationStyle> Registration builder for ISession to specify additional registration configuration. RegisterSessionFactory(ContainerBuilder) Registers ISessionFactory with the container. Requires that IRuleRepository is registered with the container. By default session factory is registered as a single instance and is wired with a IDependencyResolver. public static IRegistrationBuilder<ISessionFactory, SimpleActivatorData, SingleRegistrationStyle> RegisterSessionFactory(this ContainerBuilder builder) Parameters builder ContainerBuilder Container builder. Returns IRegistrationBuilder<ISessionFactory, SimpleActivatorData, SingleRegistrationStyle> Registration builder for ISessionFactory to specify additional registration configuration. RegisterSessionFactory(ContainerBuilder, Func<IComponentContext, ISessionFactory>) Registers ISessionFactory with the container. By default session factory is registered as a single instance and is wired with a IDependencyResolver. public static IRegistrationBuilder<ISessionFactory, SimpleActivatorData, SingleRegistrationStyle> RegisterSessionFactory(this ContainerBuilder builder, Func<IComponentContext, ISessionFactory> compileFunc) Parameters builder ContainerBuilder Container builder. compileFunc Func<IComponentContext, ISessionFactory> Compile function that creates an instance of ISessionFactory. Returns IRegistrationBuilder<ISessionFactory, SimpleActivatorData, SingleRegistrationStyle> Registration builder for ISessionFactory to specify additional registration configuration."
  },
  "api/NRules.Integration.Autofac.html": {
    "href": "api/NRules.Integration.Autofac.html",
    "title": "Namespace NRules.Integration.Autofac | NRules",
    "keywords": "Namespace NRules.Integration.Autofac Contains types that implement integration with the Autofac IoC container. Classes AutofacDependencyResolver Dependency resolver that uses Autofac DI container. AutofacRuleActivator Rule activator that uses Autofac DI container. RegistrationExtensions"
  },
  "api/NRules.Json.ITypeResolver.html": {
    "href": "api/NRules.Json.ITypeResolver.html",
    "title": "Interface ITypeResolver | NRules",
    "keywords": "Interface ITypeResolver Namespace NRules.Json Assembly NRules.Json.dll Defines the methods that enable conversion of CLR types to type names and type names to CLR types for the purpose of JSON serialization. public interface ITypeResolver Methods GetTypeFromName(string) Gets the CLR type that corresponds to the type name, retrieved from the JSON document. Type GetTypeFromName(string typeName) Parameters typeName string String representation of the CLR type. Returns Type CLR type that corresponds to the string representation. GetTypeName(Type) Gets the name of the type from the CLR type, for the purpose of JSON serialization. string GetTypeName(Type type) Parameters type Type CLR type. Returns string String representation of the CLR type."
  },
  "api/NRules.Json.RuleSerializer.html": {
    "href": "api/NRules.Json.RuleSerializer.html",
    "title": "Class RuleSerializer | NRules",
    "keywords": "Class RuleSerializer Namespace NRules.Json Assembly NRules.Json.dll Provides functionality to serialize rules to JSON and deserialize JSON into rules. public static class RuleSerializer Inheritance object RuleSerializer Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods GetConverters() Creates custom JSON converters that can be used with JsonSerializerOptions and JsonSerializer to serialize IRuleDefinition objects to JSON and deserialize JSON into IRuleDefinition objects. public static IReadOnlyCollection<JsonConverter> GetConverters() Returns IReadOnlyCollection<JsonConverter> Collection of JSON converters necessary for rules serialization. GetConverters(ITypeResolver) Creates custom JSON converters that can be used with JsonSerializerOptions and JsonSerializer to serialize IRuleDefinition objects to JSON and deserialize JSON into IRuleDefinition objects. public static IReadOnlyCollection<JsonConverter> GetConverters(ITypeResolver typeResolver) Parameters typeResolver ITypeResolver Type resolver that converts CLR types to type names and type names to CLR types. Returns IReadOnlyCollection<JsonConverter> Collection of JSON converters necessary for rules serialization. Setup(JsonSerializerOptions) Configures JsonSerializerOptions, so that it can be used with the JsonSerializer to serialize IRuleDefinition objects to JSON and deserialize JSON into IRuleDefinition objects. public static void Setup(JsonSerializerOptions options) Parameters options JsonSerializerOptions JsonSerializerOptions to configure for rules serialization. Setup(JsonSerializerOptions, ITypeResolver) Configures JsonSerializerOptions, so that it can be used with the JsonSerializer to serialize IRuleDefinition objects to JSON and deserialize JSON into IRuleDefinition objects. public static void Setup(JsonSerializerOptions options, ITypeResolver typeResolver) Parameters options JsonSerializerOptions JsonSerializerOptions to configure for rules serialization. typeResolver ITypeResolver Type resolver that converts CLR types to type names and type names to CLR types."
  },
  "api/NRules.Json.TypeResolver.html": {
    "href": "api/NRules.Json.TypeResolver.html",
    "title": "Class TypeResolver | NRules",
    "keywords": "Class TypeResolver Namespace NRules.Json Assembly NRules.Json.dll Default ITypeResolver that uses assembly-qualified type names and supports type aliases. public class TypeResolver : ITypeResolver Inheritance object TypeResolver Implements ITypeResolver Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods GetTypeFromName(string) Gets the CLR type that corresponds to the type name, retrieved from the JSON document. public Type GetTypeFromName(string typeName) Parameters typeName string Returns Type GetTypeName(Type) Gets the name of the type from the CLR type, for the purpose of JSON serialization. public string GetTypeName(Type type) Parameters type Type Returns string RegisterAlias(string, Type) Registers an alias for a CLR type for the purpose of JSON serialization. public void RegisterAlias(string alias, Type type) Parameters alias string String representation of the CLR type. type Type CLR type. RegisterDefaultAliases() Registers built-in C# types as aliases for rule serialization. public void RegisterDefaultAliases()"
  },
  "api/NRules.Json.html": {
    "href": "api/NRules.Json.html",
    "title": "Namespace NRules.Json | NRules",
    "keywords": "Namespace NRules.Json Contains types that implement serialization of rule definitions to/from JSON. Classes RuleSerializer Provides functionality to serialize rules to JSON and deserialize JSON into rules. TypeResolver Default ITypeResolver that uses assembly-qualified type names and supports type aliases. Interfaces ITypeResolver Defines the methods that enable conversion of CLR types to type names and type names to CLR types for the purpose of JSON serialization."
  },
  "api/NRules.LinkedFactAction.html": {
    "href": "api/NRules.LinkedFactAction.html",
    "title": "Enum LinkedFactAction | NRules",
    "keywords": "Enum LinkedFactAction Namespace NRules Assembly NRules.dll Action taken on the linked fact. public enum LinkedFactAction Fields Insert = 0 Linked fact is inserted into the session. Update = 1 Linked fact is updated in the session. Retract = 2 Linked fact is retracted from the session."
  },
  "api/NRules.RuleCompilationException.html": {
    "href": "api/NRules.RuleCompilationException.html",
    "title": "Class RuleCompilationException | NRules",
    "keywords": "Class RuleCompilationException Namespace NRules Assembly NRules.dll Represents errors that occur while compiling a rule. [Serializable] public class RuleCompilationException : Exception, ISerializable Inheritance object Exception RuleCompilationException Implements ISerializable Inherited Members Exception.GetBaseException() Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState object.Equals(object) object.Equals(object, object) object.GetHashCode() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors RuleCompilationException(SerializationInfo, StreamingContext) protected RuleCompilationException(SerializationInfo info, StreamingContext context) Parameters info SerializationInfo context StreamingContext Properties Message Gets a message that describes the current exception. public override string Message { get; } Property Value string The error message that explains the reason for the exception, or an empty string (\"\"). RuleName Rule that caused exception. public string RuleName { get; } Property Value string Methods GetObjectData(SerializationInfo, StreamingContext) When overridden in a derived class, sets the SerializationInfo with information about the exception. [SecurityCritical] public override void GetObjectData(SerializationInfo info, StreamingContext context) Parameters info SerializationInfo The SerializationInfo that holds the serialized object data about the exception being thrown. context StreamingContext The StreamingContext that contains contextual information about the source or destination. Exceptions ArgumentNullException The info parameter is a null reference (Nothing in Visual Basic)."
  },
  "api/NRules.RuleCompiler.html": {
    "href": "api/NRules.RuleCompiler.html",
    "title": "Class RuleCompiler | NRules",
    "keywords": "Class RuleCompiler Namespace NRules Assembly NRules.dll Compiles rules in a canonical rule model form into an executable representation. public class RuleCompiler Inheritance object RuleCompiler Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors RuleCompiler() Initializes a new instance of the RuleCompiler class using the default RuleCompilerOptions. public RuleCompiler() RuleCompiler(RuleCompilerOptions) Initializes a new instance of the RuleCompiler class using the specified RuleCompilerOptions. public RuleCompiler(RuleCompilerOptions options) Parameters options RuleCompilerOptions Properties AggregatorRegistry Registry of custom aggregator factories. public AggregatorRegistry AggregatorRegistry { get; } Property Value AggregatorRegistry ExpressionCompiler Compiles expressions used in rules conditions and actions into executable delegates. Default implementation uses the built-in .NET expression compiler. public IExpressionCompiler ExpressionCompiler { get; set; } Property Value IExpressionCompiler Methods Compile(IEnumerable<IRuleDefinition>) Compiles a collection of rules into a session factory. public ISessionFactory Compile(IEnumerable<IRuleDefinition> ruleDefinitions) Parameters ruleDefinitions IEnumerable<IRuleDefinition> Rules to compile. Returns ISessionFactory Session factory. Exceptions RuleCompilationException Any fatal error during rules compilation. See Also IRuleRepository Compile(IEnumerable<IRuleDefinition>, CancellationToken) Compiles a collection of rules into a session factory. public ISessionFactory Compile(IEnumerable<IRuleDefinition> ruleDefinitions, CancellationToken cancellationToken) Parameters ruleDefinitions IEnumerable<IRuleDefinition> Rules to compile. cancellationToken CancellationToken Enables cooperative cancellation of the rules compilation. Returns ISessionFactory Session factory. Exceptions RuleCompilationException Any fatal error during rules compilation. See Also IRuleRepository Compile(IEnumerable<IRuleSet>) Compiles rules from rule sets into a session factory. public ISessionFactory Compile(IEnumerable<IRuleSet> ruleSets) Parameters ruleSets IEnumerable<IRuleSet> Rule sets to compile. Returns ISessionFactory Session factory. Exceptions RuleCompilationException Any fatal error during rules compilation. Compile(IEnumerable<IRuleSet>, CancellationToken) Compiles rules from rule sets into a session factory. public ISessionFactory Compile(IEnumerable<IRuleSet> ruleSets, CancellationToken cancellationToken) Parameters ruleSets IEnumerable<IRuleSet> Rule sets to compile. cancellationToken CancellationToken Enables cooperative cancellation of the rules compilation. Returns ISessionFactory Session factory. Exceptions RuleCompilationException Any fatal error during rules compilation."
  },
  "api/NRules.RuleCompilerOptions.html": {
    "href": "api/NRules.RuleCompilerOptions.html",
    "title": "Class RuleCompilerOptions | NRules",
    "keywords": "Class RuleCompilerOptions Namespace NRules Assembly NRules.dll Provides options to alter default behavior of RuleCompiler. public class RuleCompilerOptions Inheritance object RuleCompilerOptions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties UnsupportedExpressionHandling Determines compiler behavior when it finds an unsupported type of lambda expressions while comparing them for the purpose of node sharing in the Rete graph. public RuleCompilerUnsupportedExpressionsHandling UnsupportedExpressionHandling { get; set; } Property Value RuleCompilerUnsupportedExpressionsHandling"
  },
  "api/NRules.RuleCompilerUnsupportedExpressionsHandling.html": {
    "href": "api/NRules.RuleCompilerUnsupportedExpressionsHandling.html",
    "title": "Enum RuleCompilerUnsupportedExpressionsHandling | NRules",
    "keywords": "Enum RuleCompilerUnsupportedExpressionsHandling Namespace NRules Assembly NRules.dll Defines different modes of handling of unsupported types of lambda expressions when the compiler is comparing them for the purpose of node sharing in the Rete graph. public enum RuleCompilerUnsupportedExpressionsHandling Fields FailFast = 0 Rule compilation fails when it finds an unsupported expression. This is the default behavior. TreatAsNotEqual = 1 Rule compilation treats unsupported expressions as not equal, sacrificing efficiency in favor of compatibility."
  },
  "api/NRules.RuleExecutionException.html": {
    "href": "api/NRules.RuleExecutionException.html",
    "title": "Class RuleExecutionException | NRules",
    "keywords": "Class RuleExecutionException Namespace NRules Assembly NRules.dll Represents errors that occur during rules execution. [Serializable] public class RuleExecutionException : Exception, ISerializable Inheritance object Exception RuleExecutionException Implements ISerializable Derived RuleExpressionEvaluationException Inherited Members Exception.GetBaseException() Exception.GetObjectData(SerializationInfo, StreamingContext) Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState object.Equals(object) object.Equals(object, object) object.GetHashCode() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors RuleExecutionException(SerializationInfo, StreamingContext) protected RuleExecutionException(SerializationInfo info, StreamingContext context) Parameters info SerializationInfo context StreamingContext"
  },
  "api/NRules.RuleExpressionEvaluationException.html": {
    "href": "api/NRules.RuleExpressionEvaluationException.html",
    "title": "Class RuleExpressionEvaluationException | NRules",
    "keywords": "Class RuleExpressionEvaluationException Namespace NRules Assembly NRules.dll Represents errors that occur while evaluating expressions as part of rules execution. [Serializable] public abstract class RuleExpressionEvaluationException : RuleExecutionException, ISerializable Inheritance object Exception RuleExecutionException RuleExpressionEvaluationException Implements ISerializable Derived AgendaExpressionEvaluationException RuleLhsExpressionEvaluationException RuleRhsExpressionEvaluationException Inherited Members Exception.GetBaseException() Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState object.Equals(object) object.Equals(object, object) object.GetHashCode() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors RuleExpressionEvaluationException(SerializationInfo, StreamingContext) protected RuleExpressionEvaluationException(SerializationInfo info, StreamingContext context) Parameters info SerializationInfo context StreamingContext Properties Expression Expression that caused exception. public string Expression { get; } Property Value string Message Gets a message that describes the current exception. public override string Message { get; } Property Value string The error message that explains the reason for the exception, or an empty string (\"\"). Methods GetObjectData(SerializationInfo, StreamingContext) When overridden in a derived class, sets the SerializationInfo with information about the exception. [SecurityCritical] public override void GetObjectData(SerializationInfo info, StreamingContext context) Parameters info SerializationInfo The SerializationInfo that holds the serialized object data about the exception being thrown. context StreamingContext The StreamingContext that contains contextual information about the source or destination. Exceptions ArgumentNullException The info parameter is a null reference (Nothing in Visual Basic)."
  },
  "api/NRules.RuleLhsExpressionEvaluationException.html": {
    "href": "api/NRules.RuleLhsExpressionEvaluationException.html",
    "title": "Class RuleLhsExpressionEvaluationException | NRules",
    "keywords": "Class RuleLhsExpressionEvaluationException Namespace NRules Assembly NRules.dll Represents errors that occur while evaluating rule left-hand side expression. [Serializable] public class RuleLhsExpressionEvaluationException : RuleExpressionEvaluationException, ISerializable Inheritance object Exception RuleExecutionException RuleExpressionEvaluationException RuleLhsExpressionEvaluationException Implements ISerializable Inherited Members RuleExpressionEvaluationException.GetObjectData(SerializationInfo, StreamingContext) RuleExpressionEvaluationException.Expression RuleExpressionEvaluationException.Message Exception.GetBaseException() Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState object.Equals(object) object.Equals(object, object) object.GetHashCode() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors RuleLhsExpressionEvaluationException(SerializationInfo, StreamingContext) protected RuleLhsExpressionEvaluationException(SerializationInfo info, StreamingContext context) Parameters info SerializationInfo context StreamingContext"
  },
  "api/NRules.RuleModel.ActionElement.html": {
    "href": "api/NRules.RuleModel.ActionElement.html",
    "title": "Class ActionElement | NRules",
    "keywords": "Class ActionElement Namespace NRules.RuleModel Assembly NRules.RuleModel.dll Action executed by the engine when the rule fires. public class ActionElement : ExpressionElement Inheritance object RuleElement ExpressionElement ActionElement Inherited Members ExpressionElement.Expression RuleElement.Exports RuleElement.Imports object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Extension Methods RuleElementExtensions.Match(RuleElement, Action<PatternElement>, Action<AggregateElement>, Action<GroupElement>, Action<ExistsElement>, Action<NotElement>, Action<ForAllElement>) Fields DefaultTrigger Default value for action trigger. public const ActionTrigger DefaultTrigger = Activated | Reactivated Field Value ActionTrigger Properties ActionTrigger Activation events that trigger this action. public ActionTrigger ActionTrigger { get; } Property Value ActionTrigger ElementType Element type of this rule element. public override ElementType ElementType { get; } Property Value ElementType"
  },
  "api/NRules.RuleModel.ActionGroupElement.html": {
    "href": "api/NRules.RuleModel.ActionGroupElement.html",
    "title": "Class ActionGroupElement | NRules",
    "keywords": "Class ActionGroupElement Namespace NRules.RuleModel Assembly NRules.RuleModel.dll Rule element that groups actions that run when the rule fires. public class ActionGroupElement : RuleElement Inheritance object RuleElement ActionGroupElement Inherited Members RuleElement.Exports RuleElement.Imports object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Extension Methods RuleElementExtensions.Match(RuleElement, Action<PatternElement>, Action<AggregateElement>, Action<GroupElement>, Action<ExistsElement>, Action<NotElement>, Action<ForAllElement>) Properties Actions List of actions the group element contains. public IEnumerable<ActionElement> Actions { get; } Property Value IEnumerable<ActionElement> ElementType Element type of this rule element. public override ElementType ElementType { get; } Property Value ElementType"
  },
  "api/NRules.RuleModel.ActionTrigger.html": {
    "href": "api/NRules.RuleModel.ActionTrigger.html",
    "title": "Enum ActionTrigger | NRules",
    "keywords": "Enum ActionTrigger Namespace NRules.RuleModel Assembly NRules.RuleModel.dll Activation events that trigger the actions. [Flags] public enum ActionTrigger Fields None = 0 Action is not triggered. Activated = 1 Action is triggered when activation is created. Reactivated = 2 Action is triggered when activation is updated. Deactivated = 4 Action is triggered when activation is removed."
  },
  "api/NRules.RuleModel.AggregateElement.html": {
    "href": "api/NRules.RuleModel.AggregateElement.html",
    "title": "Class AggregateElement | NRules",
    "keywords": "Class AggregateElement Namespace NRules.RuleModel Assembly NRules.RuleModel.dll Rule element that creates new facts (aggregates) based on matching facts it receives as input. public class AggregateElement : RuleElement Inheritance object RuleElement AggregateElement Inherited Members RuleElement.Exports RuleElement.Imports object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Extension Methods RuleElementExtensions.Match(RuleElement, Action<PatternElement>, Action<AggregateElement>, Action<GroupElement>, Action<ExistsElement>, Action<NotElement>, Action<ForAllElement>) Fields CollectName public const string CollectName = \"Collect\" Field Value string ElementSelectorName public const string ElementSelectorName = \"ElementSelector\" Field Value string FlattenName public const string FlattenName = \"Flatten\" Field Value string GroupByName public const string GroupByName = \"GroupBy\" Field Value string KeySelectorAscendingName public const string KeySelectorAscendingName = \"KeySelectorAscending\" Field Value string KeySelectorDescendingName public const string KeySelectorDescendingName = \"KeySelectorDescending\" Field Value string KeySelectorName public const string KeySelectorName = \"KeySelector\" Field Value string ProjectName public const string ProjectName = \"Project\" Field Value string SelectorName public const string SelectorName = \"Selector\" Field Value string Properties CustomFactoryType The type of custom aggregator factory. public Type CustomFactoryType { get; } Property Value Type ElementType Element type of this rule element. public override ElementType ElementType { get; } Property Value ElementType Expressions Expressions used by the aggregate. public ExpressionCollection Expressions { get; } Property Value ExpressionCollection Name Aggregate name. public string Name { get; } Property Value string ResultType Type of the result that this rule element yields. public Type ResultType { get; } Property Value Type Source Fact source of the aggregate. public PatternElement Source { get; } Property Value PatternElement"
  },
  "api/NRules.RuleModel.AndElement.html": {
    "href": "api/NRules.RuleModel.AndElement.html",
    "title": "Class AndElement | NRules",
    "keywords": "Class AndElement Namespace NRules.RuleModel Assembly NRules.RuleModel.dll Grouping element based on the logical AND condition. public class AndElement : GroupElement Inheritance object RuleElement GroupElement AndElement Inherited Members GroupElement.ChildElements RuleElement.Exports RuleElement.Imports object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Extension Methods RuleElementExtensions.Match(GroupElement, Action<AndElement>, Action<OrElement>) RuleElementExtensions.Match(RuleElement, Action<PatternElement>, Action<AggregateElement>, Action<GroupElement>, Action<ExistsElement>, Action<NotElement>, Action<ForAllElement>) Properties ElementType Element type of this rule element. public override ElementType ElementType { get; } Property Value ElementType"
  },
  "api/NRules.RuleModel.BindingElement.html": {
    "href": "api/NRules.RuleModel.BindingElement.html",
    "title": "Class BindingElement | NRules",
    "keywords": "Class BindingElement Namespace NRules.RuleModel Assembly NRules.RuleModel.dll Rule element that represents results of an expression. public class BindingElement : ExpressionElement Inheritance object RuleElement ExpressionElement BindingElement Inherited Members ExpressionElement.Expression RuleElement.Exports RuleElement.Imports object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Extension Methods RuleElementExtensions.Match(RuleElement, Action<PatternElement>, Action<AggregateElement>, Action<GroupElement>, Action<ExistsElement>, Action<NotElement>, Action<ForAllElement>) Properties ElementType Element type of this rule element. public override ElementType ElementType { get; } Property Value ElementType ResultType Type of the result that this rule element yields. public Type ResultType { get; } Property Value Type"
  },
  "api/NRules.RuleModel.Builders.ActionGroupBuilder.html": {
    "href": "api/NRules.RuleModel.Builders.ActionGroupBuilder.html",
    "title": "Class ActionGroupBuilder | NRules",
    "keywords": "Class ActionGroupBuilder Namespace NRules.RuleModel.Builders Assembly NRules.RuleModel.dll Builder to compose a group of rule actions. public class ActionGroupBuilder : RuleElementBuilder Inheritance object RuleElementBuilder ActionGroupBuilder Inherited Members RuleElementBuilder.DeclarationName(string) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors ActionGroupBuilder() Initializes a new instance of the ActionGroupBuilder. public ActionGroupBuilder() Methods Action(LambdaExpression) Adds a rule action to the group element. The action will be executed on new and updated rule activations. public void Action(LambdaExpression expression) Parameters expression LambdaExpression Rule action expression. The first parameter of the action expression must be IContext. Names and types of the rest of the expression parameters must match the names and types defined in the pattern declarations. Action(LambdaExpression, ActionTrigger) Adds a rule action to the group element. public void Action(LambdaExpression expression, ActionTrigger actionTrigger) Parameters expression LambdaExpression Rule action expression. The first parameter of the action expression must be IContext. Names and types of the rest of the expression parameters must match the names and types defined in the pattern declarations. actionTrigger ActionTrigger Activation events that trigger the action."
  },
  "api/NRules.RuleModel.Builders.AggregateBuilder.html": {
    "href": "api/NRules.RuleModel.Builders.AggregateBuilder.html",
    "title": "Class AggregateBuilder | NRules",
    "keywords": "Class AggregateBuilder Namespace NRules.RuleModel.Builders Assembly NRules.RuleModel.dll Builder to compose an aggregate element. public class AggregateBuilder : RuleElementBuilder Inheritance object RuleElementBuilder AggregateBuilder Inherited Members RuleElementBuilder.DeclarationName(string) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors AggregateBuilder() Initializes a new instance of the AggregateBuilder. public AggregateBuilder() Methods Aggregator(string, IEnumerable<KeyValuePair<string, LambdaExpression>>, Type) Configure a custom aggregator. public void Aggregator(string name, IEnumerable<KeyValuePair<string, LambdaExpression>> expressions, Type customFactoryType = null) Parameters name string Name of the aggregator. expressions IEnumerable<KeyValuePair<string, LambdaExpression>> Named expressions used by the aggregator. customFactoryType Type The type of the custom aggregate factory Collect() Configure a collection aggregator. public void Collect() Flatten(LambdaExpression) Configure flattening aggregator. public void Flatten(LambdaExpression selector) Parameters selector LambdaExpression Projection expression. GroupBy(LambdaExpression, LambdaExpression) Configure group by aggregator. public void GroupBy(LambdaExpression keySelector, LambdaExpression elementSelector) Parameters keySelector LambdaExpression Grouping key selection expressions. elementSelector LambdaExpression Element selection expression. OrderBy(LambdaExpression, SortDirection) Configure Collect() aggregator to order facts by key. public void OrderBy(LambdaExpression keySelector, SortDirection sortDirection) Parameters keySelector LambdaExpression Key selection expression. sortDirection SortDirection Order to sort the aggregation in. Pattern(PatternBuilder) Sets a pattern builder as the source of the aggregate element. public void Pattern(PatternBuilder builder) Parameters builder PatternBuilder Element builder to set as the source. Pattern(Declaration) Creates a pattern builder that builds the source of the aggregate element. public PatternBuilder Pattern(Declaration declaration) Parameters declaration Declaration Pattern declaration. Returns PatternBuilder Pattern builder. Pattern(PatternElement) Creates a pattern builder that builds the source of the aggregate. Sets a pattern element as the source of the aggregate element. public void Pattern(PatternElement element) Parameters element PatternElement Element to set as the source. Pattern(Type, string) Creates a pattern builder that builds the source of the aggregate element. public PatternBuilder Pattern(Type type, string name = null) Parameters type Type Type of the element the pattern matches. name string Pattern name (optional). Returns PatternBuilder Pattern builder. Project(LambdaExpression) Configure projection aggregator. public void Project(LambdaExpression selector) Parameters selector LambdaExpression Projection expression. ResultType(Type) Sets type of the result produced by the aggregation. public void ResultType(Type resultType) Parameters resultType Type Type of the result. ToLookup(LambdaExpression, LambdaExpression) Configure Collect() aggregator to arrange facts into a lookup, grouped by key. public void ToLookup(LambdaExpression keySelector, LambdaExpression elementSelector) Parameters keySelector LambdaExpression Grouping key selection expressions. elementSelector LambdaExpression Element selection expression."
  },
  "api/NRules.RuleModel.Builders.BindingBuilder.html": {
    "href": "api/NRules.RuleModel.Builders.BindingBuilder.html",
    "title": "Class BindingBuilder | NRules",
    "keywords": "Class BindingBuilder Namespace NRules.RuleModel.Builders Assembly NRules.RuleModel.dll Builder to compose a binding expression element. public class BindingBuilder : RuleElementBuilder Inheritance object RuleElementBuilder BindingBuilder Inherited Members RuleElementBuilder.DeclarationName(string) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors BindingBuilder() Initializes a new instance of the BindingBuilder. public BindingBuilder() Methods BindingExpression(LambdaExpression) Sets a calculated expression on the binding element. public void BindingExpression(LambdaExpression expression) Parameters expression LambdaExpression Expression to bind. ResultType(Type) Sets type of the result produced by the binding expression. If not provided, this is set to the return type of the binding expression. public void ResultType(Type resultType) Parameters resultType Type Type of the result."
  },
  "api/NRules.RuleModel.Builders.DependencyGroupBuilder.html": {
    "href": "api/NRules.RuleModel.Builders.DependencyGroupBuilder.html",
    "title": "Class DependencyGroupBuilder | NRules",
    "keywords": "Class DependencyGroupBuilder Namespace NRules.RuleModel.Builders Assembly NRules.RuleModel.dll Builder to compose a group of rule dependencies. public class DependencyGroupBuilder : RuleElementBuilder Inheritance object RuleElementBuilder DependencyGroupBuilder Inherited Members RuleElementBuilder.DeclarationName(string) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors DependencyGroupBuilder() Initializes a new instance of the DependencyGroupBuilder. public DependencyGroupBuilder() Methods Dependency(DependencyElement) Adds a dependency element to the group element. public void Dependency(DependencyElement element) Parameters element DependencyElement Element to add. Dependency(Type, string) Adds a dependency to the group element. public Declaration Dependency(Type type, string name) Parameters type Type Dependency CLR type. name string Dependency name. Returns Declaration Dependency declaration."
  },
  "api/NRules.RuleModel.Builders.Element.html": {
    "href": "api/NRules.RuleModel.Builders.Element.html",
    "title": "Class Element | NRules",
    "keywords": "Class Element Namespace NRules.RuleModel.Builders Assembly NRules.RuleModel.dll Factory class for rule elements. public static class Element Inheritance object Element Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods Action(LambdaExpression) Creates an action element that represents an action taken by the engine when the rule fires. The action element is created with the default trigger, which executes the action when rule is Activated or Reactivated. public static ActionElement Action(LambdaExpression expression) Parameters expression LambdaExpression Action expression. It must have IContext as it's first parameter. Returns ActionElement Created element. Action(LambdaExpression, ActionTrigger) Creates an action element that represents an action taken by the engine when the rule fires. public static ActionElement Action(LambdaExpression expression, ActionTrigger actionTrigger) Parameters expression LambdaExpression Action expression. It must have IContext as it's first parameter. actionTrigger ActionTrigger Action trigger that indicates when the action should execute. Returns ActionElement Created element. ActionGroup(params ActionElement[]) Creates an action group element. public static ActionGroupElement ActionGroup(params ActionElement[] actions) Parameters actions ActionElement[] Action elements in the group. Returns ActionGroupElement Created element. See Also ActionElement ActionGroup(IEnumerable<ActionElement>) Creates an action group element. public static ActionGroupElement ActionGroup(IEnumerable<ActionElement> actions) Parameters actions IEnumerable<ActionElement> Action elements in the group. Returns ActionGroupElement Created element. See Also ActionElement Aggregate(Type, string, IEnumerable<NamedExpressionElement>, PatternElement) Creates an element that represents an aggregation of facts. public static AggregateElement Aggregate(Type resultType, string name, IEnumerable<NamedExpressionElement> expressions, PatternElement source) Parameters resultType Type Type of the aggregate result. name string Aggregate name. expressions IEnumerable<NamedExpressionElement> Expressions used to construct aggregates from individual facts. source PatternElement Pattern that matches facts for aggregation. Returns AggregateElement Created element. Aggregate(Type, string, IEnumerable<NamedExpressionElement>, PatternElement, Type) Creates an element that represents an aggregation of facts. public static AggregateElement Aggregate(Type resultType, string name, IEnumerable<NamedExpressionElement> expressions, PatternElement source, Type customFactoryType) Parameters resultType Type Type of the aggregate result. name string Aggregate name. expressions IEnumerable<NamedExpressionElement> Expressions used to construct aggregates from individual facts. source PatternElement Pattern that matches facts for aggregation. customFactoryType Type Factory type used construct aggregators for this aggregation. Returns AggregateElement Created element. Aggregate(Type, string, IEnumerable<KeyValuePair<string, LambdaExpression>>, PatternElement) Creates an element that represents an aggregation of facts. public static AggregateElement Aggregate(Type resultType, string name, IEnumerable<KeyValuePair<string, LambdaExpression>> expressions, PatternElement source) Parameters resultType Type Type of the aggregate result. name string Aggregate name. expressions IEnumerable<KeyValuePair<string, LambdaExpression>> Expressions used to construct aggregates from individual facts. source PatternElement Pattern that matches facts for aggregation. Returns AggregateElement Created element. Aggregate(Type, string, IEnumerable<KeyValuePair<string, LambdaExpression>>, PatternElement, Type) Creates an element that represents an aggregation of facts. public static AggregateElement Aggregate(Type resultType, string name, IEnumerable<KeyValuePair<string, LambdaExpression>> expressions, PatternElement source, Type customFactoryType) Parameters resultType Type Type of the aggregate result. name string Aggregate name. expressions IEnumerable<KeyValuePair<string, LambdaExpression>> Expressions used to construct aggregates from individual facts. source PatternElement Pattern that matches facts for aggregation. customFactoryType Type Factory type used construct aggregators for this aggregation. Returns AggregateElement Created element. AndGroup(params RuleElement[]) Creates a left-hand side group element that combines contained elements using an AND operator. public static AndElement AndGroup(params RuleElement[] childElements) Parameters childElements RuleElement[] Child elements contained in the group. Returns AndElement Created element. AndGroup(IEnumerable<RuleElement>) Creates a left-hand side group element that combines contained elements using an AND operator. public static AndElement AndGroup(IEnumerable<RuleElement> childElements) Parameters childElements IEnumerable<RuleElement> Child elements contained in the group. Returns AndElement Created element. Binding(LambdaExpression) Creates an element that represents results of an expression evaluation. public static BindingElement Binding(LambdaExpression expression) Parameters expression LambdaExpression Binding expression. Returns BindingElement Created element. Binding(Type, LambdaExpression) Creates an element that represents results of an expression evaluation. public static BindingElement Binding(Type resultType, LambdaExpression expression) Parameters resultType Type Type of the expression result. expression LambdaExpression Binding expression. Returns BindingElement Created element. Collect(PatternElement) Creates an element that aggregates matching facts into a collection. public static AggregateElement Collect(PatternElement source) Parameters source PatternElement Pattern that matches facts for aggregation. Returns AggregateElement Created element. Collect(Type, PatternElement) Creates an element that aggregates matching facts into a collection. public static AggregateElement Collect(Type resultType, PatternElement source) Parameters resultType Type Type of the aggregate result. source PatternElement Pattern that matches facts for aggregation. Returns AggregateElement Created element. Condition(LambdaExpression) Creates a condition element that represents a condition applied to elements matched by a pattern. public static NamedExpressionElement Condition(LambdaExpression expression) Parameters expression LambdaExpression Condition expression. It must have Boolean as its return type. Returns NamedExpressionElement Created element. Declaration(Type, string) Creates a declaration with a given name and type to be used in other rule elements. public static Declaration Declaration(Type type, string name) Parameters type Type Declaration type. name string Declaration name. Returns Declaration Created declaration. Dependency(Declaration, Type) Creates a dependency element. public static DependencyElement Dependency(Declaration declaration, Type serviceType) Parameters declaration Declaration Declaration that references the dependency. serviceType Type Type of the service that the dependency represents. Returns DependencyElement Created element. Dependency(Type, string) Creates a dependency element. public static DependencyElement Dependency(Type type, string name) Parameters type Type Dependency type. name string Dependency name. Returns DependencyElement Created element. DependencyGroup(params DependencyElement[]) Creates a dependency group element. public static DependencyGroupElement DependencyGroup(params DependencyElement[] dependencies) Parameters dependencies DependencyElement[] Dependency elements in the group. Returns DependencyGroupElement Created element. See Also DependencyElement DependencyGroup(IEnumerable<DependencyElement>) Creates a dependency group element. public static DependencyGroupElement DependencyGroup(IEnumerable<DependencyElement> dependencies) Parameters dependencies IEnumerable<DependencyElement> Dependency elements in the group. Returns DependencyGroupElement Created element. See Also DependencyElement Exists(RuleElement) Creates an element that represents an existential quantifier. public static ExistsElement Exists(RuleElement source) Parameters source RuleElement Source element to apply the existential quantifier to. Returns ExistsElement Created element. Expression(string, LambdaExpression) Creates a named expression element that can be used by other rule elements. public static NamedExpressionElement Expression(string name, LambdaExpression expression) Parameters name string Name of the expression. expression LambdaExpression The actual expression that this element represents. Returns NamedExpressionElement Created element. Filter(FilterType, LambdaExpression) Creates an agenda filter element. public static FilterElement Filter(FilterType filterType, LambdaExpression expression) Parameters filterType FilterType Type of agenda filter. expression LambdaExpression Filter expression. Returns FilterElement Created element. FilterGroup(params FilterElement[]) Creates an agenda filter group element. public static FilterGroupElement FilterGroup(params FilterElement[] filters) Parameters filters FilterElement[] Agenda filter elements in the group. Returns FilterGroupElement Created element. See Also FilterElement FilterGroup(IEnumerable<FilterElement>) Creates an agenda filter group element. public static FilterGroupElement FilterGroup(IEnumerable<FilterElement> filters) Parameters filters IEnumerable<FilterElement> Agenda filter elements in the group. Returns FilterGroupElement Created element. See Also FilterElement Flatten(Type, LambdaExpression, PatternElement) Creates an element that flattens collections of elements from matching facts into a single set of facts. public static AggregateElement Flatten(Type resultType, LambdaExpression selector, PatternElement source) Parameters resultType Type Type of the aggregate result. selector LambdaExpression Expression that selects a collection of elements from a matching fact. source PatternElement Pattern that matches facts for aggregation. Returns AggregateElement Created element. ForAll(PatternElement, IEnumerable<PatternElement>) Creates an element that represents a universal quantifier. Facts that match the basePattern must also match all other patterns. public static ForAllElement ForAll(PatternElement basePattern, IEnumerable<PatternElement> patterns) Parameters basePattern PatternElement Base patterns of the universal quantifier that defines the universe of facts to consider. patterns IEnumerable<PatternElement> Additional patterns of the universal quantifier that the fact matched by the base pattern must also satisfy. Returns ForAllElement Created element. Group(GroupType, IEnumerable<RuleElement>) Creates a left-hand side group element, that contains pattern elements and nested group elements. public static GroupElement Group(GroupType groupType, IEnumerable<RuleElement> childElements) Parameters groupType GroupType Type of the group element. childElements IEnumerable<RuleElement> Child elements contained in the group. Returns GroupElement Created element. GroupBy(LambdaExpression, LambdaExpression, PatternElement) Creates an element that aggregates matching facts into groups. public static AggregateElement GroupBy(LambdaExpression keySelector, LambdaExpression elementSelector, PatternElement source) Parameters keySelector LambdaExpression Expression that extracts grouping keys from source element. elementSelector LambdaExpression Expression that extracts elements to put into resulting groups. source PatternElement Pattern that matches facts for aggregation. Returns AggregateElement Created element. GroupBy(Type, LambdaExpression, LambdaExpression, PatternElement) Creates an element that aggregates matching facts into groups. public static AggregateElement GroupBy(Type resultType, LambdaExpression keySelector, LambdaExpression elementSelector, PatternElement source) Parameters resultType Type Type of the aggregate result. keySelector LambdaExpression Expression that extracts grouping keys from source element. elementSelector LambdaExpression Expression that extracts elements to put into resulting groups. source PatternElement Pattern that matches facts for aggregation. Returns AggregateElement Created element. Not(RuleElement) Creates an element that represents a negative existential quantifier. public static NotElement Not(RuleElement source) Parameters source RuleElement Source element to apply the negative existential quantifier to. Returns NotElement Created element. OrGroup(params RuleElement[]) Creates a left-hand side group element that combines contained elements using an OR operator. public static OrElement OrGroup(params RuleElement[] childElements) Parameters childElements RuleElement[] Child elements contained in the group. Returns OrElement Created element. OrGroup(IEnumerable<RuleElement>) Creates a left-hand side group element that combines contained elements using an OR operator. public static OrElement OrGroup(IEnumerable<RuleElement> childElements) Parameters childElements IEnumerable<RuleElement> Child elements contained in the group. Returns OrElement Created element. Pattern(Declaration, IEnumerable<NamedExpressionElement>, RuleElement) Creates a pattern element that represents a match over results of the source element. public static PatternElement Pattern(Declaration declaration, IEnumerable<NamedExpressionElement> expressions, RuleElement source) Parameters declaration Declaration Declaration that references the pattern. expressions IEnumerable<NamedExpressionElement> Expressions used by the pattern to match elements. source RuleElement Source of the elements matched by the pattern. If it's null, the pattern matches facts in rules engine's working memory. Returns PatternElement Created element. Pattern(Declaration, IEnumerable<KeyValuePair<string, LambdaExpression>>) Creates a pattern element that represents a match of facts in rules engine's working memory. public static PatternElement Pattern(Declaration declaration, IEnumerable<KeyValuePair<string, LambdaExpression>> expressions) Parameters declaration Declaration Declaration that references the pattern. expressions IEnumerable<KeyValuePair<string, LambdaExpression>> Expressions used by the pattern to match elements. Returns PatternElement Created element. Pattern(Declaration, IEnumerable<KeyValuePair<string, LambdaExpression>>, RuleElement) Creates a pattern element that represents a match over results of the source element. public static PatternElement Pattern(Declaration declaration, IEnumerable<KeyValuePair<string, LambdaExpression>> expressions, RuleElement source) Parameters declaration Declaration Declaration that references the pattern. expressions IEnumerable<KeyValuePair<string, LambdaExpression>> Expressions used by the pattern to match elements. source RuleElement Source of the elements matched by the pattern. If it's null, the pattern matches facts in rules engine's working memory. Returns PatternElement Created element. Pattern(Type, string, IEnumerable<NamedExpressionElement>, RuleElement) Creates a pattern element that represents a match over results of the source element. public static PatternElement Pattern(Type type, string name, IEnumerable<NamedExpressionElement> expressions, RuleElement source) Parameters type Type Type of elements matched by the pattern. name string Pattern name. expressions IEnumerable<NamedExpressionElement> Expressions used by the pattern to match elements. source RuleElement Source of the elements matched by the pattern. If it's null, the pattern matches facts in rules engine's working memory. Returns PatternElement Created element. Pattern(Type, string, IEnumerable<KeyValuePair<string, LambdaExpression>>) Creates a pattern element that represents a match of facts in rules engine's working memory. public static PatternElement Pattern(Type type, string name, IEnumerable<KeyValuePair<string, LambdaExpression>> expressions) Parameters type Type Type of facts matched by the pattern. name string Pattern name. expressions IEnumerable<KeyValuePair<string, LambdaExpression>> Expressions used by the pattern to match elements. Returns PatternElement Created element. Pattern(Type, string, IEnumerable<KeyValuePair<string, LambdaExpression>>, RuleElement) Creates a pattern element that represents a match over results of the source element. public static PatternElement Pattern(Type type, string name, IEnumerable<KeyValuePair<string, LambdaExpression>> expressions, RuleElement source) Parameters type Type Type of elements matched by the pattern. name string Pattern name. expressions IEnumerable<KeyValuePair<string, LambdaExpression>> Expressions used by the pattern to match elements. source RuleElement Source of the elements matched by the pattern. If it's null, the pattern matches facts in rules engine's working memory. Returns PatternElement Created element. Project(LambdaExpression, PatternElement) Creates an element that projects matching facts into different elements. public static AggregateElement Project(LambdaExpression selector, PatternElement source) Parameters selector LambdaExpression Expression that translates a matching element into a different element. source PatternElement Pattern that matches facts for aggregation. Returns AggregateElement Created element. Project(Type, LambdaExpression, PatternElement) Creates an element that projects matching facts into different elements. public static AggregateElement Project(Type resultType, LambdaExpression selector, PatternElement source) Parameters resultType Type Type of the aggregate result. selector LambdaExpression Expression that translates a matching element into a different element. source PatternElement Pattern that matches facts for aggregation. Returns AggregateElement Created element. RuleDefinition(string, string, int, GroupElement, ActionGroupElement) Creates a rule definition. public static IRuleDefinition RuleDefinition(string name, string description, int priority, GroupElement leftHandSide, ActionGroupElement rightHandSide) Parameters name string Rule's name. description string Rule's description. priority int Rule's priority. leftHandSide GroupElement Rule's left-hand side top group element. rightHandSide ActionGroupElement Rule's right-hand side group element. Returns IRuleDefinition Created rule definition. RuleDefinition(string, string, int, RuleRepeatability, IEnumerable<string>, IEnumerable<RuleProperty>, DependencyGroupElement, GroupElement, FilterGroupElement, ActionGroupElement) Creates a rule definition. public static IRuleDefinition RuleDefinition(string name, string description, int priority, RuleRepeatability repeatability, IEnumerable<string> tags, IEnumerable<RuleProperty> properties, DependencyGroupElement dependencies, GroupElement leftHandSide, FilterGroupElement filters, ActionGroupElement rightHandSide) Parameters name string Rule's name. description string Rule's description. priority int Rule's priority. repeatability RuleRepeatability Rule's repeatability. tags IEnumerable<string> Tags associated with the rule. properties IEnumerable<RuleProperty> Properties associated with the rule. dependencies DependencyGroupElement Rule's dependency group element. leftHandSide GroupElement Rule's left-hand side top group element. filters FilterGroupElement Rule's filter group element. rightHandSide ActionGroupElement Rule's right-hand side group element. Returns IRuleDefinition Created rule definition. RuleDefinition(string, string, int, IEnumerable<string>, GroupElement, ActionGroupElement) Creates a rule definition. public static IRuleDefinition RuleDefinition(string name, string description, int priority, IEnumerable<string> tags, GroupElement leftHandSide, ActionGroupElement rightHandSide) Parameters name string Rule's name. description string Rule's description. priority int Rule's priority. tags IEnumerable<string> Tags associated with the rule. leftHandSide GroupElement Rule's left-hand side top group element. rightHandSide ActionGroupElement Rule's right-hand side group element. Returns IRuleDefinition Created rule definition."
  },
  "api/NRules.RuleModel.Builders.ExistsBuilder.html": {
    "href": "api/NRules.RuleModel.Builders.ExistsBuilder.html",
    "title": "Class ExistsBuilder | NRules",
    "keywords": "Class ExistsBuilder Namespace NRules.RuleModel.Builders Assembly NRules.RuleModel.dll Builder to compose an existential element. public class ExistsBuilder : RuleElementBuilder Inheritance object RuleElementBuilder ExistsBuilder Inherited Members RuleElementBuilder.DeclarationName(string) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors ExistsBuilder() Initializes a new instance of the ExistsBuilder. public ExistsBuilder() Methods Group(GroupBuilder) Sets a group builder as the source of the existential element. public void Group(GroupBuilder builder) Parameters builder GroupBuilder Element builder to set as the source. Group(GroupType) Creates a group builder that builds a group as the source of the existential element. public GroupBuilder Group(GroupType groupType) Parameters groupType GroupType Group type. Returns GroupBuilder Group builder. Group(GroupElement) Sets a group as the source of the existential element. public void Group(GroupElement element) Parameters element GroupElement Element to set as the source. Pattern(PatternBuilder) Sets a pattern builder as the source of the existential element. public void Pattern(PatternBuilder builder) Parameters builder PatternBuilder Element builder to set as the source. Pattern(Declaration) Creates a pattern builder that builds the source of the existential element. public PatternBuilder Pattern(Declaration declaration) Parameters declaration Declaration Pattern declaration. Returns PatternBuilder Pattern builder. Pattern(PatternElement) Sets a pattern as the source of the existential element. public void Pattern(PatternElement element) Parameters element PatternElement Element to set as the source. Pattern(Type, string) Creates a pattern builder that builds the source of the existential element. public PatternBuilder Pattern(Type type, string name = null) Parameters type Type Type of the element the pattern matches. name string Pattern name (optional). Returns PatternBuilder Pattern builder."
  },
  "api/NRules.RuleModel.Builders.FilterGroupBuilder.html": {
    "href": "api/NRules.RuleModel.Builders.FilterGroupBuilder.html",
    "title": "Class FilterGroupBuilder | NRules",
    "keywords": "Class FilterGroupBuilder Namespace NRules.RuleModel.Builders Assembly NRules.RuleModel.dll Builder to compose a group of rule match filters. public class FilterGroupBuilder : RuleElementBuilder Inheritance object RuleElementBuilder FilterGroupBuilder Inherited Members RuleElementBuilder.DeclarationName(string) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors FilterGroupBuilder() Initializes a new instance of the FilterGroupBuilder. public FilterGroupBuilder() Methods Filter(FilterElement) Adds a filter element to the group element. public void Filter(FilterElement element) Parameters element FilterElement Element to add. Filter(FilterType, LambdaExpression) Adds a filter to the group element. public void Filter(FilterType filterType, LambdaExpression expression) Parameters filterType FilterType Type of filter. expression LambdaExpression Filter expression."
  },
  "api/NRules.RuleModel.Builders.ForAllBuilder.html": {
    "href": "api/NRules.RuleModel.Builders.ForAllBuilder.html",
    "title": "Class ForAllBuilder | NRules",
    "keywords": "Class ForAllBuilder Namespace NRules.RuleModel.Builders Assembly NRules.RuleModel.dll Builder to compose a forall element (universal quantifier). public class ForAllBuilder : RuleElementBuilder Inheritance object RuleElementBuilder ForAllBuilder Inherited Members RuleElementBuilder.DeclarationName(string) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors ForAllBuilder() Initializes a new instance of the ForAllBuilder. public ForAllBuilder() Methods BasePattern(PatternBuilder) Sets the base pattern builder of the forall element. public void BasePattern(PatternBuilder builder) Parameters builder PatternBuilder Element builder to set as the base pattern. BasePattern(PatternElement) Sets the base pattern of the forall element. public void BasePattern(PatternElement element) Parameters element PatternElement Element to set as the base pattern. BasePattern(Type) Creates a pattern builder that builds the base pattern of the forall element. public PatternBuilder BasePattern(Type type) Parameters type Type Type of the element the pattern matches. Returns PatternBuilder Pattern builder. Pattern(PatternBuilder) Adds a pattern builder to the forall element. public void Pattern(PatternBuilder builder) Parameters builder PatternBuilder Element builder to add. Pattern(PatternElement) Adds a pattern to the forall element. public void Pattern(PatternElement element) Parameters element PatternElement Element to add. Pattern(Type) Creates a pattern builder that builds a pattern of the forall element. public PatternBuilder Pattern(Type type) Parameters type Type Type of the element the pattern matches. Returns PatternBuilder Pattern builder."
  },
  "api/NRules.RuleModel.Builders.GroupBuilder.html": {
    "href": "api/NRules.RuleModel.Builders.GroupBuilder.html",
    "title": "Class GroupBuilder | NRules",
    "keywords": "Class GroupBuilder Namespace NRules.RuleModel.Builders Assembly NRules.RuleModel.dll Builder to compose a group element. public class GroupBuilder : RuleElementBuilder Inheritance object RuleElementBuilder GroupBuilder Inherited Members RuleElementBuilder.DeclarationName(string) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors GroupBuilder() Initializes a new instance of the GroupBuilder. public GroupBuilder() Methods Exists() Creates a builder for an existential element as part of the current group element. public ExistsBuilder Exists() Returns ExistsBuilder Existential builder. Exists(ExistsBuilder) Adds an existential element builder to the group element. public void Exists(ExistsBuilder builder) Parameters builder ExistsBuilder Element builder to add. Exists(ExistsElement) Adds an existential element to the group element. public void Exists(ExistsElement element) Parameters element ExistsElement Element to add. ForAll() Creates a builder for a forall element as part of the current group element. public ForAllBuilder ForAll() Returns ForAllBuilder Forall builder. ForAll(ForAllBuilder) Adds a forall element builder to the group element. public void ForAll(ForAllBuilder builder) Parameters builder ForAllBuilder Element builder to add. ForAll(ForAllElement) Adds a forall element to the group element. public void ForAll(ForAllElement element) Parameters element ForAllElement Element to add. Group(GroupBuilder) Adds a nested group builder to this group element. public void Group(GroupBuilder builder) Parameters builder GroupBuilder Element builder to add. Group(GroupType) Creates a group builder that builds a group as part of the current group element. public GroupBuilder Group(GroupType groupType) Parameters groupType GroupType Group type. Returns GroupBuilder Group builder. Group(GroupElement) Adds a nested group to this group element. public void Group(GroupElement element) Parameters element GroupElement Element to add. GroupType(GroupType) Sets type of the group element. public void GroupType(GroupType groupType) Parameters groupType GroupType Group type to set. Not() Creates a builder for a negative existential element as part of the current group element. public NotBuilder Not() Returns NotBuilder Negative existential builder. Not(NotBuilder) Adds a negative existential element builder to the group element. public void Not(NotBuilder builder) Parameters builder NotBuilder Element builder to add. Not(NotElement) Adds a negative existential element to the group element. public void Not(NotElement element) Parameters element NotElement Element to add. Pattern(PatternBuilder) Adds a pattern builder to the group element. public void Pattern(PatternBuilder builder) Parameters builder PatternBuilder Element builder to add. Pattern(Declaration) Creates a pattern builder that builds a pattern as part of the current group element. public PatternBuilder Pattern(Declaration declaration) Parameters declaration Declaration Pattern declaration. Returns PatternBuilder Pattern builder. Pattern(PatternElement) Adds a pattern to the group element. public void Pattern(PatternElement element) Parameters element PatternElement Element to add. Pattern(Type, string) Creates a pattern builder that builds a pattern as part of the current group element. public PatternBuilder Pattern(Type type, string name = null) Parameters type Type Pattern type. name string Pattern name (optional). Returns PatternBuilder Pattern builder."
  },
  "api/NRules.RuleModel.Builders.GroupType.html": {
    "href": "api/NRules.RuleModel.Builders.GroupType.html",
    "title": "Enum GroupType | NRules",
    "keywords": "Enum GroupType Namespace NRules.RuleModel.Builders Assembly NRules.RuleModel.dll Type of group element. public enum GroupType Fields And = 0 Logical AND. Or = 1 Logical OR."
  },
  "api/NRules.RuleModel.Builders.NotBuilder.html": {
    "href": "api/NRules.RuleModel.Builders.NotBuilder.html",
    "title": "Class NotBuilder | NRules",
    "keywords": "Class NotBuilder Namespace NRules.RuleModel.Builders Assembly NRules.RuleModel.dll Builder to compose a negative existential element. public class NotBuilder : RuleElementBuilder Inheritance object RuleElementBuilder NotBuilder Inherited Members RuleElementBuilder.DeclarationName(string) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors NotBuilder() Initializes a new instance of the NotBuilder. public NotBuilder() Methods Group(GroupBuilder) Sets a group builder as the source of the negative existential element. public void Group(GroupBuilder builder) Parameters builder GroupBuilder Element builder to set as the source. Group(GroupType) Creates a group builder that builds a group as the source of the negative existential element. public GroupBuilder Group(GroupType groupType) Parameters groupType GroupType Group type. Returns GroupBuilder Group builder. Group(GroupElement) Sets a group as the source of the negative existential element. public void Group(GroupElement element) Parameters element GroupElement Element to set as the source. Pattern(PatternBuilder) Sets a pattern builder as the source of the negative existential element. public void Pattern(PatternBuilder builder) Parameters builder PatternBuilder Element builder to set as the source. Pattern(Declaration) Creates a pattern builder that builds the source of the negative existential element. public PatternBuilder Pattern(Declaration declaration) Parameters declaration Declaration Pattern declaration. Returns PatternBuilder Pattern builder. Pattern(PatternElement) Sets a pattern as the source of the negative existential element. public void Pattern(PatternElement element) Parameters element PatternElement Element to set as the source. Pattern(Type, string) Creates a pattern builder that builds the source of the negative existential element. public PatternBuilder Pattern(Type type, string name = null) Parameters type Type Type of the element the pattern matches. name string Pattern name (optional). Returns PatternBuilder Pattern builder."
  },
  "api/NRules.RuleModel.Builders.PatternBuilder.html": {
    "href": "api/NRules.RuleModel.Builders.PatternBuilder.html",
    "title": "Class PatternBuilder | NRules",
    "keywords": "Class PatternBuilder Namespace NRules.RuleModel.Builders Assembly NRules.RuleModel.dll Builder to compose a rule pattern. public class PatternBuilder : RuleElementBuilder Inheritance object RuleElementBuilder PatternBuilder Inherited Members RuleElementBuilder.DeclarationName(string) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors PatternBuilder(Declaration) Initializes a new instance of the PatternBuilder. public PatternBuilder(Declaration declaration) Parameters declaration Declaration Pattern declaration. PatternBuilder(Type, string) Initializes a new instance of the PatternBuilder. public PatternBuilder(Type type, string name) Parameters type Type Pattern type. name string Pattern name. Properties Declaration Pattern declaration. public Declaration Declaration { get; } Property Value Declaration Methods Aggregate() Creates an aggregate builder that builds the source of the pattern element. public AggregateBuilder Aggregate() Returns AggregateBuilder Aggregate builder. Aggregate(AggregateElement) Sets an aggregate element as the source of the pattern element. public void Aggregate(AggregateElement element) Parameters element AggregateElement Element to set as the source. Aggregate(AggregateBuilder) Sets an aggregate builder as the source of the pattern element. public void Aggregate(AggregateBuilder builder) Parameters builder AggregateBuilder Element builder to set as the source. Binding() Creates a binding builder that builds the source of the pattern element. public BindingBuilder Binding() Returns BindingBuilder Binding builder. Binding(BindingElement) Sets a binding element as the source of the pattern element. public void Binding(BindingElement element) Parameters element BindingElement Element to set as the source. Binding(BindingBuilder) Sets a binding builder as the source of the pattern element. public void Binding(BindingBuilder builder) Parameters builder BindingBuilder Element builder to set as the source. Condition(LambdaExpression) Adds a condition expression to the pattern element. public void Condition(LambdaExpression expression) Parameters expression LambdaExpression Condition expression. Names and types of the expression parameters must match the names and types defined in the pattern declarations."
  },
  "api/NRules.RuleModel.Builders.RuleBuilder.html": {
    "href": "api/NRules.RuleModel.Builders.RuleBuilder.html",
    "title": "Class RuleBuilder | NRules",
    "keywords": "Class RuleBuilder Namespace NRules.RuleModel.Builders Assembly NRules.RuleModel.dll Builder to compose a rule definition. Contains methods to specify rule's metadata, as well as create child builders for rule's left-hand side and right-hand side. Creates IRuleDefinition. public class RuleBuilder Inheritance object RuleBuilder Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors RuleBuilder() Constructs an empty rule builder. public RuleBuilder() Methods Build() Creates rule definition using current state of the builder. public IRuleDefinition Build() Returns IRuleDefinition Rule definition. Dependencies() Retrieves dependencies builder. public DependencyGroupBuilder Dependencies() Returns DependencyGroupBuilder Dependencies builder. Dependencies(DependencyGroupBuilder) Sets dependencies builder. public void Dependencies(DependencyGroupBuilder builder) Parameters builder DependencyGroupBuilder Builder to set. Description(string) Sets rule's description. public void Description(string description) Parameters description string Rule description value. Filters() Retrieves filters builder. public FilterGroupBuilder Filters() Returns FilterGroupBuilder Filters builder. Filters(FilterGroupBuilder) Sets filters builder. public void Filters(FilterGroupBuilder builder) Parameters builder FilterGroupBuilder Builder to set. LeftHandSide() Retrieves left-hand side builder (conditions). public GroupBuilder LeftHandSide() Returns GroupBuilder Left hand side builder. LeftHandSide(GroupBuilder) Sets left-hand side builder (conditions). public void LeftHandSide(GroupBuilder builder) Parameters builder GroupBuilder Builder to set. Name(string) Sets rule's name. public void Name(string name) Parameters name string Rule name value. Priority(int) Sets rule's priority. Default priority is 0. public void Priority(int priority) Parameters priority int Rule priority value. Properties(IEnumerable<RuleProperty>) Adds rule's properties. public void Properties(IEnumerable<RuleProperty> properties) Parameters properties IEnumerable<RuleProperty> Rule property. Property(string, object) Adds rule's property. public void Property(string name, object value) Parameters name string Property name. value object Property value. Repeatability(RuleRepeatability) Sets rule's repeatability. Default repeatability is Repeatable. public void Repeatability(RuleRepeatability repeatability) Parameters repeatability RuleRepeatability RightHandSide() Retrieves right-hand side builder (actions). public ActionGroupBuilder RightHandSide() Returns ActionGroupBuilder Right hand side builder. RightHandSide(ActionGroupBuilder) Sets right-hand side builder. public void RightHandSide(ActionGroupBuilder builder) Parameters builder ActionGroupBuilder Builder to set. Tag(string) Adds rule's tag. public void Tag(string tag) Parameters tag string Rule tag value. Tags(IEnumerable<string>) Adds rule's tags. public void Tags(IEnumerable<string> tags) Parameters tags IEnumerable<string> Rule tag values."
  },
  "api/NRules.RuleModel.Builders.RuleElementBuilder.html": {
    "href": "api/NRules.RuleModel.Builders.RuleElementBuilder.html",
    "title": "Class RuleElementBuilder | NRules",
    "keywords": "Class RuleElementBuilder Namespace NRules.RuleModel.Builders Assembly NRules.RuleModel.dll Base class for rule element builders. public abstract class RuleElementBuilder Inheritance object RuleElementBuilder Derived ActionGroupBuilder AggregateBuilder BindingBuilder DependencyGroupBuilder ExistsBuilder FilterGroupBuilder ForAllBuilder GroupBuilder NotBuilder PatternBuilder Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods DeclarationName(string) protected string DeclarationName(string name) Parameters name string Returns string"
  },
  "api/NRules.RuleModel.Builders.RuleTransformation.Context.html": {
    "href": "api/NRules.RuleModel.Builders.RuleTransformation.Context.html",
    "title": "Class RuleTransformation.Context | NRules",
    "keywords": "Class RuleTransformation.Context Namespace NRules.RuleModel.Builders Assembly NRules.RuleModel.dll public class RuleTransformation.Context Inheritance object RuleTransformation.Context Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString()"
  },
  "api/NRules.RuleModel.Builders.RuleTransformation.html": {
    "href": "api/NRules.RuleModel.Builders.RuleTransformation.html",
    "title": "Class RuleTransformation | NRules",
    "keywords": "Class RuleTransformation Namespace NRules.RuleModel.Builders Assembly NRules.RuleModel.dll public class RuleTransformation : RuleElementVisitor<RuleTransformation.Context> Inheritance object RuleElementVisitor<RuleTransformation.Context> RuleTransformation Inherited Members RuleElementVisitor<RuleTransformation.Context>.Visit(RuleTransformation.Context, RuleElement) RuleElementVisitor<RuleTransformation.Context>.VisitNamedExpression(RuleTransformation.Context, NamedExpressionElement) RuleElementVisitor<RuleTransformation.Context>.VisitDependencyGroup(RuleTransformation.Context, DependencyGroupElement) RuleElementVisitor<RuleTransformation.Context>.VisitDependency(RuleTransformation.Context, DependencyElement) RuleElementVisitor<RuleTransformation.Context>.VisitFilterGroup(RuleTransformation.Context, FilterGroupElement) RuleElementVisitor<RuleTransformation.Context>.VisitFilter(RuleTransformation.Context, FilterElement) object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods Transform(IRuleDefinition) public IRuleDefinition Transform(IRuleDefinition rule) Parameters rule IRuleDefinition Returns IRuleDefinition VisitAction(Context, ActionElement) protected override void VisitAction(RuleTransformation.Context context, ActionElement element) Parameters context RuleTransformation.Context element ActionElement VisitActionGroup(Context, ActionGroupElement) protected override void VisitActionGroup(RuleTransformation.Context context, ActionGroupElement element) Parameters context RuleTransformation.Context element ActionGroupElement VisitAggregate(Context, AggregateElement) protected override void VisitAggregate(RuleTransformation.Context context, AggregateElement element) Parameters context RuleTransformation.Context element AggregateElement VisitAnd(Context, AndElement) protected override void VisitAnd(RuleTransformation.Context context, AndElement element) Parameters context RuleTransformation.Context element AndElement VisitBinding(Context, BindingElement) protected override void VisitBinding(RuleTransformation.Context context, BindingElement element) Parameters context RuleTransformation.Context element BindingElement VisitExists(Context, ExistsElement) protected override void VisitExists(RuleTransformation.Context context, ExistsElement element) Parameters context RuleTransformation.Context element ExistsElement VisitForAll(Context, ForAllElement) protected override void VisitForAll(RuleTransformation.Context context, ForAllElement element) Parameters context RuleTransformation.Context element ForAllElement VisitNot(Context, NotElement) protected override void VisitNot(RuleTransformation.Context context, NotElement element) Parameters context RuleTransformation.Context element NotElement VisitOr(Context, OrElement) protected override void VisitOr(RuleTransformation.Context context, OrElement element) Parameters context RuleTransformation.Context element OrElement VisitPattern(Context, PatternElement) protected override void VisitPattern(RuleTransformation.Context context, PatternElement element) Parameters context RuleTransformation.Context element PatternElement"
  },
  "api/NRules.RuleModel.Builders.html": {
    "href": "api/NRules.RuleModel.Builders.html",
    "title": "Namespace NRules.RuleModel.Builders | NRules",
    "keywords": "Namespace NRules.RuleModel.Builders Contains types that allow building rules at runtime in the canonical model form. Classes ActionGroupBuilder Builder to compose a group of rule actions. AggregateBuilder Builder to compose an aggregate element. BindingBuilder Builder to compose a binding expression element. DependencyGroupBuilder Builder to compose a group of rule dependencies. Element Factory class for rule elements. ExistsBuilder Builder to compose an existential element. FilterGroupBuilder Builder to compose a group of rule match filters. ForAllBuilder Builder to compose a forall element (universal quantifier). GroupBuilder Builder to compose a group element. NotBuilder Builder to compose a negative existential element. PatternBuilder Builder to compose a rule pattern. RuleBuilder Builder to compose a rule definition. Contains methods to specify rule's metadata, as well as create child builders for rule's left-hand side and right-hand side. Creates IRuleDefinition. RuleElementBuilder Base class for rule element builders. RuleTransformation RuleTransformation.Context Enums GroupType Type of group element."
  },
  "api/NRules.RuleModel.Declaration.html": {
    "href": "api/NRules.RuleModel.Declaration.html",
    "title": "Class Declaration | NRules",
    "keywords": "Class Declaration Namespace NRules.RuleModel Assembly NRules.RuleModel.dll Rule element declaration. public sealed class Declaration : IEquatable<Declaration> Inheritance object Declaration Implements IEquatable<Declaration> Inherited Members object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) object.ToString() Extension Methods DeclarationExtensions.ToParameterExpression(Declaration) Properties Name Symbol name. public string Name { get; } Property Value string Target Rule element that this declaration is referencing. public RuleElement Target { get; } Property Value RuleElement Type Symbol type. public Type Type { get; } Property Value Type Methods Equals(Declaration) Indicates whether the current object is equal to another object of the same type. public bool Equals(Declaration other) Parameters other Declaration An object to compare with this object. Returns bool true if the current object is equal to the other parameter; otherwise, false. Equals(object) Determines whether the specified object is equal to the current object. public override bool Equals(object obj) Parameters obj object The object to compare with the current object. Returns bool true if the specified object is equal to the current object; otherwise, false. GetHashCode() Serves as the default hash function. public override int GetHashCode() Returns int A hash code for the current object."
  },
  "api/NRules.RuleModel.DeclarationExtensions.html": {
    "href": "api/NRules.RuleModel.DeclarationExtensions.html",
    "title": "Class DeclarationExtensions | NRules",
    "keywords": "Class DeclarationExtensions Namespace NRules.RuleModel Assembly NRules.RuleModel.dll public static class DeclarationExtensions Inheritance object DeclarationExtensions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods ToDeclaration(ParameterExpression) Converts ParameterExpression to a rule element Declaration. public static Declaration ToDeclaration(this ParameterExpression parameter) Parameters parameter ParameterExpression Parameter expression to convert Returns Declaration Rule element declaration. ToParameterExpression(Declaration) Converts rule element Declaration to a ParameterExpression. public static ParameterExpression ToParameterExpression(this Declaration declaration) Parameters declaration Declaration Declaration to convert. Returns ParameterExpression Parameter expression."
  },
  "api/NRules.RuleModel.DependencyElement.html": {
    "href": "api/NRules.RuleModel.DependencyElement.html",
    "title": "Class DependencyElement | NRules",
    "keywords": "Class DependencyElement Namespace NRules.RuleModel Assembly NRules.RuleModel.dll Dependency that the rule uses when its actions run. public class DependencyElement : RuleElement Inheritance object RuleElement DependencyElement Inherited Members RuleElement.Exports RuleElement.Imports object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Extension Methods RuleElementExtensions.Match(RuleElement, Action<PatternElement>, Action<AggregateElement>, Action<GroupElement>, Action<ExistsElement>, Action<NotElement>, Action<ForAllElement>) Properties Declaration Declaration that references the dependency. public Declaration Declaration { get; } Property Value Declaration ElementType Element type of this rule element. public override ElementType ElementType { get; } Property Value ElementType ServiceType Type of service that this dependency configures. public Type ServiceType { get; } Property Value Type"
  },
  "api/NRules.RuleModel.DependencyGroupElement.html": {
    "href": "api/NRules.RuleModel.DependencyGroupElement.html",
    "title": "Class DependencyGroupElement | NRules",
    "keywords": "Class DependencyGroupElement Namespace NRules.RuleModel Assembly NRules.RuleModel.dll Rule element that groups dependencies that the rule uses when its actions runs. public class DependencyGroupElement : RuleElement Inheritance object RuleElement DependencyGroupElement Inherited Members RuleElement.Exports RuleElement.Imports object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Extension Methods RuleElementExtensions.Match(RuleElement, Action<PatternElement>, Action<AggregateElement>, Action<GroupElement>, Action<ExistsElement>, Action<NotElement>, Action<ForAllElement>) Properties Dependencies List of dependencies the group element contains. public IEnumerable<DependencyElement> Dependencies { get; } Property Value IEnumerable<DependencyElement> ElementType Element type of this rule element. public override ElementType ElementType { get; } Property Value ElementType"
  },
  "api/NRules.RuleModel.ElementType.html": {
    "href": "api/NRules.RuleModel.ElementType.html",
    "title": "Enum ElementType | NRules",
    "keywords": "Enum ElementType Namespace NRules.RuleModel Assembly NRules.RuleModel.dll Describes the element types for the elements of a rule definition. public enum ElementType Fields Action = 0 Action invoked when the rule fires. ActionGroup = 1 Collection of actions associated with the rule. Aggregate = 2 Aggregation of facts into synthetic composite facts. And = 3 Grouping of the match patterns that matches only when all child patterns match. Binding = 4 Evaluates an expression and binds the result to a name. Dependency = 5 External service the rule depends on. DependencyGroup = 6 Collection of dependencies associated with the rule. Exists = 7 Existential quantifier that matches if at least one source fact is present. Filter = 8 Agenda filter applied to complete fact matches to determine if they should be placed on agenda. FilterGroup = 9 Collection of agenda filters associated with the rule. ForAll = 10 Universal quantifier that matches if all facts matching its first pattern also match all other patterns defined in the quantifier. Not = 11 Existential quantifier that matches if no source fact are present. Or = 12 Grouping of the match patterns that matches when any child patterns matches. Pattern = 13 A pattern that matches facts. NamedExpression = 14 An expression evaluated by the rules engine."
  },
  "api/NRules.RuleModel.ExistsElement.html": {
    "href": "api/NRules.RuleModel.ExistsElement.html",
    "title": "Class ExistsElement | NRules",
    "keywords": "Class ExistsElement Namespace NRules.RuleModel Assembly NRules.RuleModel.dll Existential quantifier. public class ExistsElement : RuleElement Inheritance object RuleElement ExistsElement Inherited Members RuleElement.Exports RuleElement.Imports object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Extension Methods RuleElementExtensions.Match(RuleElement, Action<PatternElement>, Action<AggregateElement>, Action<GroupElement>, Action<ExistsElement>, Action<NotElement>, Action<ForAllElement>) Properties ElementType Element type of this rule element. public override ElementType ElementType { get; } Property Value ElementType Source Fact source of the existential element. public RuleElement Source { get; } Property Value RuleElement"
  },
  "api/NRules.RuleModel.ExpressionCollection.html": {
    "href": "api/NRules.RuleModel.ExpressionCollection.html",
    "title": "Class ExpressionCollection | NRules",
    "keywords": "Class ExpressionCollection Namespace NRules.RuleModel Assembly NRules.RuleModel.dll Ordered readonly collection of named expressions. public class ExpressionCollection : IEnumerable<NamedExpressionElement>, IEnumerable Inheritance object ExpressionCollection Implements IEnumerable<NamedExpressionElement> IEnumerable Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Count Number of expressions in the collection. public int Count { get; } Property Value int this[string] Retrieves single expression by name. public NamedExpressionElement this[string name] { get; } Parameters name string Expression name. Property Value NamedExpressionElement Matching expression. Methods Find(string) Retrieves expressions by name. public IEnumerable<NamedExpressionElement> Find(string name) Parameters name string Expression name. Returns IEnumerable<NamedExpressionElement> Matching expression or empty IEnumerable. FindSingleOrDefault(string) Retrieves single expression by name. public NamedExpressionElement FindSingleOrDefault(string name) Parameters name string Expression name. Returns NamedExpressionElement Matching expression or null. GetEnumerator() Returns an enumerator for the contained expression elements. public IEnumerator<NamedExpressionElement> GetEnumerator() Returns IEnumerator<NamedExpressionElement>"
  },
  "api/NRules.RuleModel.ExpressionElement.html": {
    "href": "api/NRules.RuleModel.ExpressionElement.html",
    "title": "Class ExpressionElement | NRules",
    "keywords": "Class ExpressionElement Namespace NRules.RuleModel Assembly NRules.RuleModel.dll Rule element that defines an expression. public abstract class ExpressionElement : RuleElement Inheritance object RuleElement ExpressionElement Derived ActionElement BindingElement FilterElement NamedExpressionElement Inherited Members RuleElement.ElementType RuleElement.Exports RuleElement.Imports object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Extension Methods RuleElementExtensions.Match(RuleElement, Action<PatternElement>, Action<AggregateElement>, Action<GroupElement>, Action<ExistsElement>, Action<NotElement>, Action<ForAllElement>) Properties Expression Expression. public LambdaExpression Expression { get; } Property Value LambdaExpression"
  },
  "api/NRules.RuleModel.FactSourceType.html": {
    "href": "api/NRules.RuleModel.FactSourceType.html",
    "title": "Enum FactSourceType | NRules",
    "keywords": "Enum FactSourceType Namespace NRules.RuleModel Assembly NRules.RuleModel.dll Type of source that produced the fact. public enum FactSourceType Fields Aggregate = 1 Fact produced by an aggregation. Linked = 2 Fact produced as a linked fact from a rule action."
  },
  "api/NRules.RuleModel.FilterElement.html": {
    "href": "api/NRules.RuleModel.FilterElement.html",
    "title": "Class FilterElement | NRules",
    "keywords": "Class FilterElement Namespace NRules.RuleModel Assembly NRules.RuleModel.dll Filter that determines which rule matches should trigger rule actions. public class FilterElement : ExpressionElement Inheritance object RuleElement ExpressionElement FilterElement Inherited Members ExpressionElement.Expression RuleElement.Exports RuleElement.Imports object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Extension Methods RuleElementExtensions.Match(RuleElement, Action<PatternElement>, Action<AggregateElement>, Action<GroupElement>, Action<ExistsElement>, Action<NotElement>, Action<ForAllElement>) Properties ElementType Element type of this rule element. public override ElementType ElementType { get; } Property Value ElementType FilterType Type of rule match filter. public FilterType FilterType { get; } Property Value FilterType"
  },
  "api/NRules.RuleModel.FilterGroupElement.html": {
    "href": "api/NRules.RuleModel.FilterGroupElement.html",
    "title": "Class FilterGroupElement | NRules",
    "keywords": "Class FilterGroupElement Namespace NRules.RuleModel Assembly NRules.RuleModel.dll Rule element that groups filters that determine which rule matches should trigger rule actions. public class FilterGroupElement : RuleElement Inheritance object RuleElement FilterGroupElement Inherited Members RuleElement.Exports RuleElement.Imports object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Extension Methods RuleElementExtensions.Match(RuleElement, Action<PatternElement>, Action<AggregateElement>, Action<GroupElement>, Action<ExistsElement>, Action<NotElement>, Action<ForAllElement>) Properties ElementType Element type of this rule element. public override ElementType ElementType { get; } Property Value ElementType Filters List of filters the group element contains. public IEnumerable<FilterElement> Filters { get; } Property Value IEnumerable<FilterElement>"
  },
  "api/NRules.RuleModel.FilterType.html": {
    "href": "api/NRules.RuleModel.FilterType.html",
    "title": "Enum FilterType | NRules",
    "keywords": "Enum FilterType Namespace NRules.RuleModel Assembly NRules.RuleModel.dll Type of filter applied to rule matches. public enum FilterType Fields Predicate = 0 Filter based on a predicate expression. KeyChange = 1 Filter that only accepts matches that result in a change of a given key."
  },
  "api/NRules.RuleModel.ForAllElement.html": {
    "href": "api/NRules.RuleModel.ForAllElement.html",
    "title": "Class ForAllElement | NRules",
    "keywords": "Class ForAllElement Namespace NRules.RuleModel Assembly NRules.RuleModel.dll Universal quantifier. public class ForAllElement : RuleElement Inheritance object RuleElement ForAllElement Inherited Members RuleElement.Exports RuleElement.Imports object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Extension Methods RuleElementExtensions.Match(RuleElement, Action<PatternElement>, Action<AggregateElement>, Action<GroupElement>, Action<ExistsElement>, Action<NotElement>, Action<ForAllElement>) Properties BasePattern Base pattern that determines the universe of facts that the universal quantifier is applied to. public PatternElement BasePattern { get; } Property Value PatternElement ElementType Element type of this rule element. public override ElementType ElementType { get; } Property Value ElementType Patterns Patterns that must all match for the selected facts. public IEnumerable<PatternElement> Patterns { get; } Property Value IEnumerable<PatternElement>"
  },
  "api/NRules.RuleModel.GroupElement.html": {
    "href": "api/NRules.RuleModel.GroupElement.html",
    "title": "Class GroupElement | NRules",
    "keywords": "Class GroupElement Namespace NRules.RuleModel Assembly NRules.RuleModel.dll Grouping element that logically combines the patterns or other grouping elements. public abstract class GroupElement : RuleElement Inheritance object RuleElement GroupElement Derived AndElement OrElement Inherited Members RuleElement.ElementType RuleElement.Exports RuleElement.Imports object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Extension Methods RuleElementExtensions.Match(GroupElement, Action<AndElement>, Action<OrElement>) RuleElementExtensions.Match(RuleElement, Action<PatternElement>, Action<AggregateElement>, Action<GroupElement>, Action<ExistsElement>, Action<NotElement>, Action<ForAllElement>) Properties ChildElements List of child elements in the grouping. public IEnumerable<RuleElement> ChildElements { get; } Property Value IEnumerable<RuleElement>"
  },
  "api/NRules.RuleModel.IContext.html": {
    "href": "api/NRules.RuleModel.IContext.html",
    "title": "Interface IContext | NRules",
    "keywords": "Interface IContext Namespace NRules.RuleModel Assembly NRules.RuleModel.dll Rules engine execution context. Can be used by rules to interact with the rules engine, i.e. insert, update, retract facts. public interface IContext Extension Methods ContextExtensions.Resolve<TService>(IContext) ContextExtensions.Update<T>(IContext, T, Action<T>) Properties CancellationToken Enables cooperative cancellation of the rules execution cycle. CancellationToken CancellationToken { get; } Property Value CancellationToken Match Current rule match. IMatch Match { get; } Property Value IMatch Rule Current rule definition. IRuleDefinition Rule { get; } Property Value IRuleDefinition Methods GetLinked(object) Retrieves a fact linked to the current rule activation by key. object GetLinked(object key) Parameters key object Key for the linked fact. Returns object Linked fact if it exists, null otherwise. GetLinkedKeys() Retrieves keys of facts linked to the current rule activation. IEnumerable<object> GetLinkedKeys() Returns IEnumerable<object> Keys for linked facts. Halt() Halts rules execution. The engine continues execution of the current rule and exits the execution cycle. void Halt() Insert(object) Inserts a new fact to the rules engine memory. void Insert(object fact) Parameters fact object Fact to add. Exceptions ArgumentException If fact already exists in working memory. InsertAll(IEnumerable<object>) Inserts new facts to the rules engine memory. void InsertAll(IEnumerable<object> facts) Parameters facts IEnumerable<object> Facts to add. Exceptions ArgumentException If any fact already exists in working memory. InsertAllLinked(IEnumerable<KeyValuePair<object, object>>) Inserts new facts and links them to the current rule activation. The facts will be automatically retracted if this activation is removed. void InsertAllLinked(IEnumerable<KeyValuePair<object, object>> keyedFacts) Parameters keyedFacts IEnumerable<KeyValuePair<object, object>> Keyed facts to insert. Keys must be unique for a given rule. InsertLinked(object, object) Inserts a new fact and links it to the current rule activation. The fact will be automatically retracted if this activation is removed. void InsertLinked(object key, object fact) Parameters key object Key for the linked fact. Must be unique for a given rule. fact object Fact to insert. Resolve(Type) Resolves a registered service (normally via an IoC container). object Resolve(Type serviceType) Parameters serviceType Type Type of service to resolve. Returns object Service instance. Retract(object) Removes existing fact from the rules engine memory. void Retract(object fact) Parameters fact object Fact to remove. Exceptions ArgumentException If fact does not exist in working memory. RetractAll(IEnumerable<object>) Removes existing facts from the rules engine memory. void RetractAll(IEnumerable<object> facts) Parameters facts IEnumerable<object> Facts to remove. Exceptions ArgumentException If any fact does not exist in working memory. RetractAllLinked(IEnumerable<KeyValuePair<object, object>>) Retracts existing facts that are linked to the current rule activation. void RetractAllLinked(IEnumerable<KeyValuePair<object, object>> keyedFacts) Parameters keyedFacts IEnumerable<KeyValuePair<object, object>> Keyed facts to retract. Keys must be unique for a given rule. Remarks Linked facts are retracted automatically, when activation is deleted, but this method can be used in complex scenarios, when linked facts need to be retracted explicitly, prior to activation getting deleted. RetractLinked(object, object) Retracts existing fact that's linked to the current rule activation. void RetractLinked(object key, object fact) Parameters key object Key for the linked fact. Must be unique for a given rule. fact object Fact to retract. Remarks Linked facts are retracted automatically, when activation is deleted, but this method can be used in complex scenarios, when linked facts need to be retracted explicitly, prior to activation getting deleted. TryInsert(object) Inserts a fact to the rules engine memory if the fact does not exist. bool TryInsert(object fact) Parameters fact object Fact to add. Returns bool Whether the fact was inserted or not. TryRetract(object) Removes a fact from the rules engine memory if the fact exists. bool TryRetract(object fact) Parameters fact object Fact to remove. Returns bool Whether the fact was retracted or not. TryUpdate(object) Updates a fact in the rules engine memory if the fact exists. bool TryUpdate(object fact) Parameters fact object Fact to update. Returns bool Whether the fact was updated or not. Update(object) Updates existing fact in the rules engine memory. void Update(object fact) Parameters fact object Fact to update. Exceptions ArgumentException If fact does not exist in working memory. UpdateAll(IEnumerable<object>) Updates existing facts in the rules engine memory. void UpdateAll(IEnumerable<object> facts) Parameters facts IEnumerable<object> Facts to update. Exceptions ArgumentException If any fact does not exist in working memory. UpdateAllLinked(IEnumerable<KeyValuePair<object, object>>) Updates existing facts that are linked to the current rule activation. void UpdateAllLinked(IEnumerable<KeyValuePair<object, object>> keyedFacts) Parameters keyedFacts IEnumerable<KeyValuePair<object, object>> Keyed facts to update. Keys must be unique for a given rule. UpdateLinked(object, object) Updates existing fact that's linked to the current rule activation. void UpdateLinked(object key, object fact) Parameters key object Key for the linked fact. Must be unique for a given rule. fact object Fact to update."
  },
  "api/NRules.RuleModel.IFact.html": {
    "href": "api/NRules.RuleModel.IFact.html",
    "title": "Interface IFact | NRules",
    "keywords": "Interface IFact Namespace NRules.RuleModel Assembly NRules.RuleModel.dll Fact in the engine's working memory. public interface IFact Properties Source Source of this fact, for synthetic facts, or null. IFactSource Source { get; } Property Value IFactSource Type Fact runtime type. Type Type { get; } Property Value Type Value Fact value. object Value { get; } Property Value object"
  },
  "api/NRules.RuleModel.IFactMatch.html": {
    "href": "api/NRules.RuleModel.IFactMatch.html",
    "title": "Interface IFactMatch | NRules",
    "keywords": "Interface IFactMatch Namespace NRules.RuleModel Assembly NRules.RuleModel.dll Represents a fact matched by a rule. public interface IFactMatch : IFact Inherited Members IFact.Type IFact.Value IFact.Source Properties Declaration Variable declaration that corresponds to the fact. Declaration Declaration { get; } Property Value Declaration See Also IFact"
  },
  "api/NRules.RuleModel.IFactSource.html": {
    "href": "api/NRules.RuleModel.IFactSource.html",
    "title": "Interface IFactSource | NRules",
    "keywords": "Interface IFactSource Namespace NRules.RuleModel Assembly NRules.RuleModel.dll Source of the fact, for synthetic facts. public interface IFactSource Properties Facts Facts that produced this fact. IEnumerable<IFact> Facts { get; } Property Value IEnumerable<IFact> SourceType Type of source that produced this fact. FactSourceType SourceType { get; } Property Value FactSourceType"
  },
  "api/NRules.RuleModel.IKeyedLookup-2.html": {
    "href": "api/NRules.RuleModel.IKeyedLookup-2.html",
    "title": "Interface IKeyedLookup<TKey, TElement> | NRules",
    "keywords": "Interface IKeyedLookup<TKey, TElement> Namespace NRules.RuleModel Assembly NRules.RuleModel.dll Collection of facts grouped by a key. Exposes all keys present in the lookup as a Keys collection. public interface IKeyedLookup<TKey, TElement> : ILookup<TKey, TElement>, IEnumerable<IGrouping<TKey, TElement>>, IEnumerable Type Parameters TKey The type of the keys in the lookup. TElement The type of the elements in the lookup, Inherited Members ILookup<TKey, TElement>.Contains(TKey) ILookup<TKey, TElement>.Count ILookup<TKey, TElement>.this[TKey] IEnumerable<IGrouping<TKey, TElement>>.GetEnumerator() IEnumerable.GetEnumerator() Properties Keys All keys present in the lookup. To find the number of keys in the lookup use Count. IEnumerable<TKey> Keys { get; } Property Value IEnumerable<TKey>"
  },
  "api/NRules.RuleModel.IMatch.html": {
    "href": "api/NRules.RuleModel.IMatch.html",
    "title": "Interface IMatch | NRules",
    "keywords": "Interface IMatch Namespace NRules.RuleModel Assembly NRules.RuleModel.dll Represents a match of all rule's conditions. public interface IMatch Properties Facts Facts matched by the rule. IEnumerable<IFactMatch> Facts { get; } Property Value IEnumerable<IFactMatch> Rule Rule that matched the given facts. IRuleDefinition Rule { get; } Property Value IRuleDefinition Trigger Event that triggered the match. MatchTrigger Trigger { get; } Property Value MatchTrigger"
  },
  "api/NRules.RuleModel.IRuleDefinition.html": {
    "href": "api/NRules.RuleModel.IRuleDefinition.html",
    "title": "Interface IRuleDefinition | NRules",
    "keywords": "Interface IRuleDefinition Namespace NRules.RuleModel Assembly NRules.RuleModel.dll Production rule definition in the canonical rule model. public interface IRuleDefinition Properties DependencyGroup Rule's dependencies. DependencyGroupElement DependencyGroup { get; } Property Value DependencyGroupElement Description Rule description. string Description { get; } Property Value string FilterGroup Rule's filters, that determine whether rule's match triggers actions. FilterGroupElement FilterGroup { get; } Property Value FilterGroupElement LeftHandSide Rule left-hand side (conditions). GroupElement LeftHandSide { get; } Property Value GroupElement Name Rule name. string Name { get; } Property Value string Priority Rule priority. int Priority { get; } Property Value int Properties Properties attached to the rule. PropertyMap Properties { get; } Property Value PropertyMap Repeatability Rule repeatability. RuleRepeatability Repeatability { get; } Property Value RuleRepeatability RightHandSide Rule right-hand side (actions). ActionGroupElement RightHandSide { get; } Property Value ActionGroupElement Tags Tags applied to the rule. IEnumerable<string> Tags { get; } Property Value IEnumerable<string>"
  },
  "api/NRules.RuleModel.IRuleRepository.html": {
    "href": "api/NRules.RuleModel.IRuleRepository.html",
    "title": "Interface IRuleRepository | NRules",
    "keywords": "Interface IRuleRepository Namespace NRules.RuleModel Assembly NRules.RuleModel.dll In-memory database of production rules arranged into rule sets. IRuleSet public interface IRuleRepository Extension Methods RuleRepositoryExtensions.Compile(IRuleRepository) RuleRepositoryExtensions.Compile(IRuleRepository, CancellationToken) RuleRepositoryExtensions.GetRules(IRuleRepository) Methods GetRuleSets() Retrieves all rule sets contained in the repository. IEnumerable<IRuleSet> GetRuleSets() Returns IEnumerable<IRuleSet> Collection of rule sets."
  },
  "api/NRules.RuleModel.IRuleSet.html": {
    "href": "api/NRules.RuleModel.IRuleSet.html",
    "title": "Interface IRuleSet | NRules",
    "keywords": "Interface IRuleSet Namespace NRules.RuleModel Assembly NRules.RuleModel.dll Represents a named set of rules. public interface IRuleSet Extension Methods RuleSetExtensions.Add(IRuleSet, IRuleDefinition) Properties Name Rule set name. string Name { get; } Property Value string Rules Rules in the rule set. IEnumerable<IRuleDefinition> Rules { get; } Property Value IEnumerable<IRuleDefinition> Methods Add(IEnumerable<IRuleDefinition>) Adds rules to the rule set. void Add(IEnumerable<IRuleDefinition> ruleDefinitions) Parameters ruleDefinitions IEnumerable<IRuleDefinition> Rule definitions to add."
  },
  "api/NRules.RuleModel.ITuple.html": {
    "href": "api/NRules.RuleModel.ITuple.html",
    "title": "Interface ITuple | NRules",
    "keywords": "Interface ITuple Namespace NRules.RuleModel Assembly NRules.RuleModel.dll Set of facts matched by the rules engine. public interface ITuple Properties Count Number of facts in the tuple. int Count { get; } Property Value int Facts Facts in the tuple, representing a partial match in the engine's working memory. IEnumerable<IFact> Facts { get; } Property Value IEnumerable<IFact> Remarks Facts in the tuple are stored in the reverse order. See Also IFact"
  },
  "api/NRules.RuleModel.MatchTrigger.html": {
    "href": "api/NRules.RuleModel.MatchTrigger.html",
    "title": "Enum MatchTrigger | NRules",
    "keywords": "Enum MatchTrigger Namespace NRules.RuleModel Assembly NRules.RuleModel.dll Event that triggered the match. public enum MatchTrigger Fields None = 0 Match is not active. Created = 1 Match is triggered due to activation creation. Updated = 2 Match is triggered due to activation update. Removed = 4 Match is triggered due to activation removal."
  },
  "api/NRules.RuleModel.NamedExpressionElement.html": {
    "href": "api/NRules.RuleModel.NamedExpressionElement.html",
    "title": "Class NamedExpressionElement | NRules",
    "keywords": "Class NamedExpressionElement Namespace NRules.RuleModel Assembly NRules.RuleModel.dll Expression with a name used by an aggregator. public class NamedExpressionElement : ExpressionElement Inheritance object RuleElement ExpressionElement NamedExpressionElement Inherited Members ExpressionElement.Expression RuleElement.Exports RuleElement.Imports object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Extension Methods RuleElementExtensions.Match(RuleElement, Action<PatternElement>, Action<AggregateElement>, Action<GroupElement>, Action<ExistsElement>, Action<NotElement>, Action<ForAllElement>) Properties ElementType Element type of this rule element. public override ElementType ElementType { get; } Property Value ElementType Name Expression name. public string Name { get; } Property Value string"
  },
  "api/NRules.RuleModel.NotElement.html": {
    "href": "api/NRules.RuleModel.NotElement.html",
    "title": "Class NotElement | NRules",
    "keywords": "Class NotElement Namespace NRules.RuleModel Assembly NRules.RuleModel.dll Negative existential quantifier. public class NotElement : RuleElement Inheritance object RuleElement NotElement Inherited Members RuleElement.Exports RuleElement.Imports object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Extension Methods RuleElementExtensions.Match(RuleElement, Action<PatternElement>, Action<AggregateElement>, Action<GroupElement>, Action<ExistsElement>, Action<NotElement>, Action<ForAllElement>) Properties ElementType Element type of this rule element. public override ElementType ElementType { get; } Property Value ElementType Source Fact source of the not element. public RuleElement Source { get; } Property Value RuleElement"
  },
  "api/NRules.RuleModel.OrElement.html": {
    "href": "api/NRules.RuleModel.OrElement.html",
    "title": "Class OrElement | NRules",
    "keywords": "Class OrElement Namespace NRules.RuleModel Assembly NRules.RuleModel.dll Grouping element based on the logical OR condition. public class OrElement : GroupElement Inheritance object RuleElement GroupElement OrElement Inherited Members GroupElement.ChildElements RuleElement.Exports RuleElement.Imports object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Extension Methods RuleElementExtensions.Match(GroupElement, Action<AndElement>, Action<OrElement>) RuleElementExtensions.Match(RuleElement, Action<PatternElement>, Action<AggregateElement>, Action<GroupElement>, Action<ExistsElement>, Action<NotElement>, Action<ForAllElement>) Properties ElementType Element type of this rule element. public override ElementType ElementType { get; } Property Value ElementType"
  },
  "api/NRules.RuleModel.PatternElement.html": {
    "href": "api/NRules.RuleModel.PatternElement.html",
    "title": "Class PatternElement | NRules",
    "keywords": "Class PatternElement Namespace NRules.RuleModel Assembly NRules.RuleModel.dll Rule element that represents a pattern that matches facts. public class PatternElement : RuleElement Inheritance object RuleElement PatternElement Inherited Members RuleElement.Exports RuleElement.Imports object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Extension Methods RuleElementExtensions.Match(RuleElement, Action<PatternElement>, Action<AggregateElement>, Action<GroupElement>, Action<ExistsElement>, Action<NotElement>, Action<ForAllElement>) Fields ConditionName public const string ConditionName = \"Condition\" Field Value string Properties Declaration Declaration that references the pattern. public Declaration Declaration { get; } Property Value Declaration ElementType Element type of this rule element. public override ElementType ElementType { get; } Property Value ElementType Expressions Expressions used by the pattern to match elements. public ExpressionCollection Expressions { get; } Property Value ExpressionCollection Source Optional pattern source element. public RuleElement Source { get; } Property Value RuleElement ValueType Type of the values that the pattern matches. public Type ValueType { get; } Property Value Type"
  },
  "api/NRules.RuleModel.PropertyMap.html": {
    "href": "api/NRules.RuleModel.PropertyMap.html",
    "title": "Class PropertyMap | NRules",
    "keywords": "Class PropertyMap Namespace NRules.RuleModel Assembly NRules.RuleModel.dll Readonly map of rule properties. public class PropertyMap : IEnumerable<RuleProperty>, IEnumerable Inheritance object PropertyMap Implements IEnumerable<RuleProperty> IEnumerable Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors PropertyMap(IEnumerable<RuleProperty>) Creates new map of rule properties. public PropertyMap(IEnumerable<RuleProperty> properties) Parameters properties IEnumerable<RuleProperty> Rule properties to put in the map. Properties Count Number of properties in the map. public int Count { get; } Property Value int this[string] Retrieves property by name. public object this[string name] { get; } Parameters name string Property name. Property Value object Matching property value. Methods GetEnumerator() Returns an enumerator for the contained rule properties. public IEnumerator<RuleProperty> GetEnumerator() Returns IEnumerator<RuleProperty> TryGetProperty(string, out RuleProperty) Retrieves property by name if it exists. public bool TryGetProperty(string name, out RuleProperty property) Parameters name string Property name. property RuleProperty Matching property if found. Returns bool If found true, otherwise false."
  },
  "api/NRules.RuleModel.RuleElement.html": {
    "href": "api/NRules.RuleModel.RuleElement.html",
    "title": "Class RuleElement | NRules",
    "keywords": "Class RuleElement Namespace NRules.RuleModel Assembly NRules.RuleModel.dll Base class for rule elements. public abstract class RuleElement Inheritance object RuleElement Derived ActionGroupElement AggregateElement DependencyElement DependencyGroupElement ExistsElement ExpressionElement FilterGroupElement ForAllElement GroupElement NotElement PatternElement Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Extension Methods RuleElementExtensions.Match(RuleElement, Action<PatternElement>, Action<AggregateElement>, Action<GroupElement>, Action<ExistsElement>, Action<NotElement>, Action<ForAllElement>) Properties ElementType Element type of this rule element. public abstract ElementType ElementType { get; } Property Value ElementType Exports Rule element declarations exported to the outer scope. public IEnumerable<Declaration> Exports { get; } Property Value IEnumerable<Declaration> Imports Rule element declarations imported from the outer scope. public IEnumerable<Declaration> Imports { get; } Property Value IEnumerable<Declaration>"
  },
  "api/NRules.RuleModel.RuleElementExtensions.html": {
    "href": "api/NRules.RuleModel.RuleElementExtensions.html",
    "title": "Class RuleElementExtensions | NRules",
    "keywords": "Class RuleElementExtensions Namespace NRules.RuleModel Assembly NRules.RuleModel.dll public static class RuleElementExtensions Inheritance object RuleElementExtensions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods Match(GroupElement, Action<AndElement>, Action<OrElement>) Matches a group element to an appropriate action based on the concrete type of the element. Type-safe implementation of discriminated union for group elements. public static void Match(this GroupElement element, Action<AndElement> and, Action<OrElement> or) Parameters element GroupElement Group element to match. and Action<AndElement> Action to invoke on the element if the element is a AndElement. or Action<OrElement> Action to invoke on the element if the element is a OrElement. Match(RuleElement, Action<PatternElement>, Action<AggregateElement>, Action<GroupElement>, Action<ExistsElement>, Action<NotElement>, Action<ForAllElement>) Matches a rule element to an appropriate action based on the concrete type of the element. Type-safe implementation of discriminated union for rule elements. public static void Match(this RuleElement element, Action<PatternElement> pattern, Action<AggregateElement> aggregate, Action<GroupElement> group, Action<ExistsElement> exists, Action<NotElement> not, Action<ForAllElement> forall) Parameters element RuleElement Rule element to match. pattern Action<PatternElement> Action to invoke on the element if the element is a PatternElement. aggregate Action<AggregateElement> Action to invoke on the element if the element is an AggregateElement. group Action<GroupElement> Action to invoke on the element if the element is a GroupElement. exists Action<ExistsElement> Action to invoke on the element if the element is an ExistsElement. not Action<NotElement> Action to invoke on the element if the element is a NotElement. forall Action<ForAllElement> Action to invoke on the element if the element is a ForAllElement."
  },
  "api/NRules.RuleModel.RuleElementVisitor-1.html": {
    "href": "api/NRules.RuleModel.RuleElementVisitor-1.html",
    "title": "Class RuleElementVisitor<TContext> | NRules",
    "keywords": "Class RuleElementVisitor<TContext> Namespace NRules.RuleModel Assembly NRules.RuleModel.dll Visitor to traverse rule definition (or its part). public class RuleElementVisitor<TContext> Type Parameters TContext Traversal context. Inheritance object RuleElementVisitor<TContext> Derived RuleTransformation Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods Visit(TContext, RuleElement) public void Visit(TContext context, RuleElement element) Parameters context TContext element RuleElement VisitAction(TContext, ActionElement) protected virtual void VisitAction(TContext context, ActionElement element) Parameters context TContext element ActionElement VisitActionGroup(TContext, ActionGroupElement) protected virtual void VisitActionGroup(TContext context, ActionGroupElement element) Parameters context TContext element ActionGroupElement VisitAggregate(TContext, AggregateElement) protected virtual void VisitAggregate(TContext context, AggregateElement element) Parameters context TContext element AggregateElement VisitAnd(TContext, AndElement) protected virtual void VisitAnd(TContext context, AndElement element) Parameters context TContext element AndElement VisitBinding(TContext, BindingElement) protected virtual void VisitBinding(TContext context, BindingElement element) Parameters context TContext element BindingElement VisitDependency(TContext, DependencyElement) protected virtual void VisitDependency(TContext context, DependencyElement element) Parameters context TContext element DependencyElement VisitDependencyGroup(TContext, DependencyGroupElement) protected virtual void VisitDependencyGroup(TContext context, DependencyGroupElement element) Parameters context TContext element DependencyGroupElement VisitExists(TContext, ExistsElement) protected virtual void VisitExists(TContext context, ExistsElement element) Parameters context TContext element ExistsElement VisitFilter(TContext, FilterElement) protected virtual void VisitFilter(TContext context, FilterElement element) Parameters context TContext element FilterElement VisitFilterGroup(TContext, FilterGroupElement) protected virtual void VisitFilterGroup(TContext context, FilterGroupElement element) Parameters context TContext element FilterGroupElement VisitForAll(TContext, ForAllElement) protected virtual void VisitForAll(TContext context, ForAllElement element) Parameters context TContext element ForAllElement VisitNamedExpression(TContext, NamedExpressionElement) protected virtual void VisitNamedExpression(TContext context, NamedExpressionElement element) Parameters context TContext element NamedExpressionElement VisitNot(TContext, NotElement) protected virtual void VisitNot(TContext context, NotElement element) Parameters context TContext element NotElement VisitOr(TContext, OrElement) protected virtual void VisitOr(TContext context, OrElement element) Parameters context TContext element OrElement VisitPattern(TContext, PatternElement) protected virtual void VisitPattern(TContext context, PatternElement element) Parameters context TContext element PatternElement"
  },
  "api/NRules.RuleModel.RuleProperty.html": {
    "href": "api/NRules.RuleModel.RuleProperty.html",
    "title": "Class RuleProperty | NRules",
    "keywords": "Class RuleProperty Namespace NRules.RuleModel Assembly NRules.RuleModel.dll Arbitrary value associated with a rule. public class RuleProperty Inheritance object RuleProperty Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors RuleProperty(string, object) Creates a new rule property. public RuleProperty(string name, object value) Parameters name string Rule property name. value object Rule property value. Properties Name Rule property name. public string Name { get; } Property Value string Value Rule property value. public object Value { get; } Property Value object"
  },
  "api/NRules.RuleModel.RuleRepeatability.html": {
    "href": "api/NRules.RuleModel.RuleRepeatability.html",
    "title": "Enum RuleRepeatability | NRules",
    "keywords": "Enum RuleRepeatability Namespace NRules.RuleModel Assembly NRules.RuleModel.dll Rule repeatability. public enum RuleRepeatability Fields Repeatable = 0 Rule will fire every time a matching set of facts is inserted or updated. NonRepeatable = 1 Rule will not fire with the same combination of facts, unless that combination was previously deactivated (i.e. through retraction)."
  },
  "api/NRules.RuleModel.RuleSet.html": {
    "href": "api/NRules.RuleModel.RuleSet.html",
    "title": "Class RuleSet | NRules",
    "keywords": "Class RuleSet Namespace NRules.RuleModel Assembly NRules.RuleModel.dll Default implementation of a rule set. public class RuleSet : IRuleSet Inheritance object RuleSet Implements IRuleSet Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Extension Methods RuleSetExtensions.Add(IRuleSet, IRuleDefinition) Constructors RuleSet(string) public RuleSet(string name) Parameters name string Properties Name Rule set name. public string Name { get; } Property Value string Rules Rules in the rule set. public IEnumerable<IRuleDefinition> Rules { get; } Property Value IEnumerable<IRuleDefinition> Methods Add(IEnumerable<IRuleDefinition>) Adds rules to the rule set. public void Add(IEnumerable<IRuleDefinition> ruleDefinitions) Parameters ruleDefinitions IEnumerable<IRuleDefinition> Rule definitions to add."
  },
  "api/NRules.RuleModel.RuleSetExtensions.html": {
    "href": "api/NRules.RuleModel.RuleSetExtensions.html",
    "title": "Class RuleSetExtensions | NRules",
    "keywords": "Class RuleSetExtensions Namespace NRules.RuleModel Assembly NRules.RuleModel.dll public static class RuleSetExtensions Inheritance object RuleSetExtensions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods Add(IRuleSet, IRuleDefinition) Adds a rule to the rule set. public static void Add(this IRuleSet ruleSet, IRuleDefinition ruleDefinition) Parameters ruleSet IRuleSet Rule set instance. ruleDefinition IRuleDefinition Rule definition to add."
  },
  "api/NRules.RuleModel.SortDirection.html": {
    "href": "api/NRules.RuleModel.SortDirection.html",
    "title": "Enum SortDirection | NRules",
    "keywords": "Enum SortDirection Namespace NRules.RuleModel Assembly NRules.RuleModel.dll Order that the sort should be performed in. public enum SortDirection Fields Ascending = 0 Sort in Ascending order. Descending = 1 Sort in Descending order."
  },
  "api/NRules.RuleModel.html": {
    "href": "api/NRules.RuleModel.html",
    "title": "Namespace NRules.RuleModel | NRules",
    "keywords": "Namespace NRules.RuleModel Contains types that represent rules in the canonical model form. Classes ActionElement Action executed by the engine when the rule fires. ActionGroupElement Rule element that groups actions that run when the rule fires. AggregateElement Rule element that creates new facts (aggregates) based on matching facts it receives as input. AndElement Grouping element based on the logical AND condition. BindingElement Rule element that represents results of an expression. Declaration Rule element declaration. DeclarationExtensions DependencyElement Dependency that the rule uses when its actions run. DependencyGroupElement Rule element that groups dependencies that the rule uses when its actions runs. ExistsElement Existential quantifier. ExpressionCollection Ordered readonly collection of named expressions. ExpressionElement Rule element that defines an expression. FilterElement Filter that determines which rule matches should trigger rule actions. FilterGroupElement Rule element that groups filters that determine which rule matches should trigger rule actions. ForAllElement Universal quantifier. GroupElement Grouping element that logically combines the patterns or other grouping elements. NamedExpressionElement Expression with a name used by an aggregator. NotElement Negative existential quantifier. OrElement Grouping element based on the logical OR condition. PatternElement Rule element that represents a pattern that matches facts. PropertyMap Readonly map of rule properties. RuleElement Base class for rule elements. RuleElementExtensions RuleElementVisitor<TContext> Visitor to traverse rule definition (or its part). RuleProperty Arbitrary value associated with a rule. RuleSet Default implementation of a rule set. RuleSetExtensions Interfaces IContext Rules engine execution context. Can be used by rules to interact with the rules engine, i.e. insert, update, retract facts. IFact Fact in the engine's working memory. IFactMatch Represents a fact matched by a rule. IFactSource Source of the fact, for synthetic facts. IKeyedLookup<TKey, TElement> Collection of facts grouped by a key. Exposes all keys present in the lookup as a Keys collection. IMatch Represents a match of all rule's conditions. IRuleDefinition Production rule definition in the canonical rule model. IRuleRepository In-memory database of production rules arranged into rule sets. IRuleSet IRuleSet Represents a named set of rules. ITuple Set of facts matched by the rules engine. Enums ActionTrigger Activation events that trigger the actions. ElementType Describes the element types for the elements of a rule definition. FactSourceType Type of source that produced the fact. FilterType Type of filter applied to rule matches. MatchTrigger Event that triggered the match. RuleRepeatability Rule repeatability. SortDirection Order that the sort should be performed in."
  },
  "api/NRules.RuleRepositoryExtensions.html": {
    "href": "api/NRules.RuleRepositoryExtensions.html",
    "title": "Class RuleRepositoryExtensions | NRules",
    "keywords": "Class RuleRepositoryExtensions Namespace NRules Assembly NRules.dll public static class RuleRepositoryExtensions Inheritance object RuleRepositoryExtensions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods Compile(IRuleRepository) Compiles all rules in the repository into a session factory. Use RuleCompiler explicitly if only need to compile a subset of rules. public static ISessionFactory Compile(this IRuleRepository repository) Parameters repository IRuleRepository Rule repository. Returns ISessionFactory Session factory. See Also RuleCompiler Compile(IRuleRepository, CancellationToken) Compiles all rules in the repository into a session factory. Use RuleCompiler explicitly if only need to compile a subset of rules. public static ISessionFactory Compile(this IRuleRepository repository, CancellationToken cancellationToken) Parameters repository IRuleRepository Rule repository. cancellationToken CancellationToken Enables cooperative cancellation of the rules compilation. Returns ISessionFactory Session factory. See Also RuleCompiler GetRules(IRuleRepository) Retrieves all rules from all rule sets contained in the repository. public static IEnumerable<IRuleDefinition> GetRules(this IRuleRepository repository) Parameters repository IRuleRepository Returns IEnumerable<IRuleDefinition> Collection of rules from the repository."
  },
  "api/NRules.RuleRhsExpressionEvaluationException.html": {
    "href": "api/NRules.RuleRhsExpressionEvaluationException.html",
    "title": "Class RuleRhsExpressionEvaluationException | NRules",
    "keywords": "Class RuleRhsExpressionEvaluationException Namespace NRules Assembly NRules.dll Represents errors that occur while evaluating rule right-hand side expression. [Serializable] public class RuleRhsExpressionEvaluationException : RuleExpressionEvaluationException, ISerializable Inheritance object Exception RuleExecutionException RuleExpressionEvaluationException RuleRhsExpressionEvaluationException Implements ISerializable Inherited Members RuleExpressionEvaluationException.Expression Exception.GetBaseException() Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState object.Equals(object) object.Equals(object, object) object.GetHashCode() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors RuleRhsExpressionEvaluationException(SerializationInfo, StreamingContext) protected RuleRhsExpressionEvaluationException(SerializationInfo info, StreamingContext context) Parameters info SerializationInfo context StreamingContext Properties Message Gets a message that describes the current exception. public override string Message { get; } Property Value string The error message that explains the reason for the exception, or an empty string (\"\"). RuleName Rule that caused exception. public string RuleName { get; } Property Value string Methods GetObjectData(SerializationInfo, StreamingContext) When overridden in a derived class, sets the SerializationInfo with information about the exception. [SecurityCritical] public override void GetObjectData(SerializationInfo info, StreamingContext context) Parameters info SerializationInfo The SerializationInfo that holds the serialized object data about the exception being thrown. context StreamingContext The StreamingContext that contains contextual information about the source or destination. Exceptions ArgumentNullException The info parameter is a null reference (Nothing in Visual Basic)."
  },
  "api/NRules.Testing.FactConstraint-1.html": {
    "href": "api/NRules.Testing.FactConstraint-1.html",
    "title": "Class FactConstraint<TFact> | NRules",
    "keywords": "Class FactConstraint<TFact> Namespace NRules.Testing Assembly NRules.Testing.dll Represents a strongly-typed constraint on facts matched by a rule. public abstract class FactConstraint<TFact> : FactConstraint Type Parameters TFact Inheritance object FactConstraint FactConstraint<TFact> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods Callback(Action<TFact>) Called with the corresponding fact when all rule firing fact constraints are satisfied. public FactConstraint<TFact> Callback(Action<TFact> callback) Parameters callback Action<TFact> The delegate to call. Returns FactConstraint<TFact>"
  },
  "api/NRules.Testing.FactConstraint.html": {
    "href": "api/NRules.Testing.FactConstraint.html",
    "title": "Class FactConstraint | NRules",
    "keywords": "Class FactConstraint Namespace NRules.Testing Assembly NRules.Testing.dll Represents a constraint on the facts matched by a rule. Fact constraints are used to configure rule firing expectations. public abstract class FactConstraint Inheritance object FactConstraint Derived FactConstraint<TFact> Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString()"
  },
  "api/NRules.Testing.IQualifiedRuleFiringVerification.html": {
    "href": "api/NRules.Testing.IQualifiedRuleFiringVerification.html",
    "title": "Interface IQualifiedRuleFiringVerification | NRules",
    "keywords": "Interface IQualifiedRuleFiringVerification Namespace NRules.Testing Assembly NRules.Testing.dll Represents specific rule firing verification that uses qualified rule firing expectations. public interface IQualifiedRuleFiringVerification : IRuleFiringVerification Inherited Members IRuleFiringVerification.Fired(params FactConstraint[]) Methods Fired(Times, params FactConstraint[]) Asserts that a given rule under test fired the given number of times with a set of facts matching the specified expectations. void Fired(Times times, params FactConstraint[] constraints) Parameters times Times Expected number of rule firings. constraints FactConstraint[] Constraints narrowing down the rule firing expectation."
  },
  "api/NRules.Testing.IRuleAsserter.html": {
    "href": "api/NRules.Testing.IRuleAsserter.html",
    "title": "Interface IRuleAsserter | NRules",
    "keywords": "Interface IRuleAsserter Namespace NRules.Testing Assembly NRules.Testing.dll Abstracts assertion logic for the specific testing/assertion framework. public interface IRuleAsserter Methods Assert(RuleAssertResult) Asserts a condition specific to rule firing. void Assert(RuleAssertResult result) Parameters result RuleAssertResult Result that needs to be verified. See Also RuleAssertResult"
  },
  "api/NRules.Testing.IRuleFiringVerification.html": {
    "href": "api/NRules.Testing.IRuleFiringVerification.html",
    "title": "Interface IRuleFiringVerification | NRules",
    "keywords": "Interface IRuleFiringVerification Namespace NRules.Testing Assembly NRules.Testing.dll Represents specific rule firing verification. public interface IRuleFiringVerification Methods Fired(params FactConstraint[]) Asserts that a given rule under test fired with a set of facts matching the specified expectations. void Fired(params FactConstraint[] constraints) Parameters constraints FactConstraint[] Constraints narrowing down the rule firing expectation."
  },
  "api/NRules.Testing.IRuleInvocationRecorder.html": {
    "href": "api/NRules.Testing.IRuleInvocationRecorder.html",
    "title": "Interface IRuleInvocationRecorder | NRules",
    "keywords": "Interface IRuleInvocationRecorder Namespace NRules.Testing Assembly NRules.Testing.dll Controls the recording of rule invocations and provides access to the recorded invocations. public interface IRuleInvocationRecorder Methods Clear() Clears all recorded invocations. void Clear() GetInvocations() Gets all recorded invocations. IReadOnlyList<IMatch> GetInvocations() Returns IReadOnlyList<IMatch> Pause() Pauses recording of rule invocations. void Pause() Resume() Resumes recording of rule invocations. void Resume()"
  },
  "api/NRules.Testing.IRuleSequenceFiringVerification.html": {
    "href": "api/NRules.Testing.IRuleSequenceFiringVerification.html",
    "title": "Interface IRuleSequenceFiringVerification | NRules",
    "keywords": "Interface IRuleSequenceFiringVerification Namespace NRules.Testing Assembly NRules.Testing.dll Fluent interface to build specific rule invocation verification. public interface IRuleSequenceFiringVerification : IRulesFiringVerification<IRuleFiringVerification> Inherited Members IRulesFiringVerification<IRuleFiringVerification>.Rule() IRulesFiringVerification<IRuleFiringVerification>.Rule<TRule>() IRulesFiringVerification<IRuleFiringVerification>.Rule(Type)"
  },
  "api/NRules.Testing.IRulesFiringVerification-1.html": {
    "href": "api/NRules.Testing.IRulesFiringVerification-1.html",
    "title": "Interface IRulesFiringVerification<TVerification> | NRules",
    "keywords": "Interface IRulesFiringVerification<TVerification> Namespace NRules.Testing Assembly NRules.Testing.dll Fluent interface to build rules verification. public interface IRulesFiringVerification<out TVerification> Type Parameters TVerification Methods Rule() Single registered rule under test. TVerification Rule() Returns TVerification Specific rule verification builder. Rule(Type) Registered rule under test with the specifies rule type. Call this if you have multiple registered rules under test, or want to be specific. TVerification Rule(Type ruleType) Parameters ruleType Type Type of the rule to look for. Returns TVerification Specific rule verification builder. Rule<TRule>() Registered rule under test with the specifies rule type. Call this if you have multiple registered rules under test, or want to be specific. TVerification Rule<TRule>() where TRule : Rule Returns TVerification Specific rule verification builder. Type Parameters TRule Type of the rule to look for."
  },
  "api/NRules.Testing.IRulesFiringVerification.html": {
    "href": "api/NRules.Testing.IRulesFiringVerification.html",
    "title": "Interface IRulesFiringVerification | NRules",
    "keywords": "Interface IRulesFiringVerification Namespace NRules.Testing Assembly NRules.Testing.dll Fluent interface to build specific rule invocation verification. public interface IRulesFiringVerification : IRulesFiringVerification<IQualifiedRuleFiringVerification> Inherited Members IRulesFiringVerification<IQualifiedRuleFiringVerification>.Rule() IRulesFiringVerification<IQualifiedRuleFiringVerification>.Rule<TRule>() IRulesFiringVerification<IQualifiedRuleFiringVerification>.Rule(Type)"
  },
  "api/NRules.Testing.IRulesTestSetup.html": {
    "href": "api/NRules.Testing.IRulesTestSetup.html",
    "title": "Interface IRulesTestSetup | NRules",
    "keywords": "Interface IRulesTestSetup Namespace NRules.Testing Assembly NRules.Testing.dll Sets up rules test. public interface IRulesTestSetup Properties CompilerSetupAction Gets or sets the action to apply when creating the RuleCompiler. Action<RuleCompiler> CompilerSetupAction { get; set; } Property Value Action<RuleCompiler> Rules Rules under test. IReadOnlyCollection<RuleInfo> Rules { get; } Property Value IReadOnlyCollection<RuleInfo> Methods Rule(Rule) Adds specific rule under test to the setup. void Rule(Rule ruleInstance) Parameters ruleInstance Rule Rule instance to add. Rule(Type) Adds specific rule under test to the setup. void Rule(Type ruleType) Parameters ruleType Type Type of the rule to add. Remarks If ruleType is not derived from Rule or is not concrete, it will be ignored. Rule<T>() Adds specific rule under test to the setup. void Rule<T>() where T : Rule Type Parameters T Type of the rule to add. Remarks If T is not concrete, it will be ignored"
  },
  "api/NRules.Testing.IRulesUnderTest.html": {
    "href": "api/NRules.Testing.IRulesUnderTest.html",
    "title": "Interface IRulesUnderTest | NRules",
    "keywords": "Interface IRulesUnderTest Namespace NRules.Testing Assembly NRules.Testing.dll Represents the rules under test. public interface IRulesUnderTest Properties Rules Gets the rules under test. IReadOnlyCollection<RuleInfo> Rules { get; } Property Value IReadOnlyCollection<RuleInfo> Methods GetRuleInfo(Type) Gets the rule information for the specified rule type. RuleInfo GetRuleInfo(Type ruleType) Parameters ruleType Type Type of the rule to look for. Returns RuleInfo Found rule. GetSingle() Gets the rule information for the single rule under test. RuleInfo GetSingle() Returns RuleInfo Found rule."
  },
  "api/NRules.Testing.IRulesVerification.html": {
    "href": "api/NRules.Testing.IRulesVerification.html",
    "title": "Interface IRulesVerification | NRules",
    "keywords": "Interface IRulesVerification Namespace NRules.Testing Assembly NRules.Testing.dll Verifies recorded rules invocations against expectations. public interface IRulesVerification Methods Verify(Action<IRulesFiringVerification>) Verifies that the rules under test fired with a set of facts matching the specified expectations. RuleAssertResult Verify(Action<IRulesFiringVerification> action) Parameters action Action<IRulesFiringVerification> Expectations configuration action. Returns RuleAssertResult Outcome of validation of recorded rule invocations against the provided expectations. Remarks Recorded rule invocations are compared to expectations according to the expected number of invocations for each rule, specified using Times. VerifySequence(Action<IRuleSequenceFiringVerification>) Verifies that the rules under test fired with a set of facts matching the specified expectations. RuleAssertResult VerifySequence(Action<IRuleSequenceFiringVerification> action) Parameters action Action<IRuleSequenceFiringVerification> Expectations configuration action. Returns RuleAssertResult Outcome of validation of recorded rule invocations against the provided expectations. Remarks Recorded rule invocations are compared to expectations one by one."
  },
  "api/NRules.Testing.Matched.html": {
    "href": "api/NRules.Testing.Matched.html",
    "title": "Class Matched | NRules",
    "keywords": "Class Matched Namespace NRules.Testing Assembly NRules.Testing.dll Fluent builder for specifying fact constraints in a rule firing expectation. public static class Matched Inheritance object Matched Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods Fact<TFact>() Creates a constraint that the matched fact is of the specified type. public static FactConstraint<TFact> Fact<TFact>() Returns FactConstraint<TFact> Type Parameters TFact Type of the matched fact. Fact<TFact>(Expression<Func<TFact, bool>>) Creates a constraint that the matched fact satisfies the specified predicate. public static FactConstraint<TFact> Fact<TFact>(Expression<Func<TFact, bool>> predicateExpression) Parameters predicateExpression Expression<Func<TFact, bool>> Predicate that the matched fact must satisfy. Returns FactConstraint<TFact> Type Parameters TFact Type of the matched fact. Fact<TFact>(TFact) Creates a constraint that the matched fact is equal to the specified value. public static FactConstraint<TFact> Fact<TFact>(TFact factValue) Parameters factValue TFact Value that the matched fact must be equal to. Returns FactConstraint<TFact> Type Parameters TFact Type of the matched fact."
  },
  "api/NRules.Testing.RuleAssertResult.html": {
    "href": "api/NRules.Testing.RuleAssertResult.html",
    "title": "Class RuleAssertResult | NRules",
    "keywords": "Class RuleAssertResult Namespace NRules.Testing Assembly NRules.Testing.dll Represents the result for a rule firing assertion. public sealed class RuleAssertResult Inheritance object RuleAssertResult Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.ReferenceEquals(object, object) object.ToString() Constructors RuleAssertResult(string, RuleAssertStatus, string, object, object) Initializes a new instance of the RuleAssertResult class. public RuleAssertResult(string ruleName, RuleAssertStatus status, string assertionText, object expected, object actual) Parameters ruleName string Name of the rule corresponding to the assertion. status RuleAssertStatus Assertion outcome. assertionText string Text that describes the assertion. expected object Expected outcome. actual object Actual outcome. Properties Actual Gets the actual assertion outcome. public object Actual { get; } Property Value object AssertionText Gets the text that describes the assertion. public string AssertionText { get; } Property Value string Expected Gets the expected assertion outcome. public object Expected { get; } Property Value object RuleName Gets the name of the rule corresponding to the assertion. public string RuleName { get; } Property Value string Status Gets the rule assertion outcome. public RuleAssertStatus Status { get; } Property Value RuleAssertStatus Methods GetMessage() Gets the message that describes the assertion outcome. public string GetMessage() Returns string"
  },
  "api/NRules.Testing.RuleAssertStatus.html": {
    "href": "api/NRules.Testing.RuleAssertStatus.html",
    "title": "Enum RuleAssertStatus | NRules",
    "keywords": "Enum RuleAssertStatus Namespace NRules.Testing Assembly NRules.Testing.dll Represents assertion outcome (pass/fail). public enum RuleAssertStatus Fields Passed = 0 Rule assertion passed. Failed = 1 Rule assertion failed."
  },
  "api/NRules.Testing.RuleInfo.html": {
    "href": "api/NRules.Testing.RuleInfo.html",
    "title": "Struct RuleInfo | NRules",
    "keywords": "Struct RuleInfo Namespace NRules.Testing Assembly NRules.Testing.dll Information about a rule under test. public struct RuleInfo Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors RuleInfo(Type, object, IRuleDefinition) Initializes a new instance of the RuleInfo class. public RuleInfo(Type type, object instance, IRuleDefinition definition) Parameters type Type CLR type that contains rule's definition using Fluent DSL. instance object Instance of the rule's type. definition IRuleDefinition Rule's definition in a canonical form. Properties Definition Rule's definition. public readonly IRuleDefinition Definition { get; } Property Value IRuleDefinition Instance Instance of the rule's type. public readonly object Instance { get; } Property Value object Type CLR type that contains rule's definition using Fluent DSL. public readonly Type Type { get; } Property Value Type"
  },
  "api/NRules.Testing.RulesTestFixture.html": {
    "href": "api/NRules.Testing.RulesTestFixture.html",
    "title": "Class RulesTestFixture | NRules",
    "keywords": "Class RulesTestFixture Namespace NRules.Testing Assembly NRules.Testing.dll Fixture to test rules. public class RulesTestFixture Inheritance object RulesTestFixture Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors RulesTestFixture() Initializes a new instance of the RulesTestFixture class. public RulesTestFixture() Properties Asserter Gets or sets the framework-specific asserter to validate rule firing expectations. public IRuleAsserter Asserter { get; set; } Property Value IRuleAsserter Recorder Gets the rule invocation recorder to inspect rule firing. public IRuleInvocationRecorder Recorder { get; } Property Value IRuleInvocationRecorder Session Gets the current rules engine session. public ISession Session { get; } Property Value ISession Setup Gets the test setup to register rules under test. public IRulesTestSetup Setup { get; } Property Value IRulesTestSetup Methods Verify(Action<IRulesFiringVerification>) Configures assertions for rules firing using an expectation builder. public void Verify(Action<IRulesFiringVerification> buildAction) Parameters buildAction Action<IRulesFiringVerification> VerifySequence(Action<IRuleSequenceFiringVerification>) Configures assertions of the exact rules firing sequence using an expectation builder. public void VerifySequence(Action<IRuleSequenceFiringVerification> buildAction) Parameters buildAction Action<IRuleSequenceFiringVerification>"
  },
  "api/NRules.Testing.RulesTestHarness.html": {
    "href": "api/NRules.Testing.RulesTestHarness.html",
    "title": "Class RulesTestHarness | NRules",
    "keywords": "Class RulesTestHarness Namespace NRules.Testing Assembly NRules.Testing.dll Rules under test compiled into a rules engine session along with the means to verify rules firing. public class RulesTestHarness Inheritance object RulesTestHarness Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors RulesTestHarness(IRulesTestSetup) Initializes a new instance of the RulesTestHarness class. public RulesTestHarness(IRulesTestSetup setup) Parameters setup IRulesTestSetup Rules test setup information. Properties Recorder Gets the rule invocation recorder to control and inspect rules firing. public IRuleInvocationRecorder Recorder { get; } Property Value IRuleInvocationRecorder RuleSet Gets the rules under test. public IRulesUnderTest RuleSet { get; } Property Value IRulesUnderTest Session Gets the current rules engine session. public ISession Session { get; } Property Value ISession Remarks Lazily created Methods GetRulesVerification() Creates a rules verification builder to check rules firing expectations. public IRulesVerification GetRulesVerification() Returns IRulesVerification Instance of the verification builder."
  },
  "api/NRules.Testing.Times.html": {
    "href": "api/NRules.Testing.Times.html",
    "title": "Struct Times | NRules",
    "keywords": "Struct Times Namespace NRules.Testing Assembly NRules.Testing.dll Fluent builder for specifying the number of rule invocations in a rule firing expectation. public struct Times Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Properties Never Rule should never fire. public static Times Never { get; } Property Value Times Once Rule should fire exactly once. public static Times Once { get; } Property Value Times Twice Rule should fire exactly twice. public static Times Twice { get; } Property Value Times Methods Exactly(int) Rule should fire exactly the specified number of times. public static Times Exactly(int value) Parameters value int Number of times the rule is expected to fire. Returns Times"
  },
  "api/NRules.Testing.html": {
    "href": "api/NRules.Testing.html",
    "title": "Namespace NRules.Testing | NRules",
    "keywords": "Namespace NRules.Testing Contains types that enable testing of rules authored using internal DSL. Classes FactConstraint Represents a constraint on the facts matched by a rule. Fact constraints are used to configure rule firing expectations. FactConstraint<TFact> Represents a strongly-typed constraint on facts matched by a rule. Matched Fluent builder for specifying fact constraints in a rule firing expectation. RuleAssertResult Represents the result for a rule firing assertion. RulesTestFixture Fixture to test rules. RulesTestHarness Rules under test compiled into a rules engine session along with the means to verify rules firing. Structs RuleInfo Information about a rule under test. Times Fluent builder for specifying the number of rule invocations in a rule firing expectation. Interfaces IQualifiedRuleFiringVerification Represents specific rule firing verification that uses qualified rule firing expectations. IRuleAsserter Abstracts assertion logic for the specific testing/assertion framework. IRuleFiringVerification Represents specific rule firing verification. IRuleInvocationRecorder Controls the recording of rule invocations and provides access to the recorded invocations. IRuleSequenceFiringVerification Fluent interface to build specific rule invocation verification. IRulesFiringVerification Fluent interface to build specific rule invocation verification. IRulesFiringVerification<TVerification> Fluent interface to build rules verification. IRulesTestSetup Sets up rules test. IRulesUnderTest Represents the rules under test. IRulesVerification Verifies recorded rules invocations against expectations. Enums RuleAssertStatus Represents assertion outcome (pass/fail)."
  },
  "api/NRules.html": {
    "href": "api/NRules.html",
    "title": "Namespace NRules | NRules",
    "keywords": "Namespace NRules Contains types that implement runtime components of the rules engine. Classes Activation Represents a match of all rule's conditions. AgendaExpressionEvaluationException Represents errors that occur while evaluating agenda expression. RuleCompilationException Represents errors that occur while compiling a rule. RuleCompiler Compiles rules in a canonical rule model form into an executable representation. RuleCompilerOptions Provides options to alter default behavior of RuleCompiler. RuleExecutionException Represents errors that occur during rules execution. RuleExpressionEvaluationException Represents errors that occur while evaluating expressions as part of rules execution. RuleLhsExpressionEvaluationException Represents errors that occur while evaluating rule left-hand side expression. RuleRepositoryExtensions RuleRhsExpressionEvaluationException Represents errors that occur while evaluating rule right-hand side expression. Interfaces IAgenda Agenda stores matches between rules and facts. These matches are called activations. Multiple activations are ordered according to the conflict resolution strategy. IFactResult Result of an operation on a set of facts. ILinkedFactSet Collection of linked facts propagated as a set. ILinkedFactSource Fact source for linked facts. ISession Represents a rules engine session. Created by ISessionFactory. Each session has its own working memory, and exposes operations that manipulate facts in it, as well as fire matching rules. ISessionFactory Represents compiled production rules that can be used to create rules sessions. Created by RuleCompiler by compiling rule model into an executable form. Enums BatchOptions Defines how batch insert/update/retract of facts behaves. Any fact that already exists in the session during insert is considered failed. Similarly, a fact that does not exist in the session during update or retract is also considered failed. By default, any failed fact in a batch operation fails the whole operation, and no facts are propagated. This behavior can be changed using BatchOptions. LinkedFactAction Action taken on the linked fact. RuleCompilerUnsupportedExpressionsHandling Defines different modes of handling of unsupported types of lambda expressions when the compiler is comparing them for the purpose of node sharing in the Rete graph."
  },
  "api/index.html": {
    "href": "api/index.html",
    "title": "NRules API Documentation | NRules",
    "keywords": "NRules API Documentation Use the navigation bar to find the specific types from the NRules API."
  },
  "articles/advanced/action-interceptor.html": {
    "href": "articles/advanced/action-interceptor.html",
    "title": "AOP with Action Interceptor | NRules",
    "keywords": "AOP with Action Interceptor NRules allows extending rules actions through aspect-oriented programming via an action interceptor. Normally, when a rule fires, NRules simply executes its actions. But if action interceptor is provided to NRules then it instead gives control to the interceptor, which can add pre- and post-processing to the actions or can even choose to not execute actions at all. When action interceptor receives control, it has access to the firing rule's definition, facts matched by the rule and has ability to invoke the actions. To create an action interceptor, create a class that implements IActionInterceptor interface and assign its instance to the ISessionFactory.ActionInterceptor or to the ISession.ActionInterceptor property. Example of an action interceptor that prints out the name of the firing rule and values of the matched facts, as well as adds error handling: public class ActionInterceptor : IActionInterceptor { public void Intercept(IContext context, IEnumerable<IActionInvocation> actions) { Console.WriteLine($\"Firing rule. Name={context.Rule.Name}\"); Console.WriteLine($\"Matched facts. Facts={string.Join(\",\", context.Match.Facts.Select(x => x.Value))}\"); try { foreach (var action in actions) { action.Invoke(); } } catch (Exception e) { Console.WriteLine($\"Rule execution failed. Name={context.Rule.Name} Exception={e.Message}\"); } } } Then use the created action interceptor with the rules session: var session = factory.CreateSession(); session.ActionInterceptor = new ActionInterceptor();"
  },
  "articles/advanced/expression-compiler.html": {
    "href": "articles/advanced/expression-compiler.html",
    "title": "Custom Expression Compiler | NRules",
    "keywords": "Custom Expression Compiler In NRules, rules conditions and other expressions are represented as lambda expression trees, which are then compiled to executable delegates by the RuleCompiler. By default, RuleCompiler uses the standard .NET Expression.Compile method. But it also exposes an extensibility point to customize the expression compilation process. To use a custom expression compiler, implement IExpressionCompiler interface and assign its instance to the RuleCompiler.ExpressionCompiler property. Example of using FastExpressionCompiler with NRules: using FastExpressionCompiler; public class FastExpressionCompiler : NRules.Extensibility.IExpressionCompiler { public TDelegate Compile<TDelegate>(Expression<TDelegate> expression) where TDelegate : Delegate { return expression.CompileFast(); } } And use the created expression compiler for rules compilation: var repository = new RuleRepository(); //Load rules var compiler = new RuleCompiler(); compiler.ExpressionCompiler = new FastExpressionCompiler(); var factory = compiler.Compile(repository.GetRuleSets());"
  },
  "articles/advanced/json-serialization.html": {
    "href": "articles/advanced/json-serialization.html",
    "title": "Storing Rules in JSON Format | NRules",
    "keywords": "Storing Rules in JSON Format Normally, rules in NRules are written using a DSL in C#. They are then converted into a canonical model (AST), which is then compiled to an executable model (Rete network). However, with the help of NRules.Json library the canonical rules model can also be serialized into JSON and deserialized from it. This could be useful in scenarios where rules need to be externalized from the application in a textual form. Serializing and Deserializing Rules NRules.Json uses JsonSerializer from System.Text.Json for serialization, so to make it work you need to set up an instance of JsonSerializerOptions, such that it knows how to serialize/deserialize NRules types. ⚠️ Serialization/deserialization of code and CLR types has an associated intrinsic security risk. Care must be taken to not deserialize rules from untrusted sources. In the simplest form, serialization/deserialization code looks like this: IRuleDefinition rule = BuildRule(); //Set up JsonSerializerOptions var options = new JsonSerializerOptions { WriteIndented = true, PropertyNamingPolicy = JsonNamingPolicy.CamelCase, }; RuleSerializer.Setup(options); //Serialize a rule into JSON var json = JsonSerializer.Serialize(rule, options); //Deserialize a rule from JSON var ruleClone = JsonSerializer.Deserialize<IRuleDefinition>(json, options); Type Serialization While the above code works, the default serialization of CLR type names is quite verbose, e.g. System.Console, System.Console, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a. You can use the TypeResolver to configure aliases for known types, and pass it to the serializer setup method. var typeResolver = new TypeResolver(); typeResolver.RegisterDefaultAliases(); typeResolver.RegisterAlias(\"Customer\", typeof(Customer)); typeResolver.RegisterAlias(\"Order\", typeof(Order)); typeResolver.RegisterAlias(\"Context\", typeof(IContext)); typeResolver.RegisterAlias(\"Console\", typeof(Console)); RuleSerializer.Setup(options, typeResolver); You can also take full control of the type name serialization/deserialization by implementing a custom ITypeResolver. Example Rule in JSON Here is an example of a rule in JSON format, serialized with the above options. See samples for full details. { \"name\": \"John Do Large Order Rule\", \"leftHandSide\": { \"elementType\": \"And\", \"childElements\": [ { \"elementType\": \"Pattern\", \"name\": \"customer\", \"type\": \"Customer\", \"expressions\": [ { \"name\": \"Condition\", \"expression\": { \"nodeType\": \"Lambda\", \"parameters\": [ { \"name\": \"customer\", \"type\": \"Customer\" } ], \"body\": { \"nodeType\": \"Equal\", \"left\": { \"nodeType\": \"MemberAccess\", \"memberType\": \"Property\", \"name\": \"Name\", \"declaringType\": \"Customer\", \"expression\": { \"nodeType\": \"Parameter\", \"name\": \"customer\", \"type\": \"Customer\" } }, \"right\": { \"nodeType\": \"Constant\", \"type\": \"string\", \"value\": \"John Do\" } } } } ] }, { \"elementType\": \"Pattern\", \"name\": \"order\", \"type\": \"Order\", \"expressions\": [ { \"name\": \"Condition\", \"expression\": { \"nodeType\": \"Lambda\", \"parameters\": [ { \"name\": \"order\", \"type\": \"Order\" }, { \"name\": \"customer\", \"type\": \"Customer\" } ], \"body\": { \"nodeType\": \"Equal\", \"left\": { \"nodeType\": \"MemberAccess\", \"memberType\": \"Property\", \"name\": \"Customer\", \"declaringType\": \"Order\", \"expression\": { \"nodeType\": \"Parameter\", \"name\": \"order\", \"type\": \"Order\" } }, \"right\": { \"nodeType\": \"Parameter\", \"name\": \"customer\", \"type\": \"Customer\" } } } }, { \"name\": \"Condition\", \"expression\": { \"nodeType\": \"Lambda\", \"parameters\": [ { \"name\": \"order\", \"type\": \"Order\" } ], \"body\": { \"nodeType\": \"GreaterThan\", \"left\": { \"nodeType\": \"MemberAccess\", \"memberType\": \"Property\", \"name\": \"Amount\", \"declaringType\": \"Order\", \"expression\": { \"nodeType\": \"Parameter\", \"name\": \"order\", \"type\": \"Order\" } }, \"right\": { \"nodeType\": \"Constant\", \"type\": \"double\", \"value\": 100 } } } } ] } ] }, \"rightHandSide\": [ { \"expression\": { \"nodeType\": \"Lambda\", \"parameters\": [ { \"name\": \"ctx\", \"type\": \"Context\" } ], \"body\": { \"nodeType\": \"Call\", \"methodName\": \"WriteLine\", \"declaringType\": \"Console\", \"arguments\": [ { \"nodeType\": \"Constant\", \"type\": \"string\", \"value\": \"Found large order\" } ] } } } ] }"
  },
  "articles/advanced/rule-builder.html": {
    "href": "articles/advanced/rule-builder.html",
    "title": "Creating Rules at Runtime with the RuleBuilder | NRules",
    "keywords": "Creating Rules at Runtime with the RuleBuilder As described on the Architecture page, rules are represented in NRules in several different forms. One of these forms is a canonical model (rule model) that can be compiled into the executable model. The standard way to create rules in NRules is with the internal DSL using fluent API, which requires rules to be known at compile time. But this is not the only way rules can be created. Rule builder is a component specifically designed to create rules at runtime, and in fact is the underlying mechanism behind fluent API. RuleBuilder class and related classes reside in the NRules.RuleModel namespace. ⚠️ Unlike fluent API, canonical model and rule builder are not strongly typed, so you will need to ensure type safety and correctness yourself (or face runtime errors if you don't). When building rules at runtime, you will need a place to store them. Such a store is represented by the IRuleRepository interface, so you will need to implement it to load rules from a user-defined source. A rule repository is an in-memory database of rule definitions, organized into rule sets (IRuleSet), that encapsulates the process of turning rules in whatever form to the canonical model. public class CustomRuleRepository : IRuleRepository { private readonly IRuleSet _ruleSet = new RuleSet(\"MyRuleSet\"); public IEnumerable<IRuleSet> GetRuleSets() { return new[] {_ruleSet}; } public void LoadRules() { //Assuming there is only one rule in this example var rule = BuildRule(); _ruleSet.Add(new []{rule}); } private IRuleDefinition BuildRule() { //... } } We will use a simple contrived domain model for our custom rule. public class Customer { public Customer(string name) { Name = name; } public string Name { get; private set; } } public class Order { public Order(Customer customer, decimal amount) { Customer = customer; Amount = amount; } public Customer Customer { get; private set; } public decimal Amount { get; private set; } } Now let's implement that CustomRuleRepository.BuildRule method. We will create the following rule: Name TestRule When Customer name is John Do And this customer has an order in the amount > $100 Then Print customer's name and order amount Here is the code private IRuleDefinition BuildRule() { //Create rule builder var builder = new RuleBuilder(); builder.Name(\"TestRule\"); //Build conditions PatternBuilder customerPattern = builder.LeftHandSide().Pattern(typeof (Customer), \"customer\"); Expression<Func<Customer, bool>> customerCondition = customer => customer.Name == \"John Do\"; customerPattern.Condition(customerCondition); PatternBuilder orderPattern = builder.LeftHandSide().Pattern(typeof (Order), \"order\"); Expression<Func<Order, Customer, bool>> orderCondition1 = (order, customer) => order.Customer == customer; Expression<Func<Order, bool>> orderCondition2 = order => order.Amount > 100.00m; orderPattern.Condition(orderCondition1); orderPattern.Condition(orderCondition2); //Build actions Expression<Action<IContext, Customer, Order>> action = (ctx, customer, order) => Console.WriteLine(\"Customer {0} has an order in amount of ${1}\", customer.Name, order.Amount); builder.RightHandSide().Action(action); //Build rule model return builder.Build(); } A few notes about rule builder code. A condition expression may only reference parameters that correspond to patterns that have been previously defined (using Pattern method). Names and types of the lambda expression parameters matter and must match the names and types defined in the patterns. The first argument of action expression must be of type IContext. You can use IContext to interact with the engine (i.e. insert new facts). Lambda expressions don't have to be defined at compile time. Use various static methods on the BCL's Expression class to compose expression trees at runtime. Putting this all together, here is the test code. var repository = new CustomRuleRepository(); repository.LoadRules(); ISessionFactory factory = repository.Compile(); ISession session = factory.CreateSession(); var customer = new Customer(\"John Do\"); session.Insert(customer); session.Insert(new Order(customer, 90.00m)); session.Insert(new Order(customer, 110.00m)); session.Fire();"
  },
  "articles/agenda-filters.html": {
    "href": "articles/agenda-filters.html",
    "title": "Agenda Filters | NRules",
    "keywords": "Agenda Filters When all rule's conditions are satisfied by a set of facts, the rule is said to be activated by those facts. A rule can be activated by a new set of matching facts, or an updated existing set of matching facts. When a rule is activated, the activation (rule, plus the matching set of facts) is placed on the agenda. Once all activations are calculated, the activation with the highest priority is chosen, the rule fires, and all its actions are executed. Agenda filters allow applying a set of conditions to activations, before those are placed on the agenda. If an activation passes all the filters, it is placed on the agenda, otherwise it's not. Agenda filters could be a good place to dynamically enable/disable the rules, filter fact updates to activate on a subset of changed values, etc. An already activated rule whose agenda filter evaluates to false will not re-fire, but its activation will not be retracted, as is the case when a condition on the left-hand side of the rule evaluates to false. This makes agenda filters useful for forward chaining rules, since they allow re-firing logic to be distinct from activation/retraction logic. Agenda filters can be registered in two different ways - as global or as rule-specific filters. A global agenda filter is applied to all activations, while a rule-specific filter is only applied to activations of a particular rule. Agenda filters only apply to activations that are about to be placed on the agenda, so filters will never remove activations that are already on the agenda. Fluent Rule Filters Rule-specific agenda filters can be added declaratively, using fluent DSL. There are two kinds of filters that can be defined with the fluent DSL - predicate filters that test rule activation against a set of conditions, and change filters that only accept activations where a particular set of keys changed. Change filters in particular are extremely useful for rule chaining and recursion control. One rule may change one field in the fact and another rule may change a different field in that same fact. Without a change filter, each rule would chain the other one, causing infinite recursion. With change filters both rules can only accept fact changes they care about, thus improving rules composability and eliminating unwanted recursion. public class OrderAmountCalculationRule : Rule { public override void Define() { Order order = null; When() .Match(() => order); Filter() .OnChange(() => order.Quantity, () => order.UnitPrice, () => order.PercentDiscount) .Where(() => order.Quantity > 0); Then() .Do(ctx => ctx.Update(order, CalculateAmount)); } private static void CalculateAmount(Order order) { order.Amount = order.UnitPrice * order.Quantity * (1.0 - order.PercentDiscount / 100.0); } } This rule will fire the first time a given order is matched, and then subsequently if its Quantity, UnitPrice or PercentDiscount changes (OnChange filter). This rule will never fire on an order whose Quantity is less than or equal to zero (Where filter). The ordering of filter conditions doesn't matter. Multiple Where filters are always interpreted to have an AND relationship, whereas OnChange filters have an OR. If both Where and OnChange filters are defined, the relationship is (Where1 AND Where2 AND (OnChange1 OR OnChange2)). Defining Rule Filters in Code An agenda filter can be defined as a class that implements IAgendaFilter interface; its Accept method determines if the activation is to be added to the agenda or not. Agenda filters are added to the ISession.Agenda using AddFilter methods. Depending on the specific overload of the method used, the filter is added either as a global or rule-specific filter. public class DisabledRuleFilter : IAgendaFilter { public bool Accept(Activation activation) { if (activation.Rule.Tags.Contains(\"Disabled\")) return false; return true; } } //... var filter = new DisabledRuleFilter(); var session = factory.CreateSession(x => x.Agenda.AddFilter(filter)); Stateful Agenda Filters In most cases agenda filters are only concerned with the activation that is getting inserted into the agenda, and so are stateless. But there are cases where it's helpful for an agenda filter to store some state about the activation, so that the next time the same activation is inserted into the agenda, the filter can use that state information. In these cases, instead of implementing IAgendaFilter interface, implement IStatefulAgendaFilter. This is how OnChange filters are implemented. In addition to the Accept method, stateful agenda filters are also notified by the engine of various activation lifecycle events, so that the filter can update the state, or remove the state associated with the activation."
  },
  "articles/architecture.html": {
    "href": "articles/architecture.html",
    "title": "Architecture | NRules",
    "keywords": "Architecture NRules engine consists of several components, and is designed in a way that more components and tools will be layered on top of it, augmenting its functionality and expanding its area of applicability. The central part of any rules engine is rules, and they can exist in many different forms. First, rules exist in a form in which they are written, which in case of NRules is internal DSL that uses fluent API. One of the design goals behind NRules is to support more than one rules language, and so internal DSL is translated into a canonical form. In the future other languages can be translated to the same canonical form. The canonical rules model is akin to an abstract syntax tree (AST) in the world of compilers/DSL design. In this form rules are represented as data that can be analysed, viewed, reported on and, most importantly, compiled to an executable form. Executable rules model is a run-time representation of rules that can efficiently interact with the rest of the application. NRules is a production rules engine and its executable form is a rete network, that can very efficiently find matches between facts and rules. NRules.Fluent namespace contains classes that enable declaratively authoring rules using internal DSL, which is a fluent C# API. A RuleRepository is then used to scan assemblies to discover rules and interact with RuleBuilder to translate them into their canonical form. NRules.RuleModel namespace contains classes that represent rules as a canonical model. At this level rules are a collection of rule sets, each containing rule definitions. NRules namespace contains classes that implement the run-time side of the rules engine. RuleCompiler converts rules from the canonical form to a rete network, which is contained within an ISessionFactory. The session factory is then used to create instances of an ISession, which contains the facts that the engine will use for inference (aka working memory). There may be multiple concurrent sessions created off of the same session factory; they will all share the same rete network (which means they will use the same set of rules), but they will use different sets of facts and, from the client's perspective, are completely independent."
  },
  "articles/diagnostics.html": {
    "href": "articles/diagnostics.html",
    "title": "Diagnostics | NRules",
    "keywords": "Diagnostics NRules has several facilities to monitor execution and troubleshoot issues with the rules. There is an event model where one can hook into the engine at various points of the execution cycle. NRules does not directly integrate with any of the .NET logging frameworks, so use these events to hook up the logging framework that your application is using. Metrics provider exposes granular performance information at the level of the underlying Rete graph, which can help with the rules performance profiling. The performance metrics can also be attributed to the individual parts of the rules, by tying those metrics to the structural elements of the Rete network graph and the rule’s AST. There is also a Visual Studio debugger visualizer that can render a rules session as a graph representation of the underlying Rete network, which can greatly assist in understanding of what goes on in the rules engine behind the scenes in a concrete scenario. Execution Event Model Rules engine lifecycle events for a given rules session are exposed via an IEventProvider accessible v through the Events property on the ISession interface. Also, events for all sessions are exposed via the IEventProvider accessible through the ISessionFactory interface (sender object for each event references the actual session object that raised the event). Event provider exposes the following execution events: Category Event Description Working Memory Events FactInsertingEvent Raised when a fact is getting inserted into the session, before it propagates through the Rete network. Working Memory Events FactInsertedEvent Raised when a fact is getting inserted into the session, after it propagates through the Rete network. Working Memory Events FactUpdatingEvent Raised when a fact is getting updated in the session, before it propagates through the Rete network. Working Memory Events FactUpdatedEvent Raised when a fact is getting updated in the session, before it propagates through the Rete network. Working Memory Events FactRetractingEvent Raised when a fact is getting retracted from the session, before it propagates through the Rete network. Working Memory Events FactRetractedEvent Raised when a fact is getting retracted from the session, before it propagates through the Rete network. Agenda Events ActivationCreatedEvent Raised when a rule matches a full set of facts, creating a new activation. Agenda Events ActivationUpdatedEvent Raised when some facts in a rule match are updated, causing an update of the activation. Agenda Events ActivationDeletedEvent Raised when a rule match gets invalidated, causing a deletion of the activation. Agenda Events RuleFiringEvent Raised when a rule activation is selected as the next to fire, before the rule actions are executed. Agenda Events RuleFiredEvent Raised when a rule has fired on an activation, after the actions are executed. Error Handling Events LhsExpressionFailedEvent Raised when an exception is thrown during the evaluation of a left-hand side expression (i.e. a rule's condition, binding expression or aggregation expression). Error Handling Events AgendaExpressionFailedEvent Raised when an exception is thrown during the evaluation of an agenda expression (i.e. a rule's filter expression). Error Handling Events RhsExpressionFailedEvent Raised when an exception is thrown during the evaluation of a right-hand side expression (i.e. a rule's action). Expression Trace Events LhsExpressionEvaluatedEvent Raised after a left-hand side expression is evaluated (i.e. a rule's condition, binding expression or aggregation expression). :warning: Using this event handler may affect engine's performance. Expression Trace Events AgendaExpressionEvaluatedEvent Raised after an agenda expression is evaluated (i.e. a rule's filter expression). :warning: Using this event handler may affect engine's performance. Expression Trace Events RhsExpressionEvaluatedEvent Raised after a right-hand side expression is evaluated (i.e. a rule's action). :warning: Using this event handler may affect engine's performance. ISession session = factory.CreateSession(); session.Events.RuleFiringEvent += OnRuleFiringEvent; //... private static void OnRuleFiringEvent(object sender, AgendaEventArgs e) { Console.WriteLine(\"Rule about to fire {0}\", e.Rule.Name); } Performance Metrics In NRules, rules are compiled into a Rete network for efficient fact matching. As the rules session is going through the execution cycles, it collects performance statistics for each node in the Rete graph. This information could be handy in rules performance profiling. These metrics are used to feed the performance view in the debugger visualizer, but can also be queried programmatically via the IMetricsProvider accessible through the Metrics property on the ISession interface. Metrics accessible via the metrics provider correspond to the nodes in the Rete graph, which represents the compiled rules. This Rete graph can be retrieved from the ISession or ISessionFactory using the GetSchema() method. Each node in the Rete graph contains the information such as the node type, contained expressions, etc., as well as an Id that corresponds to the node Id used by the metrics provider. ReteGraph reteGraph = session.GetSchema(); ReteNode node = reteGraph.Nodes.First(n => n.NodeType == NodeType.BetaMemory); INodeMetrics nodeMetrics = session.Metrics.FindByNodeId(node.Id); long totalTimeSpentMsec = nodeMetrics.InsertDurationMilliseconds + nodeMetrics.UpdateDurationMilliseconds + nodeMetrics.RetractDurationMilliseconds; Console.WriteLine($\"Node {node.Id}:{node.NodeType}. ElementCount={nodeMetrics.ElementCount}, TotalTimeSpentMsec={totalTimeSpentMsec}\"); There are two types of node metrics: those that reflect the current state of the node (e.g. ElementCount that corresponds to the number of elements present in a memory node), and cumulative metrics that are accumulated as facts pass through the nodes. The cumulative metrics for a given node or the whole session can be reset to zero using the Reset() method. session.Metrics.Reset(); Debugger Visualizer Debugger visualiser is an add-on component for Visual Studio that adds visualization capabilities for certain .NET types. Debugger visualizer that comes with NRules adds such visualization capability for ISession and ISessionFactory types. It also requires a 'DGML editor' feature, which must be enabled when installing Visual Studio. NRules debugger visualiser is supported for Visual Studio 2022. NRules debugger visualizer is not packaged, so you need to clone NRules git repository from GitHub and build it yourself. Make sure to clone exactly the same version of the repo as the version of NRules library you are using in your project. To build NRules debugger visualizer, first build NRules: build.bat Then build the visualizer: build.bat Build Visualizer After building, get the contents of <Repo Root>\\binaries\\NRules.Debugger.Visualizer folder and copy to <Documents>\\Visual Studio <Version>\\Visualizers. If installed correctly, any time you debug a program that uses NRules, a magnifying glass icon will appear next to the instances of ISession and ISessionFactory in the watch window. Click on the magnifying glass to open a graphical view of that instance of the rules session. Both ISession and ISessionFactory can produce a visualization for the Rete graph that corresponds to the compiled rules. In addition to that, ISession has an option of generating a visualization for the Rete graph with the embedded performance metrics and styling that helps pinpoint performance bottlenecks. To use it, select a drop-down list next to the magnifying glass, when hovering over the ISession instance, and click 'NRules Session Performance Visualizer'. The rete graph in this mode has peformance metrics attached to the graph nodes, and the graph style reflects them. The thickness of edges reflects the volume of facts flowing through them; the color of nodes reflects the amount of time spent in that node; and the size of memory nodes reflects the number of objects stored in them. Performance properties associated with each node, including the detailed fact counts, timing information and the rules the node belongs to, can be viewed in node tooltips, or in the properties window."
  },
  "articles/dsl-extensions.html": {
    "href": "articles/dsl-extensions.html",
    "title": "DSL Extensions | NRules",
    "keywords": "DSL Extensions When defining rules using internal DSL in C#, the DSL is limited to the verbs provided by the rules engine (see Fluent Rules DSL). Consider this example: [Name(\"Self insured name validation\")] public class SelfInsuredNameValidationRule : Rule { public override void Define() { Claim claim = null; Patient patient = null; When() .Match<Claim>(() => claim) .Match<Patient>(() => patient, p => p == claim.Patient, p => p.RelationshipToInsured == Relationship.Self) .Match<Insured>(i => i == claim.Insured, i => !Equals(patient.Name, i.Name)); Then() .Do(ctx => ctx.Warning(claim, \"Self insured name does not match\")); } } public static class ContextExtensions { public static void Warning(this IContext context, Claim claim, string message) { var warning = new ClaimAlert { Severity = 2, Claim = claim, RuleName = context.Rule.Name, Message = message }; context.Insert(warning); } } This rule matches a claim for a self-insured patient, and makes sure that the name of the patient and insured matches. And if the names don't match, it creates a warning-level claim alert. The rule would look much more readable if we could write it like this: [Name(\"Self insured name validation\")] public class SelfInsuredNameValidationRule : Rule { public override void Define() { Claim claim = null; Patient patient = null; When() .Claim(() => claim) .Patient(() => patient, p => p == claim.Patient, p => p.RelationshipToInsured == Relationship.Self) .Insured(i => i == claim.Insured, i => !Equals(patient.Name, i.Name)); Then() .Warning(claim, \"Self insured name does not match\"); } } And the good news is that this can be done, by defining DSL extension methods like this: public static class DslExtensions { public static ILeftHandSideExpression Claim(this ILeftHandSideExpression lhs, Expression<Func<Claim>> alias, params Expression<Func<Claim, bool>>[] conditions) { return lhs.Match(alias, conditions); } public static ILeftHandSideExpression Patient(this ILeftHandSideExpression lhs, Expression<Func<Patient>> alias, params Expression<Func<Patient, bool>>[] conditions) { return lhs.Match(alias, conditions); } public static ILeftHandSideExpression Insured(this ILeftHandSideExpression lhs, params Expression<Func<Insured, bool>>[] conditions) { return lhs.Match(conditions); } public static IRightHandSideExpression Warning(this IRightHandSideExpression rhs, Claim claim, string message) { return rhs.Do(ctx => ctx.Warning(claim, message)); } }"
  },
  "articles/fluent-rules-dsl.html": {
    "href": "articles/fluent-rules-dsl.html",
    "title": "Fluent Rules DSL | NRules",
    "keywords": "Fluent Rules DSL The standard way to define rules in NRules is with the internal DSL using fluent C# API. A rule is a .NET class that inherits from Rule. Rule class overrides Define method where the actual conditions (left-hand side, or LHS) and actions (right-hand side, or RHS) parts are specified. Within the Define method, LHS is specified by fluently chaining conditions to the When() method; and RHS by fluently chaining actions to Then() method. ⚠️ Make sure rule classes are public, otherwise the engine won't find them. See Fluent Rules Loading on how to load rules defined with the fluent rules DSL. Rule class can also optionally be decorated with the following custom attributes to associate additional metadata with the rule. Attribute Allow Multiple? Inherited? Description Name No No Specifies rule name. Default is the fully qualified rule class name. Description No No Specifies rule description. Default is an empty string. Tag Yes Yes Associates arbitrary tag with the rule (can later be used to group or filter rules). Priority No Yes Sets rule priority. If multiple rules get activated at the same time, rules with higher priority (larger number) get executed first. Priority can be positive or negative. Default is zero. Repeatability No No Sets rule's repeatability, that is, how it behaves when it is activated with the same set of facts multiple times, which is important for recursion control. Repeatability can be set to repeatable - the rule is activated if any of the matched facts are updated, or non-repeatable - the rule is only activated once for a given set of matched facts (unless the match is retracted, before being re-asserted again). Default is Repeatable. [Name(\"MyRule\"), Description(\"Test rule that demonstrates metadata usage\")] [Tag(\"Test\"), Tag(\"Metadata\")] [Priority(10)] [Repeatability(RuleRepeatability.Repeatable)] public class RuleWithMetadata : Rule { public override void Define() { When() .Match<Customer>(c => c.Name == \"John Do\"); Then() .Do(ctx => DoSomething()); } } While fluent rules DSL uses C#, the rules have to be defined using declarative approach. There should be no imperative C# code used anywhere in the rule definition, except within condition expressions, action expressions and methods called from those expressions. If a rule pattern is bound to a variable (see below), that variable should only be used in subsequent condition and action expressions directly. The purpose of the binding variable is to serve as a token (that has a name and a type) that instructs the engine to link corresponding conditions and actions. Don't write any code that manipulates the binding variables outside of the condition/action expressions. Matching Facts with Patterns Rule's left hand side is a set of patterns that match facts of a given type. A pattern is defined using a Match method. A pattern can have zero, one or many conditions that must all be true in order for the pattern to match a given fact. Pattern matching is also polymorphic, which means it matches all facts of a given type and any derived type. Given a class hierarchy of Fruit, Apple and Pear, Match<Fruit> will match both Apples and Pears. Consequently, Match<object> will match all facts in the engine's working memory. If a given pattern matches multiple facts in the engine’s working memory, each match will result in a separate firing of the rule. Optionally, a pattern can be bound to a variable, in which case that variable can be used in subsequent patterns to specify inter-fact conditions. Also, the variable can be used inside actions to update or retract the corresponding fact, or use it in the expression. Do not use or otherwise manipulate the binding variable anywhere outside of the condition/action expressions. public class PreferredCustomerActiveAccountsRule : Rule { public override void Define() { Customer customer = null; Account account = null; When() .Match<Customer>(() => customer, c => c.IsPreferred) .Match<Account>(() => account, a => a.Owner == customer, a => a.IsActive); Then() .Do(ctx => customer.DoSomething()); } } Existential Rules Existential rules test for presence of facts that match a particular set of conditions. An existential quantifier is defined using Exists method. An existential quantifier cannot be bound to a variable, since it does not match any single fact. public class PreferredCustomerActiveAccountsRule : Rule { public override void Define() { Customer customer = null; When() .Match<Customer>(() => customer, c => c.IsPreferred) .Exists<Account>(a => a.Owner == customer, a => a.IsActive); Then() .Do(ctx => customer.DoSomething()); } } Negative Rules Opposite to existential rules, negative rules test for absence of facts that match a particular set of conditions. A negative existential quantifier is defined using Not method. A negative existential quantifier cannot be bound to a variable, since it does not match any single fact. public class PreferredCustomerNotDelinquentRule : Rule { public override void Define() { Customer customer = null; When() .Match<Customer>(() => customer, c => c.IsPreferred) .Not<Account>(a => a.Owner == customer, a => a.IsDelinquent); Then() .Do(ctx => customer.DoSomething()); } } Universal Quantifier Universal quantifier ensures that all facts that match a particular condition also match all subsequent conditions defined by the quantifier. A universal quantifier is defined using All method. A universal quantifier cannot be bound to a variable, since it does not match any single fact. public class PreferredCustomerAllAccountsActiveRule : Rule { public override void Define() { Customer customer = null; When() .Match<Customer>(() => customer, c => c.IsPreferred) .All<Account>(a => a.Owner == customer, a => a.IsActive); Then() .Do(ctx => customer.DoSomething()); } } Grouping Patterns By default all patterns on the left-hand side of the rule are connected using AND operator. This means that all patterns must match for the rule to activate. Patterns can also be connected using OR operator, as well as combined into nested groups. public class PreferredCustomerOrHasLargeOrderRule : Rule { public override void Define() { Customer customer = null; When() .Or(x => x .Match<Customer>(() => customer, c => c.IsPreferred) .And(xx => xx .Match<Customer>(() => customer, c => !c.IsPreferred) .Exists<Order>(o => o.Customer == customer, o => o.Price >= 1000.00))); Then() .Do(ctx => customer.DoSomething()); } } Rules with Complex Logic In complex rules it is usually required to aggregate or project facts, calculate derived values and correlate different matched facts. The rules engine provides several different DSL operators to express such logic. Rules can match and transform sets of facts using Query syntax, which enables rules authors to apply LINQ operators to matched facts; see [[Reactive LINQ Queries]] for more details. A Let operator binds an expression to a variable, so that the results of intermediate calculations can be used in subsequent rule conditions and actions. Also, Having operator can add new conditions to previously defined patterns, including Let expressions, improving rules expressiveness and composability. public class LargeTotalRule : Rule { public override void Define() { Customer customer = null; IEnumerable<Order> orders = null; double total = 0; When() .Match<Customer>(() => customer, c => c.IsPreferred) .Query(() => orders, x => x .Match<Order>( o => o.Customer == customer, o => o.IsOpen) .Collect()) .Let(() => total, () => orders.Sum(x => x.Amount)) .Having(() => total > 100); Then() .Do(ctx => customer.DoSomething(total)); } }"
  },
  "articles/fluent-rules-loading.html": {
    "href": "articles/fluent-rules-loading.html",
    "title": "Fluent Rules Loading | NRules",
    "keywords": "Fluent Rules Loading NRules fluent API not only provides a mechanism to define rules using internal DSL, but also to discover, instantiate and load these rules into a rule repository, so that they can be compiled into an executable form. See Fluent Rules DSL for an overview of the fluent rules DSL. Loading Rules with Fluent Specification With the fluent rules DSL, each rule is a class, and RuleRepository provides a mechanism to discover and load rules classes at runtime using a fluent load specification. Method Load accepts an action delegate that instructs the repository which assemblies and/or types to scan to load the rules. It also provides advanced filtering capabilities using metadata associated with the rules classes. Example, load all rules from the executing assembly, where rule's name starts with \"Test\" or the rule is tagged with the \"Test\" tag. Load these rules into a rule set called \"MyRuleSet\". var repository = new RuleRepository(); repository.Load(x => x .From(Assembly.GetExecutingAssembly()) .Where(rule => rule.Name.StartsWith(\"Test\") || rule.IsTagged(\"Test\")) .To(\"MyRuleSet\")); If the rule set with a given name already exists then Load method just adds rules to it. Once rules are loaded, the whole repository, or only a subset of rule sets can be compiled to an executable form. var ruleSets = repository.GetRuleSets(); var compiler = new RuleCompiler(); ISessionFactory factory = compiler.Compile(ruleSets.Where(x => x.Name == \"MyRuleSet\")); Rule Activation As part of translating rules from fluent DSL form to the canonical model, rule classes must be instantiated. By default NRules instantiates rule classes using System.Activator. It may be desirable to have control over the instantiation process, so that, for example, rules can be instantiated via an IoC container and injected with dependencies. Whenever RuleRepository needs to instantiate a rule, it calls into a rule activator, represented by the IRuleActivator interface and exposed via the RuleRepository.Activator property. To provide a custom rule activator, implement IRuleActivator interface and set it on the repository. For example, rules can be registered with and resolved via an Autofac IoC container. public class AutofacRuleActivator : IRuleActivator { private readonly ILifetimeScope _scope; public AutofacRuleActivator(ILifetimeScope scope) { _scope = scope; } public IEnumerable<Rule> Activate(Type type) { yield return (Rule)_scope.Resolve(type); } } //Build container var builder = new ContainerBuilder(); builder.RegisterAssemblyTypes(Assembly.GetExecutingAssembly()) .Where(t => t.IsAssignableTo<Rule>()) .AsSelf(); var container = builder.Build(); // Load rules var ruleRepository = new RuleRepository(); ruleRepository.Activator = new AutofacRuleActivator(container); ruleRepository.Load(r => r.From(Assembly.GetExecutingAssembly())); // Compile rules var factory = ruleRepository.Compile();"
  },
  "articles/forward-chaining.html": {
    "href": "articles/forward-chaining.html",
    "title": "Forward Chaining | NRules",
    "keywords": "Forward Chaining A rule in NRules consists of a set of conditions and a set of actions. When a rule matches a set of facts (facts satisfy all rule's conditions), the rule is activated. If it's the highest priority rule to get activated, the rule fires, and its actions are executed. The rules are not limited to only matching facts that were inserted into the engine's memory from the outside of the engine. Rules themselves can produce new facts (or change existing ones), which then would cause other rules to fire. This process of one rule causing the firing of another rule is called forward chaining. Forward chaining is useful in decomposition of the business logic, where complex pieces of logic are broken up into orthogonal rules, and a forward-chained fact serves as an interface between them. Examples of this approach include calculation rules that encapsulate a calculation of a business concept or a new metric on an existing fact, and then other rules using that concept/metric without being concerned about how it was produced. Rules can interact with the rules engine from within the actions using the IContext parameter passed to them by the engine. In particular, rule's actions can insert new facts and update or retract existing ones. When a rule creates new facts, there are two ways in which it can do it - inserting a standalone fact or inserting a linked fact. When a rule inserts a new standalone fact, the fact continues to exist in the engine until it is explicitly retracted, even if the conditions for the rule that produced it become false. These facts are inserted into the rules engine using the Insert, InsertAll or TryInsert methods. The rule can also create a linked fact, which only remains in the engine's memory for as long as the rule that produced it still holds true. If the rule that created a linked fact is no longer active, the linked facts are automatically retracted. Linked facts are inserted into the rules engine using the InsertLinked method. While managing standalone forward-chained facts can be done by directly calling methods on the IContext, managing linked facts is far easier using fluent DSL approach. Fluent Forward Chaining NRules Fluent DSL simplifies creation of linked facts to enable forward chaining. It also automatically keeps linked facts in sync with the rules that produced them. Instead of using a Do action, a rule can use Yield to generate a linked fact. If this is the first activation of the rule for a given set of matching facts, the new linked fact is created. If this is a subsequent activation of the rule (i.e. due to an update to the matching facts), the corresponding linked fact is also updated. Finally, if the rule no longer matches, the corresponding linked facts are automatically retracted. There are two overloads of the Yield method - one with the same calculation for inserts and updates, and another one with different calculations - in the later case an update has access to the previous value of the linked fact. public class PreferredCustomerDiscountRule : Rule { public override void Define() { Customer customer = null; IEnumerable<Order> orders = null; Double total = Double.NaN; When() .Match<Customer>(() => customer, c => c.IsPreferred) .Query(() => orders, x => x .Match<Order>( o => o.Customer == customer, o => o.IsOpen) .Collect()) .Let(() => total, () => orders.Sum(x => x.Amount)) .Having(() => total > 1000); Then() .Yield(_ => new InstantDiscount(customer, total * 0.05)); } } public class PrintInstantDiscountRule : Rule { public override void Define() { InstantDiscount discount = null; When() .Match(() => discount); Then() .Do(_ => Console.WriteLine(\"Customer {0} has instant discount of {1}\", discount.Customer.Name, discount.Amount)); } }"
  },
  "articles/getting-started.html": {
    "href": "articles/getting-started.html",
    "title": "Getting Started | NRules",
    "keywords": "Getting Started This guide shows step by step how to install and use NRules rules engine. Installing NRules Create a new Visual studio Console App project and install NRules package via Package Manager Console > Install-Package NRules Creating Domain Model NRules is geared towards writing rules against a domain model, so we start by creating a simple one, which describes customers and orders. public class Customer { public string Name { get; } public bool IsPreferred { get; set; } public Customer(string name) { Name = name; } public void NotifyAboutDiscount() { Console.WriteLine($\"Customer {Name} was notified about a discount\"); } } public class Order { public int Id { get; } public Customer Customer { get; } public int Quantity { get; } public double UnitPrice { get; } public double PercentDiscount { get; set; } public bool IsOpen { get; set; } = true; public Order(int id, Customer customer, int quantity, double unitPrice) { Id = id; Customer = customer; Quantity = quantity; UnitPrice = unitPrice; } } Creating Rules When using NRules internal DSL, a rule is a class that inherits from Rule. A rule consists of a set of conditions (patterns that match facts in the rules engine's memory) and a set of actions executed by the engine should the rule fire. Let's look at the first rule. We want to find all preferred customers, and for every matching customer we want to collect all orders and apply a discount of 10%. Each pattern in the When part of the rule is bound to a variable via an expression, and then can be used in the Then part of the rule. Also note that if there is more than one pattern in the rule, the patterns must be joined to avoid a Cartesian Product between the matching facts. In this example the orders are joined with the customer. public class PreferredCustomerDiscountRule : Rule { public override void Define() { Customer customer = default; IEnumerable<Order> orders = default; When() .Match<Customer>(() => customer, c => c.IsPreferred) .Query(() => orders, x => x .Match<Order>( o => o.Customer == customer, o => o.IsOpen, o => o.PercentDiscount == 0.0) .Collect() .Where(c => c.Any())); Then() .Do(ctx => ApplyDiscount(orders, 10.0)) .Do(ctx => ctx.UpdateAll(orders)); } private static void ApplyDiscount(IEnumerable<Order> orders, double discount) { foreach (var order in orders) { order.PercentDiscount = discount; } } } The second rule will find all customers that have orders with discounts and will notify them of the discount. It's interesting that this rule relies on the first rule to have fired. In other words, the first rule fires and updates the rules engine's memory, triggering the second rule. This is forward chaining in action. public class DiscountNotificationRule : Rule { public override void Define() { Customer customer = default; When() .Match<Customer>(() => customer) .Exists<Order>(o => o.Customer == customer, o => o.PercentDiscount > 0.0); Then() .Do(_ => customer.NotifyAboutDiscount()); } } Running Rules NRules is an inference engine. It means there is no predefined order in which rules are executed, and it runs a match/resolve/act cycle to figure it out. It first matches facts (instances of domain entities) with the rules and determines which rules can fire. The rules that matched facts are said to be activated. It then resolves the conflict by choosing a single rule that will actually fire. And, finally, it fires the chosen rule by executing its actions. The cycle is repeated until there are no more rules to fire. We need to do several things for the engine to enter the match/resolve/act cycle. First, we need to load the rules and compile them into an internal structure (Rete network), so that the engine knows what the rules are and can efficiently match facts. We do this by creating a rule repository and letting it scan an assembly to find the rule classes. Then we compile the rules into a session factory. Next we need to create a working session with the engine and insert facts into the engine's memory. Finally we tell the engine to start the match/resolve/act cycle. //Load rules var repository = new RuleRepository(); repository.Load(x => x.From(typeof(PreferredCustomerDiscountRule).Assembly)); //Compile rules var factory = repository.Compile(); //Create a working session var session = factory.CreateSession(); //Load domain model var customer = new Customer(\"John Doe\") {IsPreferred = true}; var order1 = new Order(123456, customer, 2, 25.0); var order2 = new Order(123457, customer, 1, 100.0); //Insert facts into rules engine's memory session.Insert(customer); session.Insert(order1); session.Insert(order2); //Start match/resolve/act cycle session.Fire();"
  },
  "articles/reactive-linq-queries.html": {
    "href": "articles/reactive-linq-queries.html",
    "title": "Reactive LINQ Queries | NRules",
    "keywords": "Reactive LINQ Queries Rules are normally written to match individual facts in the rules engine's working memory. But sometimes it is desirable to match the sets of facts. This is where reactive LINQ queries in NRules come into play. A query starts by matching all facts that satisfy a particular set of conditions, but instead of firing the rule for each fact match, reactive query allows further aggregation of matching facts using LINQ-style query operators. For example, one can group matching facts by a set of properties, and can fire the rule for each matching group. The queries are called reactive, because even though it looks like they are querying the rules engine's memory, they are evaluated incrementally, as facts are inserted, updated or retracted from the rules engine. Thus, reactive queries are as efficient as matching individual facts. A query result must be bound to a variable, so that it can then be used within other rule patterns, or by the rule's actions. The following operators are supported in reactive LINQ queries and are defined as extension methods. Match - starts a query by matching facts in rules engine's memory Where - filters source elements by a set of conditions GroupBy - aggregates source elements into groups Collect - aggregates source elements into a collection Select - projects source elements into new elements SelectMany - flattens source collections [Name(\"Preferred customer discount\")] public class PreferredCustomerDiscountRule : Rule { public override void Define() { Customer customer = null; IEnumerable<Order> orders = null; When() .Match<Customer>(() => customer, c => c.IsPreferred) .Query(() => orders, x => x .Match<Order>( o => o.Customer == customer, o => o.IsOpen, o => !o.IsDiscounted) .Collect() .Where(c => c.Any())); Then() .Do(ctx => ApplyDiscount(orders, 10.0))); } }"
  },
  "articles/rule-dependencies.html": {
    "href": "articles/rule-dependencies.html",
    "title": "Rule Dependecies | NRules",
    "keywords": "Rule Dependecies In a production rules engine rules consist of conditions that match facts in the rules engine's memory, and actions that insert, update or retract facts. In a real software project, however, this is not enough. Rules also need ability to interact with the rest of the application. This can be achieved in several ways. Since rules are regular .NET classes, they could just access various singleton and static services. This is obviously less than desirable, since the use of singletons results in tightly-coupled designs and is generally discouraged. A much better design is to resolve dependencies via a DI container. And one option here is to resolve rule types via a container and inject dependencies into them (see Rule Activation). This however presents a problem. Rule classes are instantiated only once in the lifetime of the application, and therefore can only be injected with single-instance services. This may be sufficient for some applications, but when it's not enough there is another alternative. Rules can declare their dependencies using fluent DSL, and rules engine will dynamically resolve those dependencies at runtime. The benefit of this approach is that dependencies are resolved every time the rule fires, which means that the lifetime of the dependencies is now managed by the container. public class DeniedClaimNotificationRule : Rule { public override void Define() { INotificationService service = null; Claim claim = null; Dependency() .Resolve(() => service); When() .Match(() => claim, c => c.Status == ClaimStatus.Denied); Then() .Do(_ => service.ClaimDenied(claim)); } } When declaring a dependency using rules DSL, the dependency is bound to a variable in the same exact way the patterns are bound to fact variables. The service variable can then be used in rule actions. The rules engine will inject the dependency when the rule fires. ⚠️ Rule dependencies cannot be used in rule conditions. In order to be able to use rule dependencies, one must implement IDependencyResolver interface and set resolver instance either at the ISession or at the ISessionFactory level. NRules ships with the implementation of IDependencyResolver as well as IRuleActivator for Autofac IoC container in a separate integration assembly (see NRules.Integration.Autofac). With the integration package, the following fully bootstraps and registers NRules with Autofac container. Registration extensions return registration builders that allow customization of individual registrations. var types = builder.RegisterRules(x => x.AssemblyOf(typeof(MyRule))); builder.RegisterRepository(r => r.Load(x => x.From(types))); builder.RegisterSessionFactory(); builder.RegisterSession();"
  },
  "articles/unit-testing-rules.html": {
    "href": "articles/unit-testing-rules.html",
    "title": "Unit Testing Rules | NRules",
    "keywords": "Unit Testing Rules NRules is a production rules engine, which means rules are defined in a form of When <conditions> Then <actions>. This makes the rules easy to unit test, by creating an isolated rules session with a single rule in it (or a small number of coupled rules), supplying test inputs by inserting facts into the session, calling the Fire method and asserting that the rule fired or didn't fire given those inputs. While it's possible to create your own test fixture to set up the rules engine session and assert rule firings, the NRules.Testing library provides a set of tools to help set up the rules under test, compile them into a rules session, record rule firings, as well as configure and verify rule firing expectations. Setting Up a Test Fixture NRules.Testing library does not depend on any specific unit testing or assertion framework, so by default it just throws an Exception when any assertion fails. To better tailor assertions to the specific unit testing framework, implement an asserter that uses the specific assertion mechanism. The following code uses xUnit to unit test the rules. using NRules.Testing; using Xunit.Sdk; public class XUnitRuleAsserter : IRuleAsserter { public void Assert(RuleAssertResult result) { if (result.Status == RuleAssertStatus.Failed) { throw new XunitException(result.GetMessage()); } } } With the XUnitRuleAsserter we can use the RulesTestFixture to create a base test fixture for all our rule tests. using NRules.Testing; public abstract class BaseRulesTestFixture : RulesTestFixture { protected MyRulesTestFixture() { Asserter = new XUnitRuleAsserter(); } } With the above base test fixture, a rule can be tested in the following way: public class MyRuleTest : BaseRulesTestFixture { public class MyFact { } public class MyRule : Rule { public override void Define() { MyFact fact = default; When() .Match(() => fact); Then() .Do(_ => NoOp()); } private void NoOp() { } } public MyRuleTest() { Setup.Rule<MyRule>(); } [Fact] public void Fire_InsertedOneMatchingFact_FiredOnce() { //Arrange var fact = new MyFact(); Session.Insert(fact); //Act Session.Fire(); //Assert Verify(x => x.Rule().Fired(Times.Once)); } [Fact] public void Fire_NoMatchingFacts_DidNotFire() { //Arrange - Act Session.Fire(); //Assert Verify(x => x.Rule().Fired(Times.Never)); } } Verifying Matched Facts When configuring rule firing expectations, it's possible to set up constraints on the facts matched by the rule, to make expectations more specific. To do this, use corresponding methods on the Matched class. For example, the following code verifies that the rule under test has fired, matching a Customer fact, where IsPreferred is true. Verify(x => x.Rule().Fired(Times.Exactly(3), Matched.Fact<Customer>(c => c.IsPreferred))); Testing Cooperations of Multiple Rules To test multiple rules together in the same test fixture, more than one rule can be registered during the fixture setup. The rule firing expectations with multiple rules can be set by specifying the actual rule type for which the expectations are verified. public class MyRuleTest : BaseRulesTestFixture { public MyRuleTest() { Setup.Rule<MyRule1>(); Setup.Rule<MyRule2>(); } [Fact] public void Fire_InsertedOneMatchingFact_FiredBothRules() { //Arrange var fact = new MyFact(); Session.Insert(fact); //Act Session.Fire(); //Assert Verify(x => { x.Rule<MyRule1>().Fired(Times.Once); x.Rule<MyRule2>().Fired(Times.Twice); }); } } Testing Rules with Dependencies If a rule uses injected dependencies, those can be mocked using any mocking framework, and the mocks can be passed into the rule during construction as part of the test setup. var serviceMock = new Mock<IMyService>(); var rule = new MyRule(serviceMock.Object); Setup.Rule(rule); NRules.Testing is a very capable library; see NRules integration tests on GitHub for a wide range of examples."
  },
  "index.html": {
    "href": "index.html",
    "title": "Rules Engine for .NET | NRules",
    "keywords": "Rules Engine for .NET NRules is an open source rules engine for .NET that is based on the Rete matching algorithm. Rules are authored in C# using internal DSL. NRules is also an inference engine, where, unlike with scripting engines, there is no predefined order in which rules are executed. Instead, inference engine figures out which rules should be activated based on the facts given to it, and then executes them according to a conflict resolution algorithm. Among other features, NRules supports forward chaining, complex fact queries, negative, existential and universal quantifiers. To learn more, go to the corresponding sections of the NRules documentation. Getting Started with NRules To install NRules, get the package from nuget Install the package via the dotnet CLI > dotnet add package NRules Or via the package manager > Install-Package NRules Use the following resources to get up and running with NRules Getting Started Guide Documentation API Documentation Getting Help Use the following discussion and Q&A platforms to get help with NRules Discussions Stack Overflow Gitter Chat Contributing Clone NRules on GitHub. See Contributor Guide for the guidelines on how to contribute to the project."
  }
}